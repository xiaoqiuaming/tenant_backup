/**
 * (C) 2010-2012 Alibaba Group Holding Limited.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * Version: $Id$
 *
 * ob_transformer.cpp
 *
 * Authors:
 *   Guibin Du <tianguan.dgb@taobao.com>
 *\
 */
#include "ob_transformer.h"
#include "ob_table_rpc_scan.h"
#include "ob_table_mem_scan.h"
#include "ob_merge_join.h"
#include "ob_sql_expression.h"
#include "ob_filter.h"
#include "ob_project.h"
#include "ob_set_operator.h"
#include "ob_merge_union.h"
#include "ob_merge_intersect.h"
#include "ob_merge_except.h"
#include "ob_sort.h"
#include "ob_merge_distinct.h"
#include "ob_merge_groupby.h"
#include "ob_merge_join.h"
#include "ob_scalar_aggregate.h"
#include "ob_limit.h"
#include "ob_physical_plan.h"
#include "ob_add_project.h"
#include "ob_insert.h"
#include "ob_update.h"
#include "ob_delete.h"
#include "ob_explain.h"
#include "ob_explain_stmt.h"
#include "ob_delete_stmt.h"
#include "ob_update_stmt.h"
#include "ob_create_table.h"
#include "ob_create_table_stmt.h"
//add liu jun.[MultiUPS] [sql_api] 20150320:b
#include "ob_create_part_func_stmt.h"
#include "ob_drop_part_func_stmt.h"
#include "ob_part_func_executor.h"
//add 20150320:e
#include "ob_drop_table.h"
#include "ob_drop_table_stmt.h"
#include "ob_truncate_table.h" //add zhaoqiong [Truncate Table]:20160318
#include "ob_truncate_table_stmt.h" //add zhaoqiong [Truncate Table]:20160318:b
#include "common/ob_row_desc_ext.h"
#include "ob_create_user_stmt.h"
#include "ob_prepare.h"
#include "ob_prepare_stmt.h"
#include "ob_variable_set.h"
#include "ob_variable_set_stmt.h"
#include "ob_kill_stmt.h"
#include "ob_execute.h"
#include "ob_execute_stmt.h"
#include "ob_deallocate.h"
#include "ob_deallocate_stmt.h"
#include "yylog.h"
#include "WarningBuffer.h"
#include "common/ob_obj_cast.h"
#include "ob_ups_modify.h"
#include "ob_insert_dbsem_filter.h"
#include "ob_inc_scan.h"
#include "ob_mem_sstable_scan.h"
#include "ob_multiple_scan_merge.h"
#include "ob_multiple_get_merge.h"
#include "ob_start_trans_stmt.h"
#include "ob_start_trans.h"
#include "ob_end_trans_stmt.h"
#include "ob_end_trans.h"
#include "ob_expr_values.h"
#include "ob_ups_executor.h"
#include "ob_lock_filter.h"
#include "common/hash/ob_hashmap.h"
#include "common/ob_privilege.h"
#include "common/ob_privilege_type.h"
#include "common/ob_hint.h"
#include "ob_create_user_stmt.h"
#include "ob_drop_user_stmt.h"
#include "ob_grant_stmt.h"
#include "ob_revoke_stmt.h"
#include "ob_set_password_stmt.h"
#include "ob_lock_user_stmt.h"
#include "ob_rename_user_stmt.h"
#include "sql/ob_priv_executor.h"
#include "ob_dual_table_scan.h"
#include "common/ob_trace_log.h"
#include "ob_empty_row_filter.h"
#include "ob_sql_read_strategy.h"
#include "ob_alter_table_stmt.h"
#include "ob_alter_table.h"
#include "ob_alter_sys_cnf_stmt.h"
#include "ob_alter_sys_cnf.h"
#include "ob_schema_checker.h"
#include "ob_row_count.h"
#include "ob_when_filter.h"
#include "ob_kill_session.h"
#include "ob_get_cur_time_phy_operator.h"
#include "ob_change_obi_stmt.h"
#include "ob_change_obi.h"
#include "mergeserver/ob_merge_server_main.h"
#include "common/ob_define.h"
#include "common/roottable/ob_first_tablet_entry_schema.h"
#include <vector>
#include "ob_multi_bind.h" //add tianz [SubQuery_for_Instmt] [JHOBv0.1] 20140404
#include "ob_bind_values.h"//add gaojt [Insert_Subquery_Function] [JHOBv0.1] 20140715
#include "ob_iud_loop_control.h"//add gaojt [Insert_Subquery_Function] [JHOBv0.1] 20140715
//add wenghaixing for fix insert bug decimal key 2014/10/11
#include "ob_postfix_expression.h"
//add e
//add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20160120:b
#include "ob_replace_complete_row_fuse.h"
#include "ob_incomplete_row_filter.h"
#include "ob_replace_semantic_filter.h"
#include "ob_update_semantic_filter.h"
//add 20160120:e
//add wenghaixing [database manage]20150609
#include "ob_create_db_stmt.h"
#include "ob_use_db_stmt.h"
#include "ob_drop_database_stmt.h"
#include "parse_node.h"
//add e
#include "mergeserver/ob_ms_partition_manager.h"
//add wenghaixing [secondary index] 20141025
#include "ob_create_index_stmt.h"
//add e
//add fanqiushi_index
#include "ob_index_trigger.h"
#include "ob_sql_expression.h"
#include "common/page_arena.h"
#include "common/ob_se_array.h"
#include "common/ob_array.h"
//add:e
//add wenghaixing [secondary index upd] 20141127
#include "ob_index_trigger_upd.h"
/*add by wanglei [semi join] 20151231*/
#include "ob_semi_join.h"
//add e
//add steven.h.d [hybrid_join] 20150325
#include "ob_bloomfilter_join.h"
#include "ob_hash_join_single.h"
//add wenghaixing [secondary index drop index]20141223
#include "ob_drop_index.h"
#include "ob_drop_index_stmt.h"
#include "dml_build_plan.h"
//add e
#include "ob_alter_group_stmt.h"
#include "ob_alter_group.h"
// add by liyongfeng:20150105 [secondary index replace]
#include "ob_index_trigger_rep.h"
// add:e
//add lijianqiang [sequence insert] 20150407:b
#include "ob_sequence_insert.h"
//add 20150407:e
//add lijianqiang [sequence delete] 20150515:b
#include "ob_sequence_delete.h"
//add 20150515:e
//add lijianqiang [sequence update] 20150525
#include "ob_sequence_update.h"
//add 20150525:e
//add liuzy [sequence select] 20150608 :b
#include "ob_sequence_select.h"
//add 20150608:e
#include "ob_gather_statistics_stmt.h"
#include "ob_gather_statistics.h"
#include "ob_optimizer_relation.h"
#include "ob_physical_optimizer.h"
//add zhujun [fix equal-subquery bug] 20151013:b
#include "ob_create_view.h"
#include "ob_create_view_stmt.h"
#include "ob_drop_view.h"
#include "ob_drop_view_stmt.h"
using namespace oceanbase::common;
using namespace oceanbase::sql;
typedef int ObMySQLSessionKey;
#define TRANS_LOG(...)                                                  \
  do{                                                                   \
  snprintf(err_stat.err_msg_, MAX_ERROR_MSG, __VA_ARGS__);            \
  YYSYS_LOG(WARN, __VA_ARGS__);                                       \
  } while(0)

#define CREATE_PHY_OPERRATOR(op, type_name, physical_plan, err_stat)    \
  ({                                                                    \
  op = (type_name*)trans_malloc(sizeof(type_name));   \
  if (op == NULL) \
{ \
  err_stat.err_code_ = OB_ERR_PARSER_MALLOC_FAILED; \
  TRANS_LOG("Can not malloc space for %s", #type_name);  \
  } \
  else\
{\
  op = new(op) type_name();    \
  op->set_phy_plan(physical_plan);              \
  if ((err_stat.err_code_ = physical_plan->store_phy_operator(op)) != OB_SUCCESS) \
{ \
  TRANS_LOG("Add physical operator failed");  \
  } \
  else                                        \
{                                           \
  ob_inc_phy_operator_stat(op->get_type()); \
  }                                           \
  } \
  op;})

//mod peiouya  [NotNULL_check] [JHOBv0.1] 20131222:b
/*expr: it is convenient to use if context is added to transformer construct*/
//ObTransformer::ObTransformer(ObSqlContext &context)
ObTransformer::ObTransformer(ObSqlContext &context, ObResultSet & result)
//mod 20131222:e
{
  mem_pool_ = context.transformer_allocator_;
  OB_ASSERT(mem_pool_);
  sql_context_ = &context;
  //add peiouya [NotNULL_check] [JHOBv0.1] 20131222:b
  result_ = &result;
  //add 20131222:e
  group_agg_push_down_param_ = false;
  is_multi_batch_ = false;
  stat_extractor_.set_statistic_info_cache(ObMergeServerMain::get_instance()->get_merge_server().get_statistic_info_cache());
  is_first_on_expr_with_index_=true;
}

ObTransformer::~ObTransformer()
{
}

inline void *ObTransformer::trans_malloc(const size_t nbyte)
{
    OB_ASSERT(mem_pool_);
//add support for arm platform by wangd 202106:b
#if defined(__aarch64__)
    size_t nbyte_align = (nbyte + 7) & ~(7);
#else
    size_t nbyte_align = nbyte;
#endif
//add support for arm platform by wangd 202106:e
    return mem_pool_->alloc(nbyte_align);//mod support for arm platform by wangd 202106
}

inline void ObTransformer::trans_free(void* p)
{
  OB_ASSERT(mem_pool_);
  mem_pool_->free(p);
}

int ObTransformer::generate_physical_plans(
    ObMultiLogicPlan &logical_plans,
    ObMultiPhyPlan &physical_plans,
    ErrStat& err_stat)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  // check environment
  if (NULL == sql_context_
      || NULL == sql_context_->merger_rpc_proxy_
      || NULL == sql_context_->schema_manager_
      || NULL == sql_context_->session_info_)
  {
    ret = OB_NOT_INIT;
    TRANS_LOG("sql_context not init");
  }
  else
  {
    // get group_agg_push_down_param_
    ObString param_str = ObString::make_string(OB_GROUP_AGG_PUSH_DOWN_PARAM);
    ObObj val;
    if (sql_context_->session_info_->get_sys_variable_value(param_str, val) != OB_SUCCESS
        || val.get_bool(group_agg_push_down_param_) != OB_SUCCESS)
    {
      YYSYS_LOG(DEBUG, "Can not get param %s", OB_GROUP_AGG_PUSH_DOWN_PARAM);
      // default off
      group_agg_push_down_param_ = false;
    }
  }
  ObLogicalPlan *logical_plan = NULL;
  ObPhysicalPlan *physical_plan = NULL;
  for (int32_t i = 0; ret == OB_SUCCESS && i < logical_plans.size(); i++)
  {
    logical_plan = logical_plans.at(i);
    if ((ret = generate_physical_plan(logical_plan, physical_plan, err_stat)) == OB_SUCCESS)
    {
      if ((ret = physical_plans.push_back(physical_plan)) != OB_SUCCESS)
      {
        TRANS_LOG("Add physical plan failed");
        break;
      }
    }
  }
  return ret;
}

int ObTransformer::generate_physical_plan(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan*& physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index,
    bool optimizer_open)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  bool new_generated = false;
  if (logical_plan)
  {
    if (OB_LIKELY(NULL == physical_plan))
    {
      if ((physical_plan = (ObPhysicalPlan*)trans_malloc(sizeof(ObPhysicalPlan))) == NULL)
      {
        ret = OB_ERR_PARSER_MALLOC_FAILED;
        TRANS_LOG("Can not malloc space for ObPhysicalPlan");
      }
      else
      {
        physical_plan = new(physical_plan) ObPhysicalPlan();
        YYSYS_LOG(DEBUG, "new physical plan, addr=%p", physical_plan);
        new_generated = true;
      }
    }
    ObBasicStmt *stmt = NULL;
    if (ret == OB_SUCCESS)
    {
      if (query_id == OB_INVALID_ID)
        stmt = logical_plan->get_main_stmt();
      else
        stmt = logical_plan->get_query(query_id);
      if (stmt == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Wrong query id to find query statement");
      }
    }
    YYSYS_LOG(DEBUG, "generate physical plan for query_id=%lu stmt_type=%d",
              query_id, stmt->get_stmt_type());
    if (OB_LIKELY(ret == OB_SUCCESS))
    {
      switch (stmt->get_stmt_type())
      {
        case ObBasicStmt::T_SELECT:
        {
          optimizer_open = logical_plan->get_query_optimizer_open();
          ObSelectStmt *select_stmt = NULL;
          if ((ret = get_stmt(logical_plan, err_stat, query_id, select_stmt)) != OB_SUCCESS)
          {
            optimizer_open = false;
          }
          if (optimizer_open)
          {
            ObOptimizerRelation *sub_query_relation = NULL;
            void * buf = logical_plan->get_name_pool()->alloc(sizeof(ObOptimizerRelation));
            if (buf == NULL)
            {
              ret = OB_ALLOCATE_MEMORY_FAILED;
            }
            else
            {
              sub_query_relation = new (buf)ObOptimizerRelation(ObOptimizerRelation::RELOPT_INIT);
              if (ObOPtimizerLoger::log_switch_)
              {
                bool flag = false;
                if (select_stmt->get_from_item_size() == 1)
                {
                  TableItem *table_item = NULL;
                  table_item = select_stmt->get_table_item_by_id(select_stmt->get_from_item(0).table_id_);
                  if (table_item == NULL)
                  {
                    YYSYS_LOG(ERROR, "get table_item fail. table_id = %ld", select_stmt->get_from_item(0).table_id_);
                  }
                  else if(table_item->ref_id_ <= common::OB_APP_MIN_TABLE_ID + 2000)
                  {
                    flag = true;
                  }
                }
                if(!flag)
                {
                  ObOPtimizerLoger::resetFile();
                }
              }
              ObPhysicalOptimizer physical_optimizer(this);
              ret = physical_optimizer.gen_join_method(logical_plan, physical_plan, err_stat, query_id, sub_query_relation);
              if (ret == OB_SUCCESS)
              {
                YYSYS_LOG(DEBUG, "gen join method successfully!");
                ObOptimizerRelation* tmp = select_stmt->get_select_stmt_rel_info();
                if (tmp)
                {
                  delete tmp;
                }
                select_stmt->set_select_stmt_rel_info(sub_query_relation);
                optimizer_open = true;
              }
              else
              {
                sub_query_relation->~ObOptimizerRelation();
                optimizer_open = false;
                ret = OB_SUCCESS;
              }
            }
          }
          logical_plan->set_query_optimizer_open(optimizer_open);
          //ret = gen_physical_select(logical_plan, physical_plan, err_stat, query_id, index);
          ret = gen_physical_select(logical_plan, physical_plan, err_stat, query_id, index, optimizer_open);
          break;
        }
        case ObBasicStmt::T_DELETE:
          ret = gen_physical_delete_new(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_INSERT:
          ret = gen_physical_insert_new(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_REPLACE:
          // mod by liyongfeng:20150105 [secondary index replace]: gen_physical_replace ==> gen_physical_replace_new
          //ret = gen_physical_replace(logical_plan, physical_plan, err_stat, query_id, index);
          ret = gen_physical_replace_new(logical_plan, physical_plan, err_stat, query_id, index);
          // mod:e
          break;
        case ObBasicStmt::T_UPDATE:
          ret = gen_physical_update_new(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_EXPLAIN:
          ret = gen_physical_explain(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_CREATE_TABLE:
          ret = gen_physical_create_table(logical_plan, physical_plan, err_stat, query_id, index);
          break;
          //add zhaoqiong [Truncate Table]:20160318:b
        case ObBasicStmt::T_TRUNCATE_TABLE:
          ret = gen_physical_truncate_table(logical_plan, physical_plan, err_stat, query_id, index);
          break;
          //add:e
        case ObBasicStmt::T_ALTER_GROUP:
          ret = gen_physical_alter_group(logical_plan, physical_plan, err_stat, query_id, index);
          break;
          //add liu jun.[MultiUps_Live_sql_api] 20150320:b
        case ObBasicStmt::T_CREATE_PART_FUNC:
        case ObBasicStmt::T_DROP_PART_FUNC:
          ret = gen_physical_part_func_stmt(logical_plan, physical_plan, err_stat, query_id, index);
          break;
          //add 20150320:e
        case ObBasicStmt::T_DROP_TABLE:
          ret = gen_physical_drop_table(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_ALTER_TABLE:
          ret = gen_physical_alter_table(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_SHOW_TABLES:
        case ObBasicStmt::T_SHOW_SYSTEM_TABLES:// add by zhangcd [multi_database.show_tables] 20150616
          //add liumengzhan_show_index [20141208]
        case ObBasicStmt::T_SHOW_INDEX:
          //add:e
        case ObBasicStmt::T_SHOW_ALL_INDEX:
        case ObBasicStmt::T_SHOW_CREATE_INDEX:
        case ObBasicStmt::T_SHOW_VARIABLES:
        case ObBasicStmt::T_SHOW_COLUMNS:
        case ObBasicStmt::T_SHOW_SCHEMA:
        case ObBasicStmt::T_SHOW_CREATE_TABLE:
        case ObBasicStmt::T_SHOW_CREATE_VIEW:
        case ObBasicStmt::T_SHOW_TABLE_STATUS:
        case ObBasicStmt::T_SHOW_SERVER_STATUS:
        case ObBasicStmt::T_SHOW_WARNINGS:
        case ObBasicStmt::T_SHOW_GRANTS:
        case ObBasicStmt::T_SHOW_PARAMETERS:
        case ObBasicStmt::T_SHOW_FUNCTIONS:
        case ObBasicStmt::T_SHOW_TABLE_RULES://add wuna.[MultiUPS] [sql_api] 20160223
        case ObBasicStmt::T_SHOW_GROUPS://add wuna.[MultiUPS] [sql_api] 20160223
        case ObBasicStmt::T_SHOW_CURRENT_PAXOS_ID:
        case ObBasicStmt::T_SHOW_PROCESSLIST:
        case ObBasicStmt::T_SHOW_DATABASES:  //add dolphin [show database]@20150604
        case ObBasicStmt::T_SHOW_CURRENT_DATABASE:  // add by zhangcd [multi_database.show_databases] 20150617
          ret = gen_physical_show(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_PREPARE:
          ret = gen_physical_prepare(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_VARIABLE_SET:
          ret = gen_physical_variable_set(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_EXECUTE:
          ret = gen_physical_execute(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_DEALLOCATE:
          ret = gen_physical_deallocate(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_START_TRANS:
          ret = gen_physical_start_trans(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_END_TRANS:
          ret = gen_physical_end_trans(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_ALTER_SYSTEM:
          ret = gen_physical_alter_system(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_CREATE_USER:
        case ObBasicStmt::T_DROP_USER:
        case ObBasicStmt::T_SET_PASSWORD:
        case ObBasicStmt::T_LOCK_USER:
        case ObBasicStmt::T_RENAME_USER:
        case ObBasicStmt::T_GRANT:
        case ObBasicStmt::T_REVOKE:
          //add wenghaixing [database manage]20150609
        case ObBasicStmt::T_CREATE_DATABASE:
        case ObBasicStmt::T_USE_DATABASE:
        case ObBasicStmt::T_DROP_DATABASE:
          ret = gen_physical_priv_stmt(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_KILL:
          ret = gen_physical_kill_stmt(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_CREATE_INDEX:
          ret =gen_physical_create_index(logical_plan, physical_plan, err_stat, query_id, index);
          break;
          //add e
          //add wenghaixing[secondary index drop index]20141223
        case ObBasicStmt::T_DROP_INDEX:
          ret = gen_physical_drop_index(logical_plan, physical_plan, err_stat, query_id, index);
          break;
          //add e
        case ObBasicStmt::T_GATHER_STATISTICS:
          ret = gen_physical_gather_statistics(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_CREATE_VIEW:
          ret = gen_physical_create_view(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        case ObBasicStmt::T_DROP_VIEW:
          ret = gen_physical_drop_view(logical_plan, physical_plan, err_stat, query_id, index);
          break;
        default:
          ret = OB_NOT_SUPPORTED;
          TRANS_LOG("Unknown logical plan, stmt_type=%d", stmt->get_stmt_type());
          break;
      }
    }

    if (OB_SUCCESS == ret
        //mod liuzy [datetime func] 20150909:b
        /*Exp: use count of ObArray*/
        //      && NO_CUR_TIME != logical_plan->get_cur_time_fun_type()
        && 0 != logical_plan->get_cur_time_fun_type_size()
        //mod 20150909:e
        && OB_INVALID_ID == query_id)
    {
      ret = add_cur_time_plan(physical_plan, err_stat, logical_plan->get_cur_time_fun_type());
      if (OB_SUCCESS != ret)
      {
        TRANS_LOG("failed to add cur_time_plan: ret=[%d]", ret);
      }
    }

    if (ret != OB_SUCCESS && new_generated && physical_plan != NULL)
    {
      physical_plan->~ObPhysicalPlan();
      trans_free(physical_plan);
      physical_plan = NULL;
    }
  }
  return ret;
}

//mod liuzy [datetime func] 20150909:b
/*Exp: modify "const ObCurTimeType&" to "ObArray<ObCurTimeType>&"*/
//int ObTransformer::add_cur_time_plan(ObPhysicalPlan *physical_plan, ErrStat& err_stat, const ObCurTimeType& type)
int ObTransformer::add_cur_time_plan(ObPhysicalPlan *physical_plan, ErrStat& err_stat, const ObArray<ObCurTimeType>& type)
//mod 20150909:b
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObGetCurTimePhyOperator *get_cur_time_op = NULL;

  if (NULL == physical_plan)
  {
    ret = OB_ERR_UNEXPECTED;
    YYSYS_LOG(ERROR, "physical_plan must not be NULL");
  }

  if (OB_SUCCESS == ret)
  {
    CREATE_PHY_OPERRATOR(get_cur_time_op, ObGetCurTimePhyOperator, physical_plan, err_stat);
    if (OB_SUCCESS == ret)
    {
      //add liuzy [datetime func] 20150909:b
      for (int64_t idx = 0, size = type.count(); idx < size; ++idx)
      {
        YYSYS_LOG(DEBUG, "add_cur_time_plan: idx = [%ld], size = [%ld]", idx, size);
        //add 20150909:e
        //mod liuzy [datetime func] 20150909:b
        //        get_cur_time_op->set_cur_time_fun_type(type);
        get_cur_time_op->set_cur_time_fun_type(type.at(idx));
        //mod 20150909:e
      }//add liuzy [datetime func] /*Exp:end for*/
      if (OB_SUCCESS != (ret = physical_plan->set_pre_phy_query(get_cur_time_op)))
      {
        TRANS_LOG("Add physical operator(get_cur_time_op) failed, err=%d", ret);
      }
    }
  }
  //add liuzy [datetime func] 20150909:b
  for (int64_t idx = 0, size = type.count(); idx < size; ++idx)
  {
    //add 20150909:e
    if (CUR_TIME_UPS == type.at(idx) && OB_SUCCESS == ret)
    {
      get_cur_time_op->set_rpc_stub(sql_context_->merger_rpc_proxy_);
      // physical plan to be done on ups
      if (OB_SUCCESS == ret)
      {
        ObPhysicalPlan *ups_physical_plan = NULL;
        if (NULL == (ups_physical_plan = (ObPhysicalPlan*)trans_malloc(sizeof(ObPhysicalPlan))))
        {
          ret = OB_ERR_PARSER_MALLOC_FAILED;
          TRANS_LOG("Can not malloc space for ObPhysicalPlan");
        }
        else
        { // result set of ups_physical_plan will be set in get_cur_time_op.open
          ups_physical_plan = new(ups_physical_plan) ObPhysicalPlan();
          YYSYS_LOG(DEBUG, "new physical plan, addr=%p", ups_physical_plan);
        }

        if (OB_SUCCESS == ret)
        {
          int32_t idx = 0;
          ObProject *project = NULL;
          CREATE_PHY_OPERRATOR(project, ObProject, ups_physical_plan, err_stat);
          if (OB_SUCCESS == ret && OB_SUCCESS != (ret = ups_physical_plan->add_phy_query(project, &idx, true)))
          {
            TRANS_LOG("Add physical operator(cur_time_op) failed, err=%d", ret);
          }

          if (OB_SUCCESS == ret)
          {
            ObSqlExpression expr;
            ExprItem item;

            expr.set_tid_cid(OB_INVALID_ID, OB_MAX_TMP_COLUMN_ID);
            item.type_ = T_CUR_TIME_OP;

            if (OB_SUCCESS != (ret = expr.add_expr_item(item)))
            {
              TRANS_LOG("add expr item failed, ret=%d", ret);
            }
            else if (OB_SUCCESS != (ret = expr.add_expr_item_end()))
            {
              TRANS_LOG("add expr end failed, ret=%d", ret);
            }
            else if (OB_SUCCESS != (ret = project->add_output_column(expr)))
            {
              TRANS_LOG("add expr item failed, ret=%d", ret);
            }
          }

          if (OB_SUCCESS == ret)
          {
            ObDualTableScan *dual_table_op = NULL;
            CREATE_PHY_OPERRATOR(dual_table_op, ObDualTableScan, physical_plan, err_stat);
            if (OB_SUCCESS == ret && OB_SUCCESS != (ret = project->set_child(0, *dual_table_op)))
            {
              TRANS_LOG("add ObDualTableScan on ObProject failed, ret=%d", ret);
            }
          }
        }

        if (OB_SUCCESS == ret)
        {
          get_cur_time_op->set_ups_plan(ups_physical_plan);
        }
      }
      break;//add liuzy [datetime func] 20150910 /*Exp: jump our of for-loop*/
    }
  }//add liuzy [datetime func] 20150909 /*Exp: end for*/
  return ret;
}

template <class T>
int ObTransformer::get_stmt(
    ObLogicalPlan *logical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    T *& stmt)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  /* get statement */
  if (query_id == OB_INVALID_ID)
  {
    stmt = dynamic_cast<T*>(logical_plan->get_main_stmt());
  }
  else
  {
    stmt = dynamic_cast<T*>(logical_plan->get_query(query_id));
  }
  if (stmt == NULL)
  {
    err_stat.err_code_ = OB_ERR_PARSER_SYNTAX;
    TRANS_LOG("Get Stmt error");
  }
  return ret;
}

template <class T>
int ObTransformer::add_phy_query(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    T * stmt,
    ObPhyOperator *phy_op,
    int32_t* index
    )
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  if (query_id == OB_INVALID_ID || stmt == dynamic_cast<T*>(logical_plan->get_main_stmt()))
    ret = physical_plan->add_phy_query(phy_op, index, true);
  else
    ret = physical_plan->add_phy_query(phy_op, index);
  if (ret != OB_SUCCESS)
    TRANS_LOG("Add query of physical plan failed");
  return ret;
}

//add fanqiushi_index

bool ObTransformer::is_index_table_has_all_cid_V2(uint64_t index_tid,Expr_Array *filter_array,Expr_Array *project_array)
{
  //�ж��������Ƿ����sql����г��ֵ������� //repaired from messy code by zhuxh 20151014
  bool return_ret=true;
  if(sql_context_->schema_manager_->is_this_table_avalibale(index_tid))
  {
    int64_t w_num=project_array->count();
    for(int32_t i=0;i<w_num;i++)
    {
      ObSqlExpression  col_expr=project_array->at(i);
      //YYSYS_LOG(ERROR,"test::fanqs,,col_expr=%s",to_cstring(col_expr));
      if(!col_expr.is_all_expr_cid_in_indextable(index_tid,sql_context_->schema_manager_))
      {
        return_ret=false;
        break;
      }

    }
    int64_t c_num=filter_array->count();
    for(int32_t j=0;j<c_num;j++)
    {

      ObSqlExpression c_filter=filter_array->at(j);
      if(!c_filter.is_all_expr_cid_in_indextable(index_tid,sql_context_->schema_manager_))
      {
        return_ret=false;
        break;
      }


    }

  }
  //YYSYS_LOG(ERROR,"test::fanqs,,return_ret=%d,,index_tid=%ld",return_ret,index_tid);
  return return_ret;

}


int64_t ObTransformer::is_cid_in_index_table(uint64_t cid,uint64_t tid)
{
  //�жϸ����Ƿ��ڸ��������С������0����ʾ���ڣ������1����ʾ�������������������������2����ʾ�������������ķ����� //repaired from messy code by zhuxh 20151014
  int64_t return_ret=0;
  int ret=OB_SUCCESS;
  bool is_in_rowkey=false;
  bool is_in_other_column=false;
  const ObTableSchema *index_table_schema = NULL;
  if (NULL == (index_table_schema = sql_context_->schema_manager_->get_table_schema(tid)))
  {
    ret = OB_ERROR;
    YYSYS_LOG(WARN,"Fail to get table schema for table[%ld]", tid);
  }
  else
  {
    uint64_t tmp_cid=OB_INVALID_ID;
    int64_t rowkey_column=index_table_schema->get_rowkey_info().get_size();
    for(int64_t j=0;j<rowkey_column;j++)
    {
      if(OB_SUCCESS!=(ret=index_table_schema->get_rowkey_info().get_column_id(j,tmp_cid)))
      {
        YYSYS_LOG(ERROR,"get column schema failed,cid[%ld]",tmp_cid);
        ret=OB_SCHEMA_ERROR;
      }
      else
      {
        if(tmp_cid==cid)
        {
          is_in_rowkey=true;
          break;
        }
      }
    }
    // YYSYS_LOG(ERROR,"test::fanqs,,cid=%ld,is_in_rowkey=%d",cid,is_in_rowkey);
    if(!is_in_rowkey)
    {
      /* uint64_t max_cid=OB_INVALID_ID;
            max_cid=index_table_schema->get_max_column_id();
            //YYSYS_LOG(ERROR,"test::fanqs,,max_cid=%ld,",max_cid);
            for(uint64_t k=OB_APP_MIN_COLUMN_ID;k<=max_cid;k++)
            {
                if(cid==k)
                {
                    is_in_other_column=true;
                    break;
                }
            }*/
      const ObColumnSchemaV2* index_column_schema=NULL;
      index_column_schema=sql_context_->schema_manager_->get_column_schema(tid,cid);
      if(index_column_schema!=NULL)
      {
        is_in_other_column=true;
      }
    }
  }
  if(is_in_rowkey)
    return_ret=1;
  else if(is_in_other_column)
    return_ret=2;
  return return_ret;
}
//add by [semi join second index] 20151231:b
bool ObTransformer::is_this_expr_can_use_index_for_join(uint64_t cid,uint64_t &index_tid,uint64_t main_tid,const ObSchemaManagerV2 *sm_v2)
{
  bool return_ret = false;
  uint64_t tmp_index_tid[OB_MAX_INDEX_NUMS];
  for(int32_t m=0;m<OB_MAX_INDEX_NUMS;m++)
  {
    tmp_index_tid[m]=OB_INVALID_ID;
  }
  if(sm_v2->is_cid_in_index(cid,main_tid,tmp_index_tid))
  {
    index_tid=tmp_index_tid[0];
    return_ret=true;
    //YYSYS_LOG(ERROR,"test::fanqs,column_count=%d,EQ_count=%d",column_count,EQ_count);
  }
  return return_ret;
}
bool ObTransformer::is_expr_can_use_storing_for_join(uint64_t cid,uint64_t mian_tid,uint64_t &index_tid,Expr_Array * filter_array,Expr_Array *project_array)
{
  bool ret=false;
  uint64_t expr_cid=cid;
  uint64_t tmp_index_tid=OB_INVALID_ID;
  uint64_t index_tid_array[OB_MAX_INDEX_NUMS];
  for(int32_t k=0;k<OB_MAX_INDEX_NUMS;k++)
  {
    index_tid_array[k]=OB_INVALID_ID;
  }

  if(sql_context_->schema_manager_->is_cid_in_index(expr_cid,mian_tid,index_tid_array))  //����ԭ����tid���ҵ��ñ������еĵ�һ����Ϊexpr_cid�����������浽index_tid_array���� //repaired from messy code by zhuxh 20151014
  {
    for(int32_t i=0;i<OB_MAX_INDEX_NUMS;i++)  //��ÿ�ŷ���������������  //repaired from messy code by zhuxh 20151014
    {
      // YYSYS_LOG(ERROR,"test::fanqs,,index_tid_array[i]=%ld",index_tid_array[i]);
      //uint64_t tmp_tid=index_tid_array[i];
      if(index_tid_array[i]!=OB_INVALID_ID)
      {
        if(is_index_table_has_all_cid_V2(index_tid_array[i],filter_array,project_array)) //�ж��Ƿ�������sql���������ֵ��У�����������������  //repaired from messy code by zhuxh 20151014
        {
          tmp_index_tid=index_tid_array[i];
          //YYSYS_LOG(ERROR,"test::fanqs,,tmp_index_tid=%ld",tmp_index_tid);
          ret=true;
          break;
        }
      }
    }
    index_tid=tmp_index_tid;
  }

  return ret;
}
//add:e
bool ObTransformer::is_expr_can_use_storing_V2(ObSqlExpression c_filter,uint64_t mian_tid,uint64_t &index_tid,Expr_Array * filter_array,Expr_Array *project_array)
{
  //uint64_t &index_tid����������tid  //repaired from messy code by zhuxh 20151014
  bool ret=false;
  uint64_t expr_cid=OB_INVALID_ID;
  uint64_t tmp_index_tid=OB_INVALID_ID;
  uint64_t index_tid_array[OB_MAX_INDEX_NUMS];
  for(int32_t k=0;k<OB_MAX_INDEX_NUMS;k++)
  {
    index_tid_array[k]=OB_INVALID_ID;
  }
  //[742]
  if(OB_SUCCESS==c_filter.get_cid(expr_cid))  //��ñ���ʽ�д���е�column id:expr_cid���������ʽ���ж��У�����ret������OB_SUCCESS
  {
    if(sql_context_->schema_manager_->is_cid_in_index(expr_cid,mian_tid,index_tid_array))  //����ԭ����tid���ҵ��ñ������еĵ�һ����Ϊexpr_cid�����������浽index_tid_array���� //repaired from messy code by zhuxh 20151014
    {
      for(int32_t i=0;i<OB_MAX_INDEX_NUMS;i++)  //��ÿ�ŷ���������������  //repaired from messy code by zhuxh 20151014
      {
        // YYSYS_LOG(ERROR,"test::fanqs,,index_tid_array[i]=%ld",index_tid_array[i]);
        //uint64_t tmp_tid=index_tid_array[i];
        if(index_tid_array[i]!=OB_INVALID_ID)
        {
          if(is_index_table_has_all_cid_V2(index_tid_array[i],filter_array,project_array)) //�ж��Ƿ�������sql���������ֵ��У�����������������  //repaired from messy code by zhuxh 20151014
          {
            tmp_index_tid=index_tid_array[i];
            //YYSYS_LOG(ERROR,"test::fanqs,,tmp_index_tid=%ld",tmp_index_tid);
            ret=true;
            break;
          }
        }
      }
      index_tid=tmp_index_tid;
    }
  }
  return ret;
}
//add liumz, [optimize group_order by index]20170419:b
int ObTransformer::optimize_order_by_index(ObArray<uint64_t> &idx_tids, uint64_t main_tid, uint64_t &index_table_id, bool &hit_index_ret, ObStmt *stmt, ObLogicalPlan *logical_plan)
{
  int ret = OB_SUCCESS;
  if (ObBasicStmt::T_SELECT == stmt->get_stmt_type() && 1 == stmt->get_table_size())
  {
    ObSelectStmt* select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
    int32_t num = select_stmt->get_order_item_size();
    YYSYS_LOG(DEBUG, "idx_tids.count()[%ld]", idx_tids.count());
    for (int64_t j = 0; ret == OB_SUCCESS && num > 0 && j < idx_tids.count(); j++)
    {
      uint64_t index_tid = idx_tids.at(j);
      const ObTableSchema *idx_table_schema = NULL;
      if (NULL == (idx_table_schema = sql_context_->schema_manager_->get_table_schema(index_tid)))
      {
        ret = OB_ERROR;
        YYSYS_LOG(WARN,"Fail to get table schema for table[%ld]",index_tid);
      }
      else
      {
        const ObRowkeyInfo &idx_rk_info = idx_table_schema->get_rowkey_info();
        //TODO
        bool hit_index = false;
        for (int32_t i = 0; ret == OB_SUCCESS && num <= idx_rk_info.get_size() && i < num; i++)
        {
          uint64_t column_id = OB_INVALID_ID;
          const OrderItem& order_item = select_stmt->get_order_item(i);
          ObSqlRawExpr *order_expr = logical_plan->get_expr(order_item.expr_id_);
          if (OB_SUCCESS != (ret = idx_rk_info.get_column_id(i, column_id)))
          {
            hit_index = false;
            break;
          }
          if (OrderItem::ASC == order_item.order_type_ && order_expr && order_expr->get_expr()->get_expr_type() == T_REF_COLUMN)
          {
            if (main_tid == order_expr->get_table_id() && column_id == order_expr->get_column_id())
            {
              hit_index = true;
              continue;
            }
            else
            {
              hit_index = false;
              break;
            }
          }
          else
          {
            hit_index = false;
            break;
          }
        }//end for
        if (ret == OB_SUCCESS && hit_index)
        {
          hit_index_ret = true;
          index_table_id = index_tid;
          for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
          {
            select_stmt->get_order_item_flag(i) = 1;//set applied flag
          }
          break;
        }
      }
    }//end for
  }
  return ret;
}

int ObTransformer::optimize_group_by_index(ObArray<uint64_t> &idx_tids, uint64_t main_tid, uint64_t &index_table_id, bool &hit_index_ret, ObStmt *stmt, ObLogicalPlan *logical_plan)
{
  int ret = OB_SUCCESS;
  if (ObBasicStmt::T_SELECT == stmt->get_stmt_type() && 1 == stmt->get_table_size())
  {
    ObSelectStmt* select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
    int32_t num = select_stmt->get_group_expr_size();
    YYSYS_LOG(DEBUG, "idx_tids.count()[%ld]", idx_tids.count());
    for (int64_t j = 0; ret == OB_SUCCESS && num > 0 && j < idx_tids.count(); j++)
    {
      uint64_t index_tid = idx_tids.at(j);
      const ObTableSchema *idx_table_schema = NULL;
      if (NULL == (idx_table_schema = sql_context_->schema_manager_->get_table_schema(index_tid)))
      {
        ret = OB_ERROR;
        YYSYS_LOG(WARN,"Fail to get table schema for table[%ld]",index_tid);
      }
      else
      {
        const ObRowkeyInfo &idx_rk_info = idx_table_schema->get_rowkey_info();
        //TODO
        bool hit_index = false;
        for (int32_t i = 0; ret == OB_SUCCESS && num <= idx_rk_info.get_size() && i < num; i++)
        {
          uint64_t column_id = OB_INVALID_ID;
          ObSqlRawExpr *group_expr = logical_plan->get_expr(select_stmt->get_group_expr_id(i));
          if (OB_SUCCESS != (ret = idx_rk_info.get_column_id(i, column_id)))
          {
            hit_index = false;
            break;
          }
          if (group_expr && group_expr->get_expr()->get_expr_type() == T_REF_COLUMN)
          {
            if (main_tid == group_expr->get_table_id() && column_id == group_expr->get_column_id())
            {
              hit_index = true;
              continue;
            }
            else
            {
              hit_index = false;
              break;
            }
          }
          else
          {
            hit_index = false;
            break;
          }
        }//end for
        if (ret == OB_SUCCESS && hit_index)
        {
          hit_index_ret = true;
          index_table_id = index_tid;
          for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
          {
            select_stmt->get_group_expr_flag(i) = 1;//set applied flag
          }
          break;
        }
      }
    }//end for
  }
  return ret;
}
//add:e

bool ObTransformer::is_wherecondition_have_main_cid_V2(Expr_Array *filter_array,uint64_t main_cid)
{   //���where������ĳ������ʽ��main_cid��ĳ������ʽ�ж����,����true //repaired from messy code by zhuxh 20151014
  bool return_ret=false;
  int ret=OB_SUCCESS;

  int64_t c_num = filter_array->count();
  int32_t i = 0;
  for ( ;ret == OB_SUCCESS && i < c_num; i++)
  {
    ObSqlExpression c_filter = filter_array->at(i);
    //add wanglei [second index fix] 20160425:b
    if(!c_filter.is_expr_has_more_than_two_columns())
    {
      if(c_filter.is_have_main_cid(main_cid))
      {
        return_ret=true;
        break;
      }
    }
    //add wanglei [second index fix] 20160425:e
    //        if(c_filter.is_have_main_cid(main_cid))
    //        {
    //            return_ret=true;
    //            break;
    //        }
  }
  return return_ret;
}

//add wenghaixing [secondary index for paper]20150505
bool ObTransformer::if_rowkey_in_expr(Expr_Array *filter_array, uint64_t main_tid)
{
  bool return_ret=false;
  uint64_t tid=main_tid;
  // uint64_t index_tid=OB_INVALID_ID;
  const ObTableSchema *mian_table_schema = NULL;
  if (NULL == (mian_table_schema = sql_context_->schema_manager_->get_table_schema(tid)))
  {
    YYSYS_LOG(WARN,"Fail to get table schema for table[%ld]",tid);
  }
  else
  {
    const ObRowkeyInfo *rowkey_info = &mian_table_schema->get_rowkey_info();
    uint64_t main_cid=OB_INVALID_ID;
    rowkey_info->get_column_id(0,main_cid);
    return_ret = is_wherecondition_have_main_cid_V2(filter_array,main_cid);

  }
  return return_ret;
}
//add e
bool ObTransformer::decide_is_use_storing_or_not_V2(Expr_Array  *filter_array,
                                                    Expr_Array *project_array,
                                                    uint64_t &index_table_id,
                                                    uint64_t main_tid,
                                                    Join_column_Array *join_column,//add by wanglei [semi join second index] 20151231
                                                    ObStmt *stmt,//add by wanglei [semi join second index] 20151231
                                                    //add liumz, [optimize group_order by index]20170419:b
                                                    ObLogicalPlan *logical_plan,
                                                    Expr_Array *order_array,
                                                    Expr_Array *group_array
                                                    //add:e
                                                    )
{
  //�����bool����   ����ֵ�� uint64_t &index_table_id����������tid
  bool return_ret=false;
  int ret=OB_SUCCESS;

  uint64_t tid=main_tid;
  uint64_t index_tid=OB_INVALID_ID;
  const ObTableSchema *mian_table_schema = NULL;
  if (NULL == (mian_table_schema = sql_context_->schema_manager_->get_table_schema(tid)))
  {
    YYSYS_LOG(WARN,"Fail to get table schema for table[%ld]",tid);
  }
  else
  {
    ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt *>(stmt);
    bool is_max_min_eliminate = (select_stmt != NULL ? select_stmt->is_max_min_eliminate() : false);
    if (is_max_min_eliminate)
    {
      uint64_t col_id = select_stmt->get_eliminate_index_col_id();
      const ObTableSchema *main_table_schema = NULL;
      if (NULL == (main_table_schema = sql_context_->schema_manager_->get_table_schema(tid)))
      {
        YYSYS_LOG(WARN, "Fail to get table schema for table[%ld]",tid);
      }
      else
      {
        const ObRowkeyInfo *rowkey_info = &mian_table_schema->get_rowkey_info();
        if (!rowkey_info->is_rowkey_column(col_id))
        {
          uint64_t index_tid_array[OB_MAX_INDEX_NUMS];
          for (int32_t k = 0;k < OB_MAX_INDEX_NUMS; k++)
          {
            index_tid_array[k] = OB_INVALID_ID;
          }
          if(sql_context_->schema_manager_->is_cid_in_index(col_id, tid, index_tid_array))
          {
            for (int32_t i=0;i < OB_MAX_INDEX_NUMS;i++)
            {
              if (index_tid_array[i] != OB_INVALID_ID)
              {
                if (is_index_table_has_all_cid_V2(index_tid_array[i], filter_array, project_array))
                {
                  index_table_id = index_tid_array[i];
                  return_ret = true;
                  YYSYS_LOG(DEBUG, "choose index id with storing %ld",index_table_id);
                  break;
                }
              }
            }
          }
        }
        else
        {
          YYSYS_LOG(DEBUG, "max_min_eliminate rowkey choose origin table in with storing");
        }
      }
    }
    else
    {
      const ObRowkeyInfo *rowkey_info = &mian_table_schema->get_rowkey_info();
      uint64_t main_cid=OB_INVALID_ID;
      rowkey_info->get_column_id(0,main_cid);  //���ԭ���ĵ�һ������column id,�浽main_cid���� //repaired from messy code by zhuxh 20151014
      if(!is_wherecondition_have_main_cid_V2(filter_array,main_cid))  //�ж�where�������Ƿ���ԭ���ĵ�һ����������У��������� //repaired from messy code by zhuxh 20151014
      {
        //add by wanglei [semi join second index] 20151231:b
        //���where�����еı���ʽ���в���ԭ�����������ж����Ƿ�����������ر���������
        if(stmt ==NULL)
        {
          ret = OB_ERR_POINTER_IS_NULL;
          YYSYS_LOG(WARN,"[semi join] stmt is null!");
        }
        else  if(stmt->get_query_hint().join_array_.size()>0)
        {
          ObJoinTypeArray tmp_join_type = stmt->get_query_hint().join_array_.at(0);
          if(tmp_join_type.join_type_ == T_SEMI_JOIN ||tmp_join_type.join_type_ == T_SEMI_BTW_JOIN)
          {
            for(int l=0;l<join_column->count();l++)
            {
              if(is_expr_can_use_storing_for_join(join_column->at(l),tid,index_tid,filter_array,project_array))
              {
                index_table_id=index_tid;
                return_ret=true;
                break;
              }
            }
          }
        }
        //add:e
        int64_t c_num = filter_array->count();
        ObArray<uint64_t> idx_tids;//add liumz, [optimize group_order by index]20170419
        for (int32_t i = 0; ret == OB_SUCCESS && i < c_num; i++)    //��where�����е����б���ʽ���δ��� //repaired from messy code by zhuxh 20151014
        {
          ObSqlExpression c_filter=filter_array->at(i);
          //add wanglei [second index fix] 20160425:b
          if(!c_filter.is_expr_has_more_than_two_columns ())
          {
            if(is_expr_can_use_storing_V2(c_filter,tid,index_tid,filter_array,project_array))  //�жϸñ���ʽ�ܷ�ʹ�ò��ر�������
            {
              //mod liumz, [optimize group_order by index]20170419:b
              YYSYS_LOG(DEBUG, "index_tid[%ld]", index_tid);
              idx_tids.push_back(index_tid);
              return_ret=true;
              /*index_table_id=index_tid;
                            return_ret=true;
                            break;*/
              //mod:e
            }
          }
          //add wanglei [second index fix] 20160425:e
          //                if(is_expr_can_use_storing_V2(c_filter,tid,index_tid,filter_array,project_array))  //�жϸñ���ʽ�ܷ�ʹ�ò��ر�������
          //                {
          //                    index_table_id=index_tid;
          //                    return_ret=true;
          //                    break;
          //                }
        }
        //add liumz, [optimize group_order by index]20170419:b
        if (OB_SUCCESS == ret)
        {
          bool index_group = false;
          bool index_order = false;
          uint64_t index_group_table_id = OB_INVALID_ID;
          uint64_t index_order_table_id = OB_INVALID_ID;
          if (return_ret && idx_tids.count() > 0)
          {
            index_table_id = idx_tids.at(0);//pick the first index table, default
            index_group_table_id = idx_tids.at(0);//pick the first index table, default
            index_order_table_id = idx_tids.at(0);//pick the first index table, default
            if (group_array->count() > 0 && OB_SUCCESS != (ret = optimize_group_by_index(idx_tids, tid, index_group_table_id, index_group, stmt, logical_plan)))
            {
              YYSYS_LOG(WARN, "optimize_group_by_index failed, ret = %d", ret);
            }
            if (OB_SUCCESS == ret && order_array->count() > 0)
            {
              if (index_group)
              {
                idx_tids.clear();
                idx_tids.push_back(index_group_table_id);
              }
              if ((index_group || 0 == group_array->count())
                  && OB_SUCCESS != (ret = optimize_order_by_index(idx_tids, tid, index_order_table_id, index_order, stmt, logical_plan)))
              {
                YYSYS_LOG(WARN, "optimize_order_by_index failed, ret = %d", ret);
              }
            }
          }
          else
          {
            //check whether we can use index without storing, if not, check group or order column
            bool is_use_index_without_storing=false;
            for(int32_t j=0; j<c_num; j++)
            {
              ObSqlExpression &c_filter=filter_array->at(j);
              if(c_filter.is_this_expr_can_use_index(index_tid,tid,sql_context_->schema_manager_))
              {
                is_use_index_without_storing=true;
                break;
              }
            }
            if (!is_use_index_without_storing && group_array->count() > 0)
            {
              idx_tids.clear();
              ObSqlExpression &c_filter = group_array->at(0);
              if(!c_filter.is_expr_has_more_than_two_columns ())
              {
                if(is_expr_can_use_storing_V2(c_filter,tid,index_tid,filter_array,project_array))
                {
                  idx_tids.push_back(index_tid);
                  if (OB_SUCCESS != (ret = optimize_group_by_index(idx_tids, tid, index_group_table_id, index_group, stmt, logical_plan)))
                  {
                    YYSYS_LOG(WARN, "optimize_group_by_index failed, ret = %d", ret);
                  }
                }
              }
            }//end if
            if (OB_SUCCESS == ret && !is_use_index_without_storing && order_array->count() > 0)
            {
              idx_tids.clear();
              if (index_group)
              {
                idx_tids.push_back(index_group_table_id);
                if (OB_SUCCESS != (ret = optimize_order_by_index(idx_tids, tid, index_order_table_id, index_order, stmt, logical_plan)))
                {
                  YYSYS_LOG(WARN, "optimize_order_by_index failed, ret = %d", ret);
                }
              }
              else if (0 == group_array->count())
              {
                ObSqlExpression &c_filter = order_array->at(0);
                if(!c_filter.is_expr_has_more_than_two_columns ())
                {
                  if(is_expr_can_use_storing_V2(c_filter,tid,index_tid,filter_array,project_array))
                  {
                    idx_tids.push_back(index_tid);
                    if (OB_SUCCESS != (ret = optimize_order_by_index(idx_tids, tid, index_order_table_id, index_order, stmt, logical_plan)))
                    {
                      YYSYS_LOG(WARN, "optimize_order_by_index failed, ret = %d", ret);
                    }
                  }
                }
              }
            }//end if
          }
          //set return_ret & index_table_id
          if (index_group)
          {
            return_ret = index_group;
            index_table_id = index_group_table_id;
          }
          else if (index_order)
          {
            return_ret = index_order;
            index_table_id = index_order_table_id;
          }
        }
        //add liumz, [optimize group_order by index]20170419:e
      }
      //add by wanglei [semi join second index] 20151231:b
      //���hint�е�һ������semi join��ô����ʹ��ʧЧ
      else
      {
        if(stmt ==NULL)
        {
          ret = OB_ERR_POINTER_IS_NULL;
          YYSYS_LOG(WARN,"[semi join] stmt is null!");
        }
        else if(stmt->get_query_hint().join_array_.size()>0)
        {
          ObJoinTypeArray tmp_join_type = stmt->get_query_hint().join_array_.at(0);
          if(tmp_join_type.join_type_ == T_SEMI_JOIN ||tmp_join_type.join_type_ == T_SEMI_BTW_JOIN)
          {
            for(int l=0;l<join_column->count();l++)
            {
              if(is_expr_can_use_storing_for_join(join_column->at(l),tid,index_tid,filter_array,project_array))
              {
                index_table_id=index_tid;
                return_ret=true;
              }
            }
          }
        }
      }
      //add:e
    }
  }
  // YYSYS_LOG(ERROR,"test::fanqs,,return_ret=%d,index_table_id=%ld",return_ret,index_table_id);
  return return_ret;
}


bool ObTransformer::is_can_use_hint_for_storing_V2(
    Expr_Array *filter_array,
    Expr_Array *project_array,
    uint64_t index_table_id,
    Join_column_Array *join_column,//add by wanglei [semi join second index] 20151231
    ObStmt *stmt)//add by wanglei [semi join second index] 20151231
{
  bool cond_has_main_cid = false;
  bool can_use_hint_for_storing = false;
  const ObTableSchema *index_table_schema = NULL;
  if (NULL == (index_table_schema = sql_context_->schema_manager_->get_table_schema(index_table_id)))
  {
    YYSYS_LOG(WARN, "Fail to get table schema for table[%ld]", index_table_id);
  }
  else if(sql_context_->schema_manager_->is_this_table_avalibale(index_table_id))
  {
    const ObRowkeyInfo& rowkey_info = index_table_schema->get_rowkey_info();
    uint64_t index_key_cid = OB_INVALID_ID;
    // ����������ĵ�һ������column id
    if(OB_SUCCESS != rowkey_info.get_column_id(0, index_key_cid))
    {
      YYSYS_LOG(WARN, "Fail to get column id, index_table name:[%s], index_table id: [%ld]",
                index_table_schema->get_table_name(), index_table_schema->get_table_id());
      cond_has_main_cid = false;
    }
    // �ж�where�����ı���ʽ���Ƿ�����������ĵ�һ������ÿ������ʽ��ֻ��һ����������һ�����������ĵ�һ����ʱ����true

    //add by wanglei [semi join second index] 20151231:b
    //ע��
    //������û�п��ǵ������Σ����where����ʽ������������cid�ı���ʽ����ô�Ͳ������semi join�ļ�����̣��Ͳ�֪��
    //hint�е��������������Ƿ���on����ʽ�е�cid��ͬ�����,�����where����ʽ���з���is_wherecondition_have_main_cid_V2
    //�ı���ʽʱ����Ҫ�ж�һ��on�е���id��ָ����������������id�Ƿ���ͬ��
    else if(!is_wherecondition_have_main_cid_V2(filter_array,index_key_cid))
    {
      //add by wanglei [semi join second index] 20151231:b
      //���where�����еı���ʽ�������������ĵ�һ�������ж����Ƿ�����������ر���������
      if(stmt ==NULL)
      {
        YYSYS_LOG(WARN,"[semi join] stmt is null!");
      }
      else if(stmt->get_query_hint().join_array_.size()>0)
      {
        ObJoinTypeArray tmp_join_type = stmt->get_query_hint().join_array_.at(0);
        if(tmp_join_type.join_type_ == T_SEMI_JOIN ||tmp_join_type.join_type_ == T_SEMI_BTW_JOIN)
        {
          //ʵ��join_column��ֻ��һ��Ԫ��
          for(int l=0;l<join_column->count();l++)
          {
            if(join_column->at(l) == index_key_cid )
            {
              cond_has_main_cid = true;
            }
            else
            {
              cond_has_main_cid = false;
            }
          }
        }
        else
        {
          cond_has_main_cid = false;
        }
      }
      else
      {
        cond_has_main_cid = false;
      }
      //add:e
      //ԭ���̴��룺b
      //cond_has_main_cid = false;
      //e
    }
    else
    {
      //add wanglei [semi join second index] 20160106 :b
      //���where����ʽ���з��������ı���ʽ����ô��Ҫ���on����ʽ�еĶ�Ӧ������id�Ƿ���
      //ָ����������������id��ͬ
      if(stmt ==NULL)
      {
        YYSYS_LOG(WARN,"[semi join] stmt is null!");
      }
      else if(stmt->get_query_hint().join_array_.size()>0)
      {
        ObJoinTypeArray tmp_join_type = stmt->get_query_hint().join_array_.at(0);
        if(tmp_join_type.join_type_ == T_SEMI_JOIN ||tmp_join_type.join_type_ == T_SEMI_BTW_JOIN)
        {
          //ʵ��join_column��ֻ��һ��Ԫ��
          for(int l=0;l<join_column->count();l++)
          {
            if(join_column->at(l) != index_key_cid )
            {
              cond_has_main_cid = false;
            }
            else
            {
              cond_has_main_cid = true;
            }
          }
        }
        else
        {
          cond_has_main_cid = true;
        }
      }
      else
      {
        cond_has_main_cid = true;
      }
      //add e
      //ԭ���̴��룺b
      //cond_has_main_cid = true;
      //e
    }
  }

  if(cond_has_main_cid)
  {
    // ���where�����а����������ĵ�һ�������ж���Щ����ʽ�е��к�select��������ǲ��Ƕ�����������
    can_use_hint_for_storing = is_index_table_has_all_cid_V2(index_table_id,filter_array,project_array );
  }
  // �������where��������ʹ�������������������Ϊ����ʹ����������storing
  else
  {
    can_use_hint_for_storing = false;
  }

  return can_use_hint_for_storing;
}

bool ObTransformer::is_can_use_hint_index_V2(
    Expr_Array *filter_ayyay,
    uint64_t index_table_id,
    Join_column_Array *join_column,//add by wanglei [semi join second index] 20151231
    ObStmt *stmt  //add by wanglei [semi join second index] 20151231
    )
{
  bool can_use_hint_index = false;
  bool cond_has_main_cid = false;
  const ObTableSchema *index_table_schema = NULL;
  if (NULL == (index_table_schema = sql_context_->schema_manager_->get_table_schema(index_table_id)))
  {
    YYSYS_LOG(WARN, "Fail to get table schema for table[%ld]", index_table_id);
  }
  else
  {
    const ObRowkeyInfo& rowkey_info = index_table_schema->get_rowkey_info();
    uint64_t index_key_cid = OB_INVALID_ID;
    // ����������ĵ�һ������column id
    if(OB_SUCCESS != rowkey_info.get_column_id(0, index_key_cid))
    {
      YYSYS_LOG(WARN, "Fail to get column id, index_table name:[%s], index_table id: [%ld]",
                index_table_schema->get_table_name(), index_table_schema->get_table_id());
      cond_has_main_cid = false;
    }
    // �ж�where�����ı���ʽ���Ƿ�����������ĵ�һ������ÿ������ʽ��ֻ��һ����������һ�����������ĵ�һ����ʱ����true
    else if(!is_wherecondition_have_main_cid_V2(filter_ayyay,index_key_cid))
    {
      //add by wanglei [semi join second index] 20151231:b
      //���where�����еı���ʽ�������������ĵ�һ�������ж����Ƿ�����������ر���������
      if(stmt ==NULL)
      {
        YYSYS_LOG(WARN,"[semi join] stmt is null!");
      }
      else if(stmt->get_query_hint().join_array_.size()>0)
      {
        ObJoinTypeArray tmp_join_type = stmt->get_query_hint().join_array_.at(0);
        if(tmp_join_type.join_type_ == T_SEMI_JOIN ||tmp_join_type.join_type_ == T_SEMI_BTW_JOIN)
        {
          //mod dragon [] 2016-11-9
          //���join_column,ֻҪ��һ�������������ĵ�һ����������true
          for(int l=0;l<join_column->count();l++)
          {
            if(join_column->at(l) == index_key_cid )
            {
              cond_has_main_cid = true;
              break;
            }
            else
            {
              cond_has_main_cid = false;
            }
          }

          /*---old code as below---
                    //ʵ��join_column��ֻ��һ��Ԫ��
                    for(int l=0;l<join_column->count();l++)
                    {
                        if(join_column->at(l) == index_key_cid )
                        {
                            cond_has_main_cid = true;
                        }
                        else
                        {
                            cond_has_main_cid = false;
                        }
                    }
                  -------old code-----*/

          //mod e
        }
        else
        {
          cond_has_main_cid = false;
        }
      }
      else
      {
        cond_has_main_cid = false;
      }
      //add:e
      //cond_has_main_cid = false;
    }
    else
    {
      //add by wanglei [semi join second index] 20151231:b
      if(stmt ==NULL)
      {
        YYSYS_LOG(WARN,"[semi join] stmt is null!");
      }
      else  if(stmt->get_query_hint().join_array_.size()>0)
      {
        ObJoinTypeArray tmp_join_type = stmt->get_query_hint().join_array_.at(0);
        if(tmp_join_type.join_type_ == T_SEMI_JOIN ||tmp_join_type.join_type_ == T_SEMI_BTW_JOIN)
        {
          //ʵ��join_column��ֻ��һ��Ԫ��
          for(int l=0;l<join_column->count();l++)
          {
            if(join_column->at(l) == index_key_cid )
            {
              cond_has_main_cid = true;
            }
            else
            {
              cond_has_main_cid = false;
            }
          }
        }
        else
        {
          cond_has_main_cid = true;
        }
      }
      else
      {
        cond_has_main_cid = true;
      }
      //add:e
      // cond_has_main_cid = true;
    }
  }

  if(cond_has_main_cid)
  {
    can_use_hint_index = true;
  }
  if(!sql_context_->schema_manager_->is_this_table_avalibale(index_table_id))
  {
    can_use_hint_index=false;
  }
  return can_use_hint_index;
}


//add:e


int ObTransformer::gen_physical_select(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index,
    bool optimizer_open)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObSelectStmt  *select_stmt = NULL;
  ObPhyOperator *result_op = NULL;
  /* get statement */
  if ((ret = get_stmt(logical_plan, err_stat, query_id, select_stmt)) != OB_SUCCESS)
  {
  }
  else if (select_stmt->is_for_update())
  {
    if ((ret = gen_phy_select_for_update(
           logical_plan,
           physical_plan,
           err_stat,
           query_id,
           index)) != OB_SUCCESS)
    {
      //TRANS_LOG("Transform select for update statement failed");
    }
    //mod 20150917:e
  }
  else if(select_stmt->is_partition_calc_func())
  {
    select_stmt->set_is_partition_calc_func(false);
    if ((ret = gen_phy_select_partition_calc_func(
           logical_plan,
           physical_plan,
           err_stat,
           query_id,
           index)) != OB_SUCCESS)
    {
      TRANS_LOG("Transform select partition_calc() failed");
    }
  }
  else
  {
    //add hongchen [FIX_SUPPORT_READ_ATOMIC] 20170612:b
    //if(select_stmt->is_support_read_atomic())
    if(false)
    {
      common::ObReadAtomicLevel& read_atomic_level = select_stmt->get_query_hint().read_atomic_level_;
      if (read_atomic_level < common::READ_ATOMIC_WEAK)
      {
        read_atomic_level = common::READ_ATOMIC_WEAK;
        select_stmt->get_query_hint().read_atomic_weak_time_limit_ = -1;
      }
    }
    //add hongchen [FIX_SUPPORT_READ_ATOMIC] 20170612:e
    ObSelectStmt::SetOperator set_type = select_stmt->get_set_op();
    if (set_type != ObSelectStmt::NONE)
    {
      ObSetOperator *set_op = NULL;
      common::ObArray<common::ObObjType> tmp_result_columns_type;
      tmp_result_columns_type = select_stmt->get_result_type_array();
      if (ret == OB_SUCCESS)
      {
        switch (set_type)
        {
          case ObSelectStmt::UNION :
          {
            ObMergeUnion *union_op = NULL;
            CREATE_PHY_OPERRATOR(union_op, ObMergeUnion, physical_plan, err_stat);
            /*del qianzm [set_operation] 20160115:b
                    for (int i = 0; i < select_stmt->get_result_type_array().count(); i ++)
                    {
                      ObObjType res_type = select_stmt->get_result_type_array().at(i);
                      union_op->get_result_type_array().push_back(res_type);
                    }
                    del 20160115:e
          */
            //add qianzm [set_operation] 20160115
            if (OB_SUCCESS == ret)//add qianzm[null operator unjudgement bug1181] 20160520
            {
              union_op->add_result_type_array(tmp_result_columns_type);
            }
            //add 20160115:e
            set_op = union_op;
            break;
          }
          case ObSelectStmt::INTERSECT :
          {
            ObMergeIntersect *intersect_op = NULL;
            CREATE_PHY_OPERRATOR(intersect_op, ObMergeIntersect, physical_plan, err_stat);
            /*del qianzm [set_operation] 20160115:b
                    for (int i = 0; i < select_stmt->get_result_type_array().count(); i ++)
                    {
                      ObObjType res_type = select_stmt->get_result_type_array().at(i);
                      intersect_op->get_result_type_array().push_back(res_type);
                    }
                    del 20160115:e
          */
            //add qianzm [set_operation] 20160115
            if (OB_SUCCESS == ret)//add qianzm[null operator unjudgement bug1181] 20160520
            {
              intersect_op->add_result_type_array(tmp_result_columns_type);
            }
            //add 20160115:e
            set_op = intersect_op;
            break;
          }
          case ObSelectStmt::EXCEPT :
          {
            ObMergeExcept *except_op = NULL;
            CREATE_PHY_OPERRATOR(except_op, ObMergeExcept, physical_plan, err_stat);
            /*del qianzm [set_operation] 20160115:b
                    for (int i = 0; i < select_stmt->get_result_type_array().count(); i ++)
                    {
                      ObObjType res_type = select_stmt->get_result_type_array().at(i);
                      except_op->get_result_type_array().push_back(res_type);
                    }
                    del 20160115:e
          */
            //add qianzm [set_operation] 20160115
            if (OB_SUCCESS == ret)//add qianzm[null operator unjudgement bug1181] 20160520
            {
              except_op->add_result_type_array(tmp_result_columns_type);
            }
            //add 20160115:e
            set_op = except_op;
            break;
          }
          default:
            break;
        }
        if (OB_SUCCESS == ret)  // ret is a reference to err_stat.err_code_
        {
          set_op->set_distinct(select_stmt->is_set_distinct() ? true : false);
        }
      }
      int32_t lidx = OB_INVALID_INDEX;
      int32_t ridx = OB_INVALID_INDEX;
      if (ret == OB_SUCCESS)
      {
        ret = gen_physical_select(
                logical_plan,
                physical_plan,
                err_stat,
                select_stmt->get_left_query_id(),
                &lidx,
                optimizer_open);
      }
      if (ret == OB_SUCCESS)
      {
        ret = gen_physical_select(
                logical_plan,
                physical_plan,
                err_stat,
                select_stmt->get_right_query_id(),
                &ridx,
                optimizer_open);
      }

      if (ret == OB_SUCCESS)
      {
        ObPhyOperator *left_op = physical_plan->get_phy_query(lidx);
        ObPhyOperator *right_op = physical_plan->get_phy_query(ridx);
        ObSelectStmt *lselect = dynamic_cast<ObSelectStmt*>(logical_plan->get_query(select_stmt->get_left_query_id()));
        ObSelectStmt *rselect = dynamic_cast<ObSelectStmt*>(logical_plan->get_query(select_stmt->get_right_query_id()));
        if (set_type != ObSelectStmt::UNION || select_stmt->is_set_distinct())
        {
          // 1
          // select c1+c2 from tbl
          // union
          // select c3+c4 rom tbl
          // order by 1;

          // 2
          // select c1+c2 as cc from tbl
          // union
          // select c3+c4 from tbl
          // order by cc;

          // there must be a Project operator on union part,
          // so do not worry non-column expr appear in sot operator

          //CREATE sort operators
          /* Create first sort operator */
          ObSort *left_sort = NULL;
          if (CREATE_PHY_OPERRATOR(left_sort, ObSort, physical_plan, err_stat) == NULL)
          {
          }
          else if (ret == OB_SUCCESS && (ret = left_sort->set_child(0, *left_op)) != OB_SUCCESS)
          {
            TRANS_LOG("Set child of sort operator failed");
          }
          ObSqlRawExpr *sort_expr = NULL;
          for (int32_t i = 0; ret == OB_SUCCESS && i < lselect->get_select_item_size(); i++)
          {
            sort_expr = logical_plan->get_expr(lselect->get_select_item(i).expr_id_);
            if (sort_expr == NULL || sort_expr->get_expr() == NULL)
            {
              ret = OB_ERR_ILLEGAL_ID;
              TRANS_LOG("Get internal expression failed");
              break;
            }
            ret = left_sort->add_sort_column(sort_expr->get_table_id(), sort_expr->get_column_id(), true);
            if (ret != OB_SUCCESS)
            {
              TRANS_LOG("Add sort column failed");
            }
          }

          /* Create second sort operator */
          ObSort *right_sort = NULL;
          if (ret == OB_SUCCESS)
            CREATE_PHY_OPERRATOR(right_sort, ObSort, physical_plan, err_stat);
          if (ret == OB_SUCCESS && (ret = right_sort->set_child(0 /* first child */, *right_op)) != OB_SUCCESS)
          {
            TRANS_LOG("Set child of sort operator failed");
          }
          for (int32_t i = 0; ret == OB_SUCCESS && i < rselect->get_select_item_size(); i++)
          {
            sort_expr = logical_plan->get_expr(rselect->get_select_item(i).expr_id_);
            if (sort_expr == NULL || sort_expr->get_expr() == NULL)
            {
              ret = OB_ERR_ILLEGAL_ID;
              TRANS_LOG("Get internal expression failed");
              break;
            }
            ret = right_sort->add_sort_column(sort_expr->get_table_id(), sort_expr->get_column_id(), true);
            if (ret != OB_SUCCESS)
            {
              TRANS_LOG("Add sort column failed");
              break;
            }
          }
          //add qianzm [set_operation] 20151222 :b
          if (set_type == ObSelectStmt::UNION && !select_stmt->is_set_distinct())
          {
          }
          else
          {
            left_sort->set_is_set_op_flag();
            right_sort->set_is_set_op_flag();
            /*del qianzm [set_operation] 20160115:b
                        for (int i = 0; i < select_stmt->get_result_type_array().count(); i ++)
                        {
                            ObObjType res_type = select_stmt->get_result_type_array().at(i);
                            left_sort->get_result_type_array().push_back(res_type);
                            right_sort->get_result_type_array().push_back(res_type);
                        }
                        //del 20160115:e*/
            //add qianzm [set_operation] 20160115:b
            left_sort->add_result_type_array_for_setop(tmp_result_columns_type);
            right_sort->add_result_type_array_for_setop(tmp_result_columns_type);
            //add 20160115:e
          }
          //add e
          left_op = left_sort;
          right_op = right_sort;
        }
        OB_ASSERT(NULL != set_op);
        set_op->set_child(0 /* first child */, *left_op);
        set_op->set_child(1 /* second child */, *right_op);
      }
      result_op = set_op;

      // generate physical plan for order by
      if (ret == OB_SUCCESS && select_stmt->get_order_item_size() > 0)
        ret = gen_phy_order_by(logical_plan, physical_plan, err_stat, select_stmt, result_op, result_op, true);

      // generate physical plan for limit
      if (ret == OB_SUCCESS && select_stmt->has_limit())
      {
        ret = gen_phy_limit(logical_plan, physical_plan, err_stat, select_stmt, result_op, result_op);
      }

      if (ret == OB_SUCCESS)
      {
        ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, select_stmt, result_op, index);
      }
    }
    else
    {
      /* Normal Select Statement */
      bool group_agg_pushed_down = false;
      bool limit_pushed_down = false;
      //add liuzy [sequence select] [JHOBv0.1] 20150525:b
      ObSequenceSelect *sequence_select_op = NULL;
      if (select_stmt->has_sequence())
      {
        //add shili, [MultiUPS] [merge transaction code]20170309
        physical_plan->set_result_set(result_);
        //add e
        ObSEArray<int64_t, 64> row_desc_map;
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          CREATE_PHY_OPERRATOR(sequence_select_op, ObSequenceSelect, physical_plan, err_stat);
        }
        if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
        {
        }
        else if (OB_SUCCESS != (ret = wrap_sequence(logical_plan, physical_plan, err_stat,
                                                    row_desc_map, sequence_select_op, select_stmt)))
        {
          TRANS_LOG("wrap sequence failed");
        }
        /*get the sequence info from the "__all_sequences" for all prevval use*/
        else if (OB_SUCCESS != (ret = sequence_select_op->prepare_sequence_prevval()))
        {
          TRANS_LOG("prepare sequence info failed!");
        }
        else
        {
          sequence_select_op->copy_sequence_info_from_select_stmt(select_stmt);
        }
      }
      //add 20150525:e
      // 1. generate physical plan for base-table/outer-join-table/temporary table
      ObList<ObPhyOperator*> phy_table_list;
      ObList<ObBitSet<> > bitset_list;
      ObList<ObSqlRawExpr*> remainder_cnd_list;
      ObList<ObSqlRawExpr*> none_columnlize_alias;
      if (ret == OB_SUCCESS)
        ret = gen_phy_tables(
                logical_plan,
                physical_plan,
                err_stat,
                select_stmt,
                group_agg_pushed_down,
                limit_pushed_down,
                phy_table_list,
                bitset_list,
                remainder_cnd_list,
                none_columnlize_alias,
                sequence_select_op, //add liuzy [sequence select]20160616:", sequence_select_op"
                optimizer_open
                );

      // 2. Join all tables
      //add by wanglei [semi join] 20151231:b
      //select_stmt->get_query_hint().join_array_.clear();
      //add:e
      if (ret == OB_SUCCESS && phy_table_list.size() > 1)
        ret = gen_phy_joins(
                logical_plan,
                physical_plan,
                err_stat,
                select_stmt,
                ObJoin::INNER_JOIN,
                phy_table_list,
                bitset_list,
                remainder_cnd_list,
                none_columnlize_alias,
                true,
                optimizer_open,
                optimizer_open ? true:false);
      if (ret == OB_SUCCESS)
        phy_table_list.pop_front(result_op);

      // 3. add filter(s) to the join-op/table-scan-op result
      if (ret == OB_SUCCESS && remainder_cnd_list.size() >= 1)
      {
        ObFilter *filter_op = NULL;
        CREATE_PHY_OPERRATOR(filter_op, ObFilter, physical_plan, err_stat);
        if (ret == OB_SUCCESS && (ret = filter_op->set_child(0, *result_op)) != OB_SUCCESS)
        {
          TRANS_LOG("Set child of filter plan failed");
        }
        oceanbase::common::ObList<ObSqlRawExpr*>::iterator cnd_it;
        for (cnd_it = remainder_cnd_list.begin();
             ret == OB_SUCCESS && cnd_it != remainder_cnd_list.end();
             cnd_it++)
        {
          ObSqlExpression *filter = ObSqlExpression::alloc();
          if (NULL == filter
              || (ret = (*cnd_it)->fill_sql_expression(
                    *filter,
                    this,
                    logical_plan,
                    physical_plan)) != OB_SUCCESS
              || (ret = filter_op->add_filter(filter)) != OB_SUCCESS)
          {
            TRANS_LOG("Add filters to filter plan failed");
            break;
          }
          //add tianz [SubQuery_for_Instmt] [JHOBv0.1] 20151016:b
          else if (filter->get_sub_query_num() > 0)
          {
            filter_op->set_need_handle_sub_query(true);
          }
          //add tianz 20151016:e
        }
        if (ret == OB_SUCCESS)
          result_op = filter_op;
      }

      // 4. generate physical plan for group by/aggregate
      if (ret == OB_SUCCESS && (select_stmt->get_group_expr_size() > 0 || select_stmt->get_agg_fun_size() > 0))
      {
        if(select_stmt->get_from_item_size() > 0 && (select_stmt->get_table_id() == OB_ALL_SERVER_STAT_TID || select_stmt->get_table_id() == OB_ALL_SERVER_SESSION_TID))
        {
          group_agg_pushed_down = true;
        }
        if (group_agg_pushed_down == false)
        {
          if (select_stmt->get_group_expr_size() > 0)
            ret = gen_phy_group_by(logical_plan, physical_plan, err_stat, select_stmt, result_op, result_op);
          else if (select_stmt->get_agg_fun_size() > 0)
            ret = gen_phy_scalar_aggregate(logical_plan, physical_plan, err_stat, select_stmt, result_op, result_op);
        }
        if (ret == OB_SUCCESS && none_columnlize_alias.size() > 0)
        {
          // compute complex expressions that contain aggreate functions
          ObAddProject *project_op = NULL;
          oceanbase::common::ObList<ObSqlRawExpr*>::iterator alias_it;
          for (alias_it = none_columnlize_alias.begin(); ret == OB_SUCCESS && alias_it != none_columnlize_alias.end();)
          {
            if ((*alias_it)->is_columnlized() == false
                && (*alias_it)->is_contain_aggr() && (*alias_it)->get_expr()->get_expr_type() != T_REF_COLUMN)
            {
              if (project_op == NULL)
              {
                CREATE_PHY_OPERRATOR(project_op, ObAddProject, physical_plan, err_stat);
                if (ret == OB_SUCCESS && (ret = project_op->set_child(0, *result_op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Set child of filter plan failed");
                  break;
                }
              }
              (*alias_it)->set_columnlized(true);
              ObSqlExpression alias_expr;
              if ((ret = (*alias_it)->fill_sql_expression(
                     alias_expr,
                     this,
                     logical_plan,
                     physical_plan)) != OB_SUCCESS
                  || (ret = project_op->add_output_column(alias_expr)) != OB_SUCCESS)
              {
                TRANS_LOG("Add project on aggregate plan failed");
                break;
              }
            }
            common::ObList<ObSqlRawExpr*>::iterator del_alias = alias_it;
            alias_it++;
            if ((ret = none_columnlize_alias.erase(del_alias)) != OB_SUCCESS)
            {
              TRANS_LOG("Add project on aggregate plan failed");
              break;
            }
          }
          if (ret == OB_SUCCESS && project_op != NULL)
            result_op = project_op;
        }
      }

      // 5. generate physical plan for having
      if (ret == OB_SUCCESS && select_stmt->get_having_expr_size() > 0)
      {
        ObFilter *having_op = NULL;
        CREATE_PHY_OPERRATOR(having_op, ObFilter, physical_plan, err_stat);
        ObSqlRawExpr *having_expr;
        int32_t num = select_stmt->get_having_expr_size();
        for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
        {
          having_expr = logical_plan->get_expr(select_stmt->get_having_expr_id(i));
          OB_ASSERT(NULL != having_expr);
          ObSqlExpression *having_filter = ObSqlExpression::alloc();
          if (NULL == having_filter
              || (ret = having_expr->fill_sql_expression(
                    *having_filter,
                    this,
                    logical_plan,
                    physical_plan)) != OB_SUCCESS
              || (ret = having_op->add_filter(having_filter)) != OB_SUCCESS)
          {
            TRANS_LOG("Add filters to having plan failed");
            break;
          }
        }
        if (ret == OB_SUCCESS)
        {
          if ((ret = having_op->set_child(0, *result_op)) == OB_SUCCESS)
          {
            result_op = having_op;
          }
          else
          {
            TRANS_LOG("Add child of having plan failed");
          }
        }
      }

      // 6. generate physical plan for distinct
      if (ret == OB_SUCCESS && select_stmt->is_distinct())
        ret = gen_phy_distinct(logical_plan, physical_plan, err_stat, select_stmt, result_op, result_op);

      // 7. generate physical plan for order by
      if (ret == OB_SUCCESS && select_stmt->get_order_item_size() > 0)
        ret = gen_phy_order_by(logical_plan, physical_plan, err_stat, select_stmt, result_op, result_op);

      // 8. generate physical plan for limit
      if (ret == OB_SUCCESS && limit_pushed_down == false && select_stmt->has_limit())
      {
        ret = gen_phy_limit(logical_plan, physical_plan, err_stat, select_stmt, result_op, result_op);
      }

      //add liumz, [ROW_NUMBER]20150825:b
      // 9. generate physical plan for analytic func
      if (OB_SUCCESS == ret)
      {
        if (select_stmt->get_partition_expr_size() > 0 || select_stmt->get_order_item_for_rownum_size() > 0)
        {
          if(OB_SUCCESS != (ret = gen_phy_partition_by(logical_plan, physical_plan, err_stat, select_stmt, result_op, result_op)))
          {
            TRANS_LOG("Gen partition physical plan failed");
          }
        }
        else if (select_stmt->get_anal_fun_size() > 0)
        {
          if (OB_SUCCESS != (ret = gen_phy_scalar_analytic(logical_plan, physical_plan, err_stat, select_stmt, result_op, result_op)))
          {
            TRANS_LOG("Gen scalar_analytic physical plan failed");
          }
        }
      }
      //add:e

      // 10. generate physical plan for select clause
      if (ret == OB_SUCCESS && select_stmt->get_select_item_size() > 0)
      {
        ObProject *project_op = NULL;
        ObFilter *filter_op = NULL;
        CREATE_PHY_OPERRATOR(project_op, ObProject, physical_plan, err_stat);
        /*if (ret == OB_SUCCESS && (ret = project_op->set_child(0, *result_op)) != OB_SUCCESS)
                {
                    TRANS_LOG("Add child of project plan failed");
                }
                */
        //add liuzy [sequence select] 20150703:b
        if (OB_SUCCESS == ret && select_stmt->select_clause_has_sequence())
        {
          if (OB_SUCCESS != (ret = sequence_select_op->set_child(1, *project_op)))
          {
            TRANS_LOG("Add child of select_op plan failed");
          }
          if (OB_SUCCESS == ret)
          {
            project_op->set_sequence_select_op();
          }
        }
        //add 20150703:e

        ObSqlRawExpr *select_expr;
        int32_t num = select_stmt->get_select_item_size();
        for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
        {
          const SelectItem& select_item = select_stmt->get_select_item(i);
          select_expr = logical_plan->get_expr(select_item.expr_id_);
          OB_ASSERT(NULL != select_expr);
          if(select_stmt->get_from_item_size() > 0 && (select_stmt->get_table_id() == OB_ALL_SERVER_STAT_TID || select_stmt->get_table_id() == OB_ALL_SERVER_SESSION_TID)
             && select_stmt->get_condition_size() > 0)
          {
            const ColumnItem *col_item = select_stmt->get_column_item(i);
            select_expr->set_table_id(col_item->table_id_);
            select_expr->set_column_id(col_item->column_id_);
          }
          //YYSYS_LOG(ERROR,"test::fanqs,,select_item.is_real_alias_=%d,select_expr->is_columnlized()=%d",select_item.is_real_alias_,select_expr->is_columnlized());
          //add liuzy [sequence select] 20150728:b
          ObSqlExpression real_alias_expr;
          if (select_stmt->select_clause_has_sequence()
              && OB_SUCCESS != (ret = select_expr->fill_sql_expression(real_alias_expr,
                                                                       this,
                                                                       logical_plan,
                                                                       physical_plan)))
          {
            TRANS_LOG("Fill sql expression failed.");
            break;
          }
          //add 20150728:e

          //delete by xionghui 20151109 b:
          /*
          if (select_item.is_real_alias_ && select_expr->is_columnlized())
          {
              ObBinaryRefRawExpr col_raw(OB_INVALID_ID, select_expr->get_column_id(), T_REF_COLUMN);
              ObSqlRawExpr col_sql_raw(*select_expr);
              col_sql_raw.set_expr(&col_raw);
              ObSqlExpression  col_expr;
              if ((ret = col_sql_raw.fill_sql_expression(col_expr)) != OB_SUCCESS
                      || (ret = project_op ->add_output_column(col_expr)) != OB_SUCCESS)
              {
                  TRANS_LOG("Add output column to project plan failed");
                  break;
              }
              //add liuzy [sequence select]20150703:b
              else if (select_stmt->select_clause_has_sequence()
                       && OB_SUCCESS != (ret = sequence_select_op->add_output_column(real_alias_expr)))
              {
                  TRANS_LOG("Add output column to sequence select plan failed");
                  break;
              }
              //add 20150703:e
          }
            */
          //delete by 20151109 e:

          //add xionghui 20151109 [fix select NULL bug] b:
          //�����ﲻǿ�еı�ΪCOL�ı���ʽ����Ϊ��������������������������ǰ�����̣���������������ʽ���¼��㣬�ټӵ����ϲ��project��
          if (select_item.is_real_alias_ && select_expr->is_columnlized())
          {
            bool is_column_expr = select_expr->get_expr()->is_column();
            if(is_column_expr)
            {
              ObBinaryRefRawExpr col_raw(OB_INVALID_ID, select_expr->get_column_id(), T_REF_COLUMN);
              ObSqlRawExpr col_sql_raw(*select_expr);
              col_sql_raw.set_expr(&col_raw);
              ObSqlExpression  col_expr;
              if ((ret = col_sql_raw.fill_sql_expression(col_expr)) != OB_SUCCESS
                  || (ret = project_op ->add_output_column(col_expr)) != OB_SUCCESS)
              {
                TRANS_LOG("Add output column to project plan failed");
                break;
              }
            }
            else
            {
              ObSqlExpression  col_expr;
              if ((ret = select_expr->fill_sql_expression(
                     col_expr,
                     this,
                     logical_plan,
                     physical_plan)) != OB_SUCCESS
                  || (ret = project_op ->add_output_column(col_expr)) != OB_SUCCESS)
              {
                TRANS_LOG("Add output column to project plan failed");
                break;
              }
            }
            //add liuzy [sequence select]20150703:b
            if(ret == OB_SUCCESS )
            {
              if( select_stmt->select_clause_has_sequence()
                  && OB_SUCCESS != (ret = sequence_select_op->add_output_column(real_alias_expr)))
              {
                TRANS_LOG("Add output column to sequence select plan failed");
                break;
              }
            }
            //add 20150703:e
          }
          //add 20151109 e:
          else
          {
            ObSqlExpression  col_expr;
            if ((ret = select_expr->fill_sql_expression(
                   col_expr,
                   this,
                   logical_plan,
                   physical_plan)) != OB_SUCCESS
                || (ret = project_op ->add_output_column(col_expr)) != OB_SUCCESS)
            {
              TRANS_LOG("Add output column to project plan failed");
              break;
            }
            //add liuzy [sequence select]20150703:b
            else if (select_stmt->select_clause_has_sequence()
                     && (ret = sequence_select_op->add_output_column(col_expr)) != OB_SUCCESS)
            {
              TRANS_LOG("Add output column to sequence select plan failed");
              break;
            }
            //add 20150703:e
          }
          select_expr->set_columnlized(true);
        }
        if(select_stmt->get_from_item_size() > 0 && (select_stmt->get_table_id() == OB_ALL_SERVER_STAT_TID ||select_stmt->get_table_id() == OB_ALL_SERVER_SESSION_TID))
        {
          if(select_stmt->get_condition_size() > 0)
          {
            CREATE_PHY_OPERRATOR(filter_op, ObFilter, physical_plan, err_stat);
            for (int32_t i = 0; ret == OB_SUCCESS && i < select_stmt->get_condition_size(); i++)
            {
              ObSqlRawExpr *cnd_expr = logical_plan->get_expr(select_stmt->get_condition_id(i));
              ObSqlExpression *filter = ObSqlExpression::alloc();
              if (NULL == filter)
              {
                ret= OB_ALLOCATE_MEMORY_FAILED;
                YYSYS_LOG(ERROR, "no memory");
                break;
              }
              else if((ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan)) != OB_SUCCESS
                      || (ret = filter_op->add_filter(filter)) != OB_SUCCESS)
              {
                ObSqlExpression::free(filter);
                TRANS_LOG("Add table filter condition failed");
                break;
              }
            }
          }
          if(ret == OB_SUCCESS && select_stmt->get_agg_fun_size() > 0)
          {
            ret = gen_phy_scalar_aggregate(logical_plan, physical_plan, err_stat, select_stmt, result_op, result_op);
          }
          if(ret == OB_SUCCESS && filter_op != NULL)
          {
            if((ret = filter_op->set_child(0, *result_op)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of filter plan failed");
            }
            else
            {
              result_op = filter_op;
            }
          }
        }
        if(ret == OB_SUCCESS && (ret = project_op->set_child(0, *result_op)) != OB_SUCCESS)
        {
          TRANS_LOG("Add child of project plan failed");
        }
        //add liuzy [sequence select]20150706:b
        if (OB_SUCCESS == ret)
        {
          if (select_stmt->select_clause_has_sequence())
          {
            result_op = sequence_select_op;
          }
          else
          {
            result_op = project_op;
          }
        }
        //add 20150706:e
        //del liuzy [sequence select]20150706:b
        //        if (ret == OB_SUCCESS)
        //          result_op = project_op;
        //del 20150706:e
      }

      if (ret == OB_SUCCESS)
      {
        if(physical_plan->get_insert_select_flag())
        {
          ret = physical_plan->add_phy_query(result_op, index);
        }
        else
          ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, select_stmt, result_op, index);
      }
      //add tianz [EXPORT_TOOL] 20141120:b
      if (select_stmt->get_has_range())
      {
        physical_plan->set_has_range();
        if (select_stmt->start_is_min())
        {
          physical_plan->set_start_is_min();
        }
        else if (select_stmt->end_is_max())
        {
          physical_plan->set_end_is_max();
        }
        const ObTableSchema *table_schema = NULL;
        if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(select_stmt->get_table_id())))
        {
          ret = OB_ERR_ILLEGAL_ID;
          TRANS_LOG("fail to get table schema for table[%ld]", select_stmt->get_table_id());
        }
        else
        {
          ObRowkeyInfo rowkey_info = table_schema->get_rowkey_info();
          int64_t rowkey_col_num = rowkey_info.get_size();
          for(int i = 0; ret == OB_SUCCESS && i < select_stmt->get_range_vector_count(); i++)
          {
            const ObArray<uint64_t>& value_row = select_stmt->get_value_row(i);
            if ( value_row.count() != rowkey_col_num)
            {
              ret = OB_ERR_INSERT_NULL_ROWKEY;
              TRANS_LOG("range values num not match the rowkey num");
            }
            for (int j = 0; ret == OB_SUCCESS && j < value_row.count(); j++)
            {
              ObSqlRawExpr *value_expr = logical_plan->get_expr(value_row.at(j));
              ObConstRawExpr* const_value = NULL;
              ObObj obj_value;
              ObObj obj_value2;//add qianzm [EXPORT_TOOL bug76] 20160421
              if (value_expr == NULL)
              {
                ret = OB_ERR_ILLEGAL_ID;
                TRANS_LOG("Get value failed");
              }
              else if(NULL == (const_value = dynamic_cast<ObConstRawExpr*>(value_expr->get_expr())))
              {
                ret = OB_ERR_ILLEGAL_ID;
                TRANS_LOG("Get const value failed, should be const value");
              }
              else if ((ret = ob_write_obj(*mem_pool_,
                                           const_value->get_value(),
                                           obj_value)) != OB_SUCCESS)
              {
                TRANS_LOG("Failed to copy range value, err=%d", ret);
                break;
              }
              else
              {
                const ObRowkeyColumn *rowkey_column = rowkey_info.get_column(j);
                OB_ASSERT(rowkey_column);
                if (rowkey_column->type_ == ObPreciseDateTimeType)
                {
                  if (obj_value.get_type()!= ObIntType)
                  {
                    ret = OB_OBJ_TYPE_ERROR;
                  }
                  else
                  {
                    obj_value.set_precise_datetime_type();
                  }
                }
                //add qianzm [EXPORT_TOOL bug76] 20160421
                if (rowkey_column->type_ != obj_value.get_type())
                {
                  if (rowkey_column->type_ == ObDateTimeType)
                  {
                    if (obj_value.get_type()!= ObIntType)
                    {
                      ret = OB_OBJ_TYPE_ERROR;
                    }
                    else
                    {
                      int64_t date_time_val = 0;
                      ret = obj_value.get_int(date_time_val);
                      obj_value.set_datetime(static_cast<ObDateTime>(date_time_val));
                    }
                  }
                  else if (rowkey_column->type_ == ObDateType)
                  {
                    if (obj_value.get_type()!= ObIntType)
                    {
                      ret = OB_OBJ_TYPE_ERROR;
                    }
                    else
                    {
                      int64_t date_val = 0;
                      ret = obj_value.get_int(date_val);
                      obj_value.set_date(static_cast<ObPreciseDateTime>(date_val));
                    }
                  }
                  else if (rowkey_column->type_ == ObTimeType)
                  {
                    if (obj_value.get_type()!= ObIntType)
                    {
                      ret = OB_OBJ_TYPE_ERROR;
                    }
                    else
                    {
                      int64_t time_val = 0;
                      ret = obj_value.get_int(time_val);
                      obj_value.set_time(static_cast<ObPreciseDateTime>(time_val));
                    }
                  }
                  else if (rowkey_column->type_ == ObInt32Type)
                  {
                    if (obj_value.get_type()!= ObIntType)
                    {
                      ret = OB_OBJ_TYPE_ERROR;
                    }
                    else
                    {
                      int64_t int_val = 0;
                      ret = obj_value.get_int(int_val);
                      obj_value.set_int32(static_cast<int32_t>(int_val));
                    }
                  }
                  else if (rowkey_column->type_ == ObDecimalType)
                  {
                    if (obj_value.get_type()!= ObIntType)
                    {
                      ret = OB_OBJ_TYPE_ERROR;
                    }
                    else
                    {
                      int64_t int_val = 0;
                      ret = obj_value.get_int(int_val);
                      char tmp_buf[128];
                      std::string int_str;
                      sprintf(tmp_buf, "%ld", int_val);
                      int_str = tmp_buf;
                      ObString tmp_os = ObString::make_string(int_str.c_str());
                      obj_value2.set_decimal(tmp_os);
                      if ((ret = ob_write_obj(*mem_pool_,
                                              obj_value2,
                                              obj_value)) != OB_SUCCESS)
                      {
                        TRANS_LOG("Failed to copy range value, err=%d", ret);
                        break;
                      }
                    }
                  }
                }
                //add 20160421:e
              }

              if (OB_SUCCESS != ret)
              {
              }
              else if (0 == i && !select_stmt->start_is_min())
              {
                physical_plan->add_start_range_values(j,obj_value);
              }
              else
              {
                physical_plan->add_end_range_values(j,obj_value);
              }
            }
          }
        }
      }
      //add 20141120:e
    }
  }
  return ret;
}

int ObTransformer::gen_phy_limit(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObSelectStmt *select_stmt,
    ObPhyOperator *in_op,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObLimit *limit_op = NULL;
  if (!select_stmt->has_limit())
  {
    /* skip */
  }
  else if (CREATE_PHY_OPERRATOR(limit_op, ObLimit, physical_plan, err_stat) == NULL)
  {
  }
  else if ((ret = limit_op->set_child(0, *in_op)) != OB_SUCCESS)
  {
    TRANS_LOG("Add child of limit plan failed");
  }
  else
  {
    ObSqlExpression limit_count;
    ObSqlExpression limit_offset;
    ObSqlExpression *ptr = &limit_count;
    uint64_t id = select_stmt->get_limit_expr_id();
    int64_t i = 0;
    for (; ret == OB_SUCCESS && i < 2;
         i++, id = select_stmt->get_offset_expr_id(), ptr = &limit_offset)
    {
      ObSqlRawExpr *raw_expr = NULL;
      if (id == OB_INVALID_ID)
      {
        continue;
      }
      else if ((raw_expr = logical_plan->get_expr(id)) == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Wrong internal expression id = %lu, ret=%d", id, ret);
        break;
      }
      else if ((ret = raw_expr->fill_sql_expression(
                  *ptr,
                  this,
                  logical_plan,
                  physical_plan)) != OB_SUCCESS)
      {
        TRANS_LOG("Add limit/offset faild");
        break;
      }
    }
    if (ret == OB_SUCCESS && (ret = limit_op->set_limit(limit_count, limit_offset)) != OB_SUCCESS)
    {
      TRANS_LOG("Set limit/offset failed, ret=%d", ret);
    }
  }
  if (ret == OB_SUCCESS)
    out_op = limit_op;
  return ret;
}

int ObTransformer::gen_phy_order_by(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObSelectStmt *select_stmt,
    ObPhyOperator *in_op,
    ObPhyOperator *&out_op,
    bool use_generated_id)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObSort *sort_op = NULL;
  ObProject *project_op = NULL;
  CREATE_PHY_OPERRATOR(sort_op, ObSort, physical_plan, err_stat);

  ObSqlRawExpr *order_expr;
  int32_t num = select_stmt->get_order_item_size();
  for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
  {
    //add liumz, [optimize group_order by index]20170419:b
    if (select_stmt->get_order_item_flag(i))
    {
      continue;
    }
    //add:e
    const OrderItem& order_item = select_stmt->get_order_item(i);
    order_expr = logical_plan->get_expr(order_item.expr_id_);
    if (order_expr->get_expr()->is_const())
    {
      // do nothing, const column is of no usage for sorting
    }
    else if (order_expr->get_expr()->get_expr_type() == T_REF_COLUMN)
    {
      ObBinaryRefRawExpr *col_expr = dynamic_cast<ObBinaryRefRawExpr*>(order_expr->get_expr());
      if ((ret = sort_op->add_sort_column(
             use_generated_id? order_expr->get_table_id() : col_expr->get_first_ref_id(),
             use_generated_id? order_expr->get_column_id() : col_expr->get_second_ref_id(),
             order_item.order_type_ == OrderItem::ASC ? true : false
             )) != OB_SUCCESS)
      {
        TRANS_LOG("Add sort column to sort plan failed");
        break;
      }
    }
    else
    {
      if (!project_op)
      {
        CREATE_PHY_OPERRATOR(project_op, ObAddProject, physical_plan, err_stat);
        if (ret != OB_SUCCESS)
          break;
        if ((ret = project_op->set_child(0, *in_op)) != OB_SUCCESS)
        {
          TRANS_LOG("Add child of project plan failed");
          break;
        }
      }
      ObSqlExpression col_expr;
      if ((ret = order_expr->fill_sql_expression(
             col_expr,
             this,
             logical_plan,
             physical_plan)) != OB_SUCCESS
          || (ret = project_op->add_output_column(col_expr)) != OB_SUCCESS)
      {
        TRANS_LOG("Add output column to project plan failed");
        break;
      }
      if ((ret = sort_op->add_sort_column(
             order_expr->get_table_id(),
             order_expr->get_column_id(),
             order_item.order_type_ == OrderItem::ASC ? true : false
             )) != OB_SUCCESS)
      {
        TRANS_LOG("Add sort column to sort plan failed");
        break;
      }
    }
  }
  if (ret == OB_SUCCESS)
  {
    if (project_op)
      ret = sort_op->set_child(0, *project_op);
    else
      ret = sort_op->set_child(0, *in_op);
    if (ret != OB_SUCCESS)
    {
      TRANS_LOG("Add child of sort plan failed");
    }
  }
  if (ret == OB_SUCCESS)
  {
    if (sort_op->get_sort_column_size() > 0)
      out_op = sort_op;
    else
      out_op = in_op;
  }

  return ret;
}

int ObTransformer::gen_phy_distinct(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObSelectStmt *select_stmt,
    ObPhyOperator *in_op,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObMergeDistinct *distinct_op = NULL;
  ObSort *sort_op = NULL;
  ObProject *project_op = NULL;
  if (ret == OB_SUCCESS)
    CREATE_PHY_OPERRATOR(sort_op, ObSort, physical_plan, err_stat);
  if (ret == OB_SUCCESS)
    CREATE_PHY_OPERRATOR(distinct_op, ObMergeDistinct, physical_plan, err_stat);
  if (ret == OB_SUCCESS && (ret = distinct_op->set_child(0, *sort_op)) != OB_SUCCESS)
  {
    TRANS_LOG("Add child of distinct plan failed");
  }

  ObSqlRawExpr *select_expr;
  int32_t num = select_stmt->get_select_item_size();
  for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
  {
    const SelectItem& select_item = select_stmt->get_select_item(i);
    select_expr = logical_plan->get_expr(select_item.expr_id_);
    if (select_expr->get_expr()->is_const())
    {
      // do nothing, const column is of no usage for sorting
    }
    else if (select_item.is_real_alias_)
    {
      ret = sort_op->add_sort_column(select_expr->get_table_id(), select_expr->get_column_id(), true);
      if (ret != OB_SUCCESS)
      {
        TRANS_LOG("Add sort column of sort plan failed");
        break;
      }
      ret = distinct_op->add_distinct_column(select_expr->get_table_id(), select_expr->get_column_id());
      if (ret != OB_SUCCESS)
      {
        TRANS_LOG("Add distinct column of distinct plan failed");
        break;
      }
    }
    else if (select_expr->get_expr()->get_expr_type() == T_REF_COLUMN)
    {
      ObBinaryRefRawExpr *col_expr = dynamic_cast<ObBinaryRefRawExpr*>(select_expr->get_expr());
      ret = sort_op->add_sort_column(col_expr->get_first_ref_id(), col_expr->get_second_ref_id(), true);
      if (ret != OB_SUCCESS)
      {
        TRANS_LOG("Add sort column to sort plan failed");
        break;
      }
      ret = distinct_op->add_distinct_column(col_expr->get_first_ref_id(), col_expr->get_second_ref_id());
      if (ret != OB_SUCCESS)
      {
        TRANS_LOG("Add distinct column to distinct plan failed");
        break;
      }
    }
    else
    {
      if (!project_op)
      {
        CREATE_PHY_OPERRATOR(project_op, ObAddProject, physical_plan, err_stat);
        if (ret != OB_SUCCESS)
          break;
        if ((ret = project_op->set_child(0, *in_op)) != OB_SUCCESS)
        {
          TRANS_LOG("Add child of project plan failed");
          break;
        }
      }
      ObSqlExpression col_expr;
      if ((ret = select_expr->fill_sql_expression(
             col_expr,
             this,
             logical_plan,
             physical_plan)) != OB_SUCCESS
          || (ret = project_op->add_output_column(col_expr)) != OB_SUCCESS)
      {
        TRANS_LOG("Add output column to project plan failed");
        break;
      }
      if ((ret = sort_op->add_sort_column(
             select_expr->get_table_id(),
             select_expr->get_column_id(),
             true)) != OB_SUCCESS)
      {
        TRANS_LOG("Add sort column to sort plan failed");
        break;
      }
      if ((ret = distinct_op->add_distinct_column(
             select_expr->get_table_id(),
             select_expr->get_column_id())) != OB_SUCCESS)
      {
        TRANS_LOG("Add distinct column to distinct plan failed");
        break;
      }
    }
  }
  if (ret == OB_SUCCESS)
  {
    if (project_op)
      ret = sort_op->set_child(0, *project_op);
    else
      ret = sort_op->set_child(0, *in_op);
    if (ret != OB_SUCCESS)
    {
      TRANS_LOG("Add child to sort plan failed");
    }
  }
  if (ret == OB_SUCCESS)
  {
    out_op = distinct_op;
  }

  return ret;
}

int ObTransformer::gen_phy_group_by(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObSelectStmt *select_stmt,
    ObPhyOperator *in_op,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObMergeGroupBy *group_op = NULL;
  ObSort *sort_op = NULL;
  ObProject *project_op = NULL;
  if (ret == OB_SUCCESS && !select_stmt->is_indexed_group())//mod liumz, [optimize group_order by index]20170419
    CREATE_PHY_OPERRATOR(sort_op, ObSort, physical_plan, err_stat);
  if (ret == OB_SUCCESS)
    CREATE_PHY_OPERRATOR(group_op, ObMergeGroupBy, physical_plan, err_stat);
  if (ret == OB_SUCCESS && !select_stmt->is_indexed_group() && (ret = group_op->set_child(0, *sort_op)) != OB_SUCCESS)//mod liumz, [optimize group_order by index]20170419
  {
    TRANS_LOG("Add child of group by plan faild");
  }

  ObSqlRawExpr *group_expr;
  int32_t num = select_stmt->get_group_expr_size();
  for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
  {
    group_expr = logical_plan->get_expr(select_stmt->get_group_expr_id(i));
    OB_ASSERT(NULL != group_expr);
    if (group_expr->get_expr()->get_expr_type() == T_REF_COLUMN)
    {
      ObBinaryRefRawExpr *col_expr = dynamic_cast<ObBinaryRefRawExpr*>(group_expr->get_expr());
      OB_ASSERT(NULL != col_expr);
      if (!select_stmt->is_indexed_group())//add liumz, [optimize group_order by index]20170419
        ret = sort_op->add_sort_column(col_expr->get_first_ref_id(), col_expr->get_second_ref_id(), true);
      if (ret != OB_SUCCESS)
      {
        TRANS_LOG("Add sort column faild, table_id=%lu, column_id=%lu",
                  col_expr->get_first_ref_id(), col_expr->get_second_ref_id());
        break;
      }
      ret = group_op->add_group_column(col_expr->get_first_ref_id(), col_expr->get_second_ref_id());
      if (ret != OB_SUCCESS)
      {
        TRANS_LOG("Add group column faild, table_id=%lu, column_id=%lu",
                  col_expr->get_first_ref_id(), col_expr->get_second_ref_id());
        break;
      }
    }
    else if (group_expr->get_expr()->is_const())
    {
      // do nothing, const column is of no usage for sorting
    }
    else
    {
      if (!project_op)
      {
        CREATE_PHY_OPERRATOR(project_op, ObAddProject, physical_plan, err_stat);
        if (ret != OB_SUCCESS)
          break;
        if ((ret = project_op->set_child(0, *in_op)) != OB_SUCCESS)
        {
          TRANS_LOG("Add child of project plan faild");
          break;
        }
      }
      ObSqlExpression col_expr;
      if ((ret = group_expr->fill_sql_expression(
             col_expr,
             this,
             logical_plan,
             physical_plan)) != OB_SUCCESS
          || (ret = project_op->add_output_column(col_expr)) != OB_SUCCESS)
      {
        TRANS_LOG("Add output column to project plan faild");
        break;
      }
      if (!select_stmt->is_indexed_group() &&//add liumz, [optimize group_order by index]20170419
          (ret = sort_op->add_sort_column(
             group_expr->get_table_id(),
             group_expr->get_column_id(),
             true)) != OB_SUCCESS)
      {
        TRANS_LOG("Add sort column to sort plan faild");
        break;
      }
      if ((ret = group_op->add_group_column(
             group_expr->get_table_id(),
             group_expr->get_column_id())) != OB_SUCCESS)
      {
        TRANS_LOG("Add group column to group plan faild");
        break;
      }
    }
  }
  if (ret == OB_SUCCESS)
  {
    //add liumz, [optimize group_order by index]20170419:b
    if (select_stmt->is_indexed_group())
    {
      if (project_op)
        ret = group_op->set_child(0, *project_op);
      else
        ret = group_op->set_child(0, *in_op);
    }
    else
    {
      //add:e
      if (project_op)
        ret = sort_op->set_child(0, *project_op);
      else
        ret = sort_op->set_child(0, *in_op);
    }
    if (ret != OB_SUCCESS)
    {
      TRANS_LOG("Add child to sort plan faild");
    }
  }

  num = select_stmt->get_agg_fun_size();
  ObSqlRawExpr *agg_expr = NULL;
  for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
  {
    agg_expr = logical_plan->get_expr(select_stmt->get_agg_expr_id(i));
    OB_ASSERT(NULL != agg_expr);
    if (agg_expr->get_expr()->is_aggr_fun())
    {
      ObSqlExpression new_agg_expr;
      if ((ret = agg_expr->fill_sql_expression(
             new_agg_expr,
             this,
             logical_plan,
             physical_plan)) != OB_SUCCESS
          || (ret = group_op->add_aggr_column(new_agg_expr)) != OB_SUCCESS)
      {
        TRANS_LOG("Add aggregate function to group plan faild");
        break;
      }
    }
    else
    {
      TRANS_LOG("Wrong aggregate function, exp_id = %lu", agg_expr->get_expr_id());
      break;
    }
    agg_expr->set_columnlized(true);
  }
  if (ret == OB_SUCCESS)
    out_op = group_op;

  return ret;
}

int ObTransformer::gen_phy_scalar_aggregate(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObSelectStmt *select_stmt,
    ObPhyOperator *in_op,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObScalarAggregate *scalar_agg_op = NULL;
  CREATE_PHY_OPERRATOR(scalar_agg_op, ObScalarAggregate, physical_plan, err_stat);
  //del gaojt [ListAgg][JHOBv0.1]20150104:b
  //  if (ret == OB_SUCCESS && (ret = scalar_agg_op->set_child(0, *in_op)) != OB_SUCCESS)
  //  {
  //    TRANS_LOG("Add child of scalar aggregate plan failed");
  //  }
  // del 20150104:e

  int32_t num = select_stmt->get_agg_fun_size();
  ObSqlRawExpr *agg_expr = NULL;
  bool is_listagg_and_order_exist = false;//add gaojt [ListAgg][JHOBv0.1]20150104
  for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
  {
    agg_expr = logical_plan->get_expr(select_stmt->get_agg_expr_id(i));
    OB_ASSERT(NULL != agg_expr);
    if (agg_expr->get_expr()->is_aggr_fun())
    {
      //add gaojt [ListAgg][JHOBv0.1]20150104:b
      /* Exp:not push down listagg */
      if(T_FUN_LISTAGG == agg_expr->get_expr()->get_expr_type()&&select_stmt->get_order_item_for_listagg_size()>0)
      {
        is_listagg_and_order_exist = true;
      }
      // add 20150104:e
      ObSqlExpression new_agg_expr;
      if ((ret = agg_expr->fill_sql_expression(
             new_agg_expr,
             this,
             logical_plan,
             physical_plan)) != OB_SUCCESS
          || (ret = scalar_agg_op->add_aggr_column(new_agg_expr)) != OB_SUCCESS)
      {
        TRANS_LOG("Add aggregate function to scalar aggregate plan failed");
        break;
      }
    }
    else
    {
      TRANS_LOG("wrong aggregate function, exp_id = %ld", agg_expr->get_expr_id());
      break;
    }
    agg_expr->set_columnlized(true);
  }
  //add gaojt [ListAgg][JHOBv0.1]20150104:b
  /*Exp: If the agg's type is T_FUN_LISTAGG,and there is order-by,then set the sort operator as
      scalar_agg_op operator's child.
    */
  if(true == is_listagg_and_order_exist)
  {
    ObSort *sort_op = NULL;
    CREATE_PHY_OPERRATOR(sort_op, ObSort, physical_plan, err_stat);
    if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
    {
    }
    else if ((ret = scalar_agg_op->set_child(0, *sort_op)) != OB_SUCCESS)
    {
      TRANS_LOG("Add child of scalar aggregate plan failed");
    }
    else if ((ret = sort_op->set_child(0, *in_op)) != OB_SUCCESS)
    {
      TRANS_LOG("Add child of scalar aggregate plan failed");
    }
    else
    {
      ObSqlRawExpr *order_expr;
      int32_t num = select_stmt->get_order_item_for_listagg_size();
      for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
      {
        const OrderItem& order_item = select_stmt->get_order_item_for_listagg(i);
        order_expr = logical_plan->get_expr(order_item.expr_id_);
        if (order_expr->get_expr()->is_const())
        {
          // do nothing, const column is of no usage for sorting
        }
        else if (order_expr->get_expr()->get_expr_type() == T_REF_COLUMN)
        {
          ObBinaryRefRawExpr *col_expr = dynamic_cast<ObBinaryRefRawExpr*>(order_expr->get_expr());
          if ((ret = sort_op->add_sort_column(
                 col_expr->get_first_ref_id(),
                 col_expr->get_second_ref_id(),
                 order_item.order_type_ == OrderItem::ASC ? true : false
                 )) != OB_SUCCESS)
          {
            TRANS_LOG("Add sort column to sort plan failed");
            break;
          }
        }
        else
        {
          ObSqlExpression col_expr;
          if ((ret = order_expr->fill_sql_expression(
                 col_expr,
                 this,
                 logical_plan,
                 physical_plan)) != OB_SUCCESS)
          {
            TRANS_LOG("Add output column to project plan failed");
            break;
          }
          else if ((ret = sort_op->add_sort_column(
                      order_expr->get_table_id(),
                      order_expr->get_column_id(),
                      order_item.order_type_ == OrderItem::ASC ? true : false
                      )) != OB_SUCCESS)
          {
            TRANS_LOG("Add sort column to sort plan failed");
            break;
          }
        }
      }
    }
  }
  if(OB_SUCCESS == ret&&is_listagg_and_order_exist==false)
  {
    if ((ret = scalar_agg_op->set_child(0, *in_op)) != OB_SUCCESS)
    {
      TRANS_LOG("Add child of scalar aggregate plan failed");
    }
  }
  //add 20150104 e
  if (ret == OB_SUCCESS)
    out_op = scalar_agg_op;

  return ret;
}
//add liumz, [ROW_NUMBER]20150825
int ObTransformer::gen_phy_scalar_analytic(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObSelectStmt *select_stmt,
    ObPhyOperator *in_op,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObScalarAggregate *scalar_agg_op = NULL;
  CREATE_PHY_OPERRATOR(scalar_agg_op, ObScalarAggregate, physical_plan, err_stat);
  if (ret == OB_SUCCESS && (ret = scalar_agg_op->set_child(0, *in_op)) != OB_SUCCESS)
  {
    TRANS_LOG("Add child of scalar analytic plan failed");
  }

  int32_t num = select_stmt->get_anal_fun_size();
  ObSqlRawExpr *anal_expr = NULL;
  for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
  {
    anal_expr = logical_plan->get_expr(select_stmt->get_anal_expr_id(i));
    OB_ASSERT(NULL != anal_expr);
    if (anal_expr->get_expr()->is_aggr_fun())
    {
      ObSqlExpression new_anal_expr;
      if ((ret = anal_expr->fill_sql_expression(
             new_anal_expr,
             this,
             logical_plan,
             physical_plan)) != OB_SUCCESS
          || (ret = scalar_agg_op->add_anal_column(new_anal_expr)) != OB_SUCCESS)
      {
        TRANS_LOG("Add analytic function to scalar analytic plan failed");
        break;
      }
    }
    else
    {
      TRANS_LOG("wrong analytic function, exp_id = %ld", anal_expr->get_expr_id());
      break;
    }
    anal_expr->set_columnlized(true);
  }

  if (ret == OB_SUCCESS)
  {
    scalar_agg_op->set_analytic_func(true);
    out_op = scalar_agg_op;
  }
  return ret;
}
//add:e

//add by hushuang [bloomfilter_join]20150429
int ObTransformer::add_bloomfilter_join_expr(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ObBloomFilterJoin& join_op,
    ObSort& l_sort,
    ObSort& r_sort,
    ObSqlRawExpr& expr,
    const bool is_table_expr_same_order)
{
  int ret = OB_SUCCESS;
  ObSqlRawExpr join_expr = expr;
  ObBinaryOpRawExpr equal_expr = *(dynamic_cast<ObBinaryOpRawExpr*>(expr.get_expr()));
  join_expr.set_expr(&equal_expr);
  if (OB_UNLIKELY(!expr.get_expr() || expr.get_expr()->get_expr_type() != T_OP_EQ))
  {
    ret = OB_ERR_GEN_PLAN;
    YYSYS_LOG(WARN, "Wrong expression of merge join, ret=%d", ret);
  }
  else
  {
    ObBinaryRefRawExpr *expr1 = NULL;
    ObBinaryRefRawExpr *expr2 = NULL;
    if (is_table_expr_same_order)
    {
      expr1 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_first_op_expr());
      expr2 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_second_op_expr());
    }
    else
    {
      expr2 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_first_op_expr());
      expr1 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_second_op_expr());
      equal_expr.set_op_exprs(expr1, expr2);
    }
    if ((ret = l_sort.add_sort_column(expr1->get_first_ref_id(), expr1->get_second_ref_id(), true)) != OB_SUCCESS
        ||(ret = r_sort.add_sort_column(expr2->get_first_ref_id(), expr2->get_second_ref_id(), true)) != OB_SUCCESS)
    {
      YYSYS_LOG(WARN, "Add sort column faild, ret=%d", ret);
    }
    else
    {
      ObSqlExpression join_op_cnd;
      if ((ret = join_expr.fill_sql_expression(
             join_op_cnd,
             this,
             logical_plan,
             physical_plan)) != OB_SUCCESS)
      {
      }
      else if ((ret = join_op.add_equijoin_condition(join_op_cnd)) != OB_SUCCESS)
      {
        YYSYS_LOG(WARN, "Add condition of join plan faild");
      }
    }
  }
  return ret;
}
//add:e

int ObTransformer::add_hash_join_single_expr(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ObHashJoinSingle &join_op,
    ObSqlRawExpr &expr,
    const bool is_table_expr_same_order)
{
  int ret = OB_SUCCESS;
  ObSqlRawExpr join_expr = expr;
  ObBinaryOpRawExpr equal_expr = *(dynamic_cast<ObBinaryOpRawExpr *>(expr.get_expr()));
  join_expr.set_expr(&equal_expr);
  if (OB_UNLIKELY(!expr.get_expr() || expr.get_expr()->get_expr_type()!=T_OP_EQ))
  {
    ret = OB_ERR_GEN_PLAN;
    YYSYS_LOG(WARN, "Wrong expression of merge join, ret=%d",ret);
  }
  else
  {
    ObBinaryRefRawExpr *expr1 = NULL;
    ObBinaryRefRawExpr *expr2 = NULL;
    if (is_table_expr_same_order)
    {
      expr1 = dynamic_cast<ObBinaryRefRawExpr *>(equal_expr.get_first_op_expr());
      expr2 = dynamic_cast<ObBinaryRefRawExpr *>(equal_expr.get_second_op_expr());
    }
    else
    {
      expr2 = dynamic_cast<ObBinaryRefRawExpr *>(equal_expr.get_first_op_expr());
      expr1 = dynamic_cast<ObBinaryRefRawExpr *>(equal_expr.get_second_op_expr());
      equal_expr.set_op_exprs(expr1,expr2);
    }
    ObSqlExpression join_op_cnd;
    if((ret = join_expr.fill_sql_expression(
          join_op_cnd,
          this,
          logical_plan,
          physical_plan)) != OB_SUCCESS)
    {
    }
    else if((ret = join_op.add_equijoin_condition(join_op_cnd)) != OB_SUCCESS)
    {
      YYSYS_LOG(WARN, "Add condition of join plan faild");
    }
  }
  return ret;
}

/*add by wanglei [semi join] 20151231*/
int ObTransformer::add_semi_join_expr(ObLogicalPlan *logical_plan,
                                      ObPhysicalPlan *physical_plan,
                                      ObSemiJoin& join_op,
                                      ObSort& l_sort,
                                      ObSort& r_sort,
                                      ObSqlRawExpr& expr,
                                      const bool is_table_expr_same_order,
                                      oceanbase::common::ObList<ObSqlRawExpr*>& remainder_cnd_list,
                                      bool &is_add_other_join_cond,
                                      ObJoin::JoinType join_type,
                                      ObSelectStmt *select_stmt,
                                      int id,
                                      ObJoinTypeArray& hint_temp)
{
  int ret = OB_SUCCESS;
  //    UNUSED(remainder_cnd_list);
  //    UNUSED(join_type);
  //    UNUSED(select_stmt);
  //    UNUSED(is_add_other_join_cond);
  //UNUSED(id);
  UNUSED(hint_temp);
  //����ģ�鿪�أ�b
  bool is_on_expr_push_down = true; //on����ʽ�й����ұ��Ĺ��������Ƿ���ѹģ��
  bool is_cons_right_table_filter = true; //�Ƿ����ұ���filter������ģ��
  bool is_get_all_index_table_for_right_table = false;//�Ƿ��ȡ�ұ�������index tableģ��
  bool is_decide_use_index = true; //�Ƿ�ʹ������ģ�� Ҫ���ԭ�ж�������ʹ������ʹ��
  //����ģ�鿪�أ�e

  ObSqlRawExpr join_expr = expr;
  ObBinaryOpRawExpr equal_expr = *(dynamic_cast<ObBinaryOpRawExpr*>(expr.get_expr()));
  join_expr.set_expr(&equal_expr);
  ObBinaryRefRawExpr *expr1 = NULL;
  ObBinaryRefRawExpr *expr2 = NULL;
  //[second index]:b
  uint64_t first_table_id = OB_INVALID_ID; //�����index table id��Ŀǰ�����һ������ʱ����
  uint64_t second_table_id = OB_INVALID_ID;//�ұ���index table id��Ŀǰ�����һ������ʱ����
  uint64_t index_table_id = OB_INVALID_ID;  //ʵ�ʴ����ұ�����������table id
  uint64_t left_main_cid = OB_INVALID_ID;//�������
  uint64_t right_main_cid = OB_INVALID_ID;//�ұ�����
  uint64_t hint_tid = OB_INVALID_ID;      //hint�е�index table id
  //�ж��Ƿ���t1.c1>t2.id���ֱ���ʽ��b
  //bool is_non_equal_cond =false;
  bool is_use_hint = false; //�ж��Ƿ�ʹ��hint
  bool is_use_index = false;//�ж��Ƿ�ʹ����������Ϊ��ʹhint����ֱָ�������������ǻ�Ҫ���һ�����Ƿ����
  uint64_t left_table_id = OB_INVALID_ID;
  uint64_t right_table_id = OB_INVALID_ID;
  TableItem* left_table_item = NULL;
  TableItem* right_table_item = NULL;
  ObSqlExpression join_op_cnd;
  if(hint_temp.join_type_ == T_SEMI_BTW_JOIN)
  {
    join_op.set_use_btw (true);
  }
  else if(hint_temp.join_type_ == T_SEMI_JOIN)
  {
    join_op.set_use_in (true);
  }
  if (OB_UNLIKELY(!expr.get_expr() || expr.get_expr()->get_expr_type() != T_OP_EQ))
  {
    ret = OB_ERR_GEN_PLAN;
    YYSYS_LOG(WARN, "Wrong expression of semi join, ret=%d", ret);
  }
  else
  {
    if (is_table_expr_same_order)
    {
      expr1 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_first_op_expr());
      expr2 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_second_op_expr());
    }
    else
    {
      expr2 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_first_op_expr());
      expr1 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_second_op_expr());
      equal_expr.set_op_exprs(expr1, expr2);
    }
    if ((ret = l_sort.add_sort_column(expr1->get_first_ref_id(), expr1->get_second_ref_id(), true)) != OB_SUCCESS
        ||(ret = r_sort.add_sort_column(expr2->get_first_ref_id(), expr2->get_second_ref_id(), true)) != OB_SUCCESS)
    {
      join_op.set_is_can_use_semi_join(false);
      YYSYS_LOG(WARN, "Add sort column faild, ret = %d", ret);
    }
    else
    {
      //��ȡ�������ű���ԭ��table id��ע�ⲻ�Ǳ�����id:b
      if(select_stmt == NULL)
      {
        join_op.set_is_can_use_semi_join(false);
        ret = OB_ERR_POINTER_IS_NULL;
        YYSYS_LOG(WARN,"[semi join] select stmt is null!");
      }
      else
      {
        left_table_item = select_stmt->get_table_item_by_id(expr1->get_first_ref_id());
        right_table_item = select_stmt->get_table_item_by_id(expr2->get_first_ref_id());
        if(left_table_item == NULL || right_table_item == NULL)
        {
          join_op.set_is_can_use_semi_join(false);
          ret = OB_ERR_POINTER_IS_NULL;
          YYSYS_LOG(WARN,"[semi join] left table item is null or right item is null!");
        }
        else
        {
          left_table_id = left_table_item->ref_id_;
          right_table_id = right_table_item->ref_id_;
        }
      }
      //:e
      //����table id��Schema�л�ȡ���ű����е�index table��b
      if(OB_SUCCESS == ret && is_get_all_index_table_for_right_table)
      {
        if(sql_context_ == NULL)
        {
          join_op.set_is_can_use_semi_join(false);
          ret = OB_ERR_POINTER_IS_NULL;
          YYSYS_LOG(WARN,"[semi join] sql_context is null!");
        }
        else
        {
          const common::ObSchemaManagerV2 *schema_manager = sql_context_->schema_manager_;
          IndexList first_table_index_table_list;//���������������index table��table id��
          IndexList second_table_index_table_list;//�������ұ�������index table��table id��
          if(schema_manager == NULL)
          {
            join_op.set_is_can_use_semi_join(false);
            ret = OB_ERR_POINTER_IS_NULL;
            YYSYS_LOG(WARN,"[semi join] schema manager is null!");
          }
          else
          {
            schema_manager->get_index_list(left_table_id,first_table_index_table_list);
            schema_manager->get_index_list(right_table_id,second_table_index_table_list);
            for(int64_t i=0;i<first_table_index_table_list.get_count();i++)
            {
              first_table_index_table_list.get_idx_id(i,first_table_id);
              YYSYS_LOG(DEBUG, "[semi join] first_table_index_table_list = [%ld]",first_table_id);
            }
            for(int64_t i=0;i<second_table_index_table_list.get_count();i++)
            {
              second_table_index_table_list.get_idx_id(i,second_table_id);
              YYSYS_LOG(DEBUG, "[semi join] second_table_index_table_list = [%ld]",second_table_id);
            }
          }
        }
      }
      //:e

      //add dragon [Bugfix 1224] 2016-8-25 10:02:26
      //�ж��Ƿ����ñ���
      if(OB_SUCCESS == ret)
      {
        if(OB_SUCCESS != (ret = join_op.set_alias_table (right_table_item->table_id_, select_stmt)))
        {
          join_op.set_is_can_use_semi_join (false);
          YYSYS_LOG(WARN, "don't know right table[%ld],ret[%d]", right_table_item->table_id_, ret);
        }
      }
      //add e

      //�ж��Ƿ�ʹ������ģ��:b
      if(OB_SUCCESS == ret && is_decide_use_index)
      {
        if ((ret = join_expr.fill_sql_expression(
               join_op_cnd,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS)
        {
          join_op.set_is_can_use_semi_join(false);
          YYSYS_LOG(WARN, "[semi join] fill join op condition faild!");
        }
        else
        {
          //�ж��Ƿ�ʹ������
          //���ж�on���ұ���ʽ�е����Ƿ�Ϊ�����У����Ϊ��������ʹ��������
          //�������id left_main_cid
          const ObTableSchema *left_mian_table_schema = NULL;
          if (NULL == (left_mian_table_schema = sql_context_->schema_manager_->get_table_schema(left_table_id)))
          {
            join_op.set_is_can_use_semi_join(false);
            ret = OB_ERR_POINTER_IS_NULL;
            YYSYS_LOG(ERROR,"[semi join] get left table schema faild");
          }
          else
          {
            const ObRowkeyInfo *left_rowkey_info = &left_mian_table_schema->get_rowkey_info();
            left_rowkey_info->get_column_id(0,left_main_cid);
            //�ұ�����id right_main_cid
            const ObTableSchema *right_mian_table_schema = NULL;
            if (NULL == (right_mian_table_schema = sql_context_->schema_manager_->get_table_schema(right_table_id)))
            {
              join_op.set_is_can_use_semi_join(false);
              ret = OB_ERR_POINTER_IS_NULL;
              YYSYS_LOG(ERROR,"[semi join] get right table schema faild");
            }
            else
            {
              const ObRowkeyInfo *right_rowkey_info = &right_mian_table_schema->get_rowkey_info();
              if(right_rowkey_info != NULL)
                right_rowkey_info->get_column_id(0,right_main_cid);
              else
              {
                join_op.set_is_can_use_semi_join(false);
                ret = OB_ERR_POINTER_IS_NULL;
                YYSYS_LOG(ERROR,"[semi join] get right table row key info faild");
              }
            }
          }
          //�ж��Ƿ�ʹ���û�hint��ָ����������:b
          if(OB_SUCCESS == ret)
          {
            if(select_stmt != NULL)
            {
              if(select_stmt->get_query_hint().has_index_hint())
              {
                //��hint��ÿ�ű�������ֻ�ܳ���һ�Σ������ͬһ�ű��Ķ�������������Ĭ��ʹ���б��еĵ�һ�� [20151225 9:07]
                for(int i=0;i < select_stmt->get_query_hint().use_index_array_.size ();i++)
                {
                  ObIndexTableNamePair tmp = select_stmt->get_query_hint().use_index_array_.at(i);
                  hint_tid=tmp.index_table_id_;
                  //YYSYS_LOG(ERROR,"test::fanqs,,tmp.src_table_id_=%ld,,from_item.table_id_=%ld",tmp.src_table_id_,from_item.table_id_);
                  if(tmp.src_table_id_ == right_table_id)
                  {
                    is_use_hint = true;
                    break;
                  }
                }
              }
            }
            else
            {
              join_op.set_is_can_use_semi_join(false);
              ret = OB_ERR_POINTER_IS_NULL;
              YYSYS_LOG(ERROR,"[semi join] get select stmt faild");
            }
          }
          //�ж��Ƿ�ʹ���û�hint��ָ����������:e
          //��ȡ��������Ϣ:b
          if(OB_SUCCESS == ret)
          {
            if(ObJoin::INNER_JOIN == join_type ||
               ObJoin::LEFT_OUTER_JOIN == join_type)
            {
              if(is_use_hint)
              {
                //����ұ����������ұ�on����ʽ�е���cid��ͬ���ſ���ʹ�ö�������
                if(expr2 != NULL && right_main_cid != expr2->get_second_ref_id()
                   && is_this_expr_can_use_index_for_join(expr2->get_second_ref_id(),
                                                          index_table_id,
                                                          right_table_id,
                                                          sql_context_->schema_manager_)
                   && index_table_id == hint_tid)
                {
                  is_use_index = true;
                  join_op.set_is_use_second_index(true);
                  //�ݲ�֧��right join
                  join_op.set_index_table_id(first_table_id,hint_tid);
                  join_op.set_id(id);
                }
              }
              else
              {
                if (select_stmt->get_query_hint().not_use_index_)
                {
                  YYSYS_LOG(DEBUG, "exist hint, not use index.");
                }
                else
                  //�ж��ұ���������id�Ƿ���on����ʽ���ұ����е�id��ͬ����ͬ�Ͳ�ʹ������
                  if(expr2 != NULL && right_main_cid != expr2->get_second_ref_id())
                  {
                    //�������������е��ұ���cidҪ��������������
                    if(is_this_expr_can_use_index_for_join(expr2->get_second_ref_id(),
                                                           index_table_id,
                                                           right_table_id,
                                                           sql_context_->schema_manager_)
                       && is_first_on_expr_with_index_)
                    {
                      is_use_index = true;
                      //join_op.set_id(id);//add wanglei [semi join on expr] 20160511
                      join_op.set_is_use_second_index(true);
                      join_op.set_index_table_id(first_table_id,index_table_id);
                      join_op.set_id(id);
                      is_first_on_expr_with_index_ = false;
                    }
                  }
              }
            }
          }
          //��ȡ��������Ϣ:e
        }
      }
      //�ж��Ƿ�ʹ������ģ��:e

      //add dragon [Bugfix 1224] 2016-8-29 14:53:42
      /*
       * �ж�ʹ�ö�������������:�ر����ǲ��ر�
       */
      if(OB_SUCCESS == ret && is_use_index)
      {
        //1.project
        //2.filter
        //if(all this index tab include all using column)
        // then: not back
        //else
        //  go back
        //end
        Expr_Array filter_array;
        Expr_Array project_array;
        uint64_t right_tid = OB_INVALID_ID;
        uint64_t right_idx_tid_used = is_use_hint ? hint_tid : index_table_id;
        if(NULL == right_table_item)
        {
          ret = OB_ERR_NULL_POINTER;
          YYSYS_LOG(WARN, "right_table_item is null");
        }
        else
        {
          right_tid = join_op.get_aliasT() ? right_table_item->table_id_ : right_table_id;
          if(OB_SUCCESS != (ret = get_project_and_filter_array(logical_plan,physical_plan,
                                                               right_tid, select_stmt,
                                                               project_array, filter_array)))
          {
            YYSYS_LOG(WARN, "failed to get filter_array and project array, ret=%d", ret);
          }
          else if (is_index_table_has_all_cid_V2(right_idx_tid_used, &filter_array, &project_array))
          {
            join_op.set_is_use_second_index_storing (true);
            join_op.set_is_use_second_index_without_storing (false);
          }
          else
          {
            join_op.set_is_use_second_index_storing (false);
            join_op.set_is_use_second_index_without_storing (true);
          }
        }
        if(OB_SUCCESS != ret)
        {
          join_op.set_is_can_use_semi_join(false);
        }
      }
      //add 2016-8-29 14:53:48e

      if(OB_SUCCESS == ret)
      {
        if ((ret = join_op.add_equijoin_condition(join_op_cnd)) != OB_SUCCESS)
        {
          YYSYS_LOG(WARN, "[semi join] Add condition of join plan faild");
        }
        else
        {
          //���Խ�on����ʽ�еĹ���������ѹ��b
          //is_add_other_join_condȷ��ֻ��ѹһ��
          if(!is_add_other_join_cond)
          {
            //add wanglei [semi join update] 20160510:b
            /*if(ret == OB_SUCCESS && is_cons_right_table_filter)
            {
              if(PHY_TABLE_MEM_SCAN == r_sort.get_child(0)->get_type())
              {
                join_op.set_is_can_use_semi_join(false);
                YYSYS_LOG(WARN,"[semi join] can not use semi join ! right table is memory table or sub query!");
              }
              else
              {
                ErrStat err_stat;
                ObFilter *right_table_filter = NULL;
                CREATE_PHY_OPERRATOR(right_table_filter, ObFilter, physical_plan, err_stat);
                ret = err_stat.err_code_;
                if(right_table_filter != NULL && ret == OB_SUCCESS)
                {
                  ObBitSet<> table_bitset;
                  int32_t num = 0;
                  if(right_table_item == NULL)
                  {
                    join_op.set_is_can_use_semi_join(false);
                    ret = OB_ERR_POINTER_IS_NULL;
                    YYSYS_LOG(ERROR,"[semi join] right table item is null!");
                  }
                  else if(select_stmt != NULL)
                  {
                    int32_t bit_index = select_stmt->get_table_bit_index(right_table_item->table_id_);
                    table_bitset.add_member(bit_index);
                    num = select_stmt->get_condition_size();
                    //���ұ�������filter���ŵ�right_table_filter�У�b
                    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
                    {
                      ObSqlRawExpr *cnd_expr = logical_plan->get_expr(select_stmt->get_condition_id(i));
                      if (cnd_expr && table_bitset.is_superset(cnd_expr->get_tables_set()))
                      {
                        ObSqlExpression *filter = ObSqlExpression::alloc();
                        if (NULL == filter)
                        {
                          join_op.set_is_can_use_semi_join(false);
                          ret = OB_ALLOCATE_MEMORY_FAILED;
                          break;
                        }
                        else if ((ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan)) != OB_SUCCESS)
                        {
                          join_op.set_is_can_use_semi_join(false);
                          ObSqlExpression::free(filter);
                          break;
                        }
                        else
                        {
                          //add dragon [Bugfix lmz-2017-2-6] 2017-2-7 b
                          // A.a IS NULL������left join֮ǰ�ͼ����ұ���filter��
                          int64_t start = yysys::CTimeUtil::getTime();
                          bool is_null_cond = false;
                          if(ObJoin::INNER_JOIN != join_type)
                          {
                            is_null_cond = filter->is_op_is_null();
                            YYSYS_LOG(DEBUG, "FILTER IS %s, is_null_cond[%s]", to_cstring(*filter), STR_BOOL(is_null_cond));
                          }
                          YYSYS_LOG(DEBUG, "Bugfix(lmz-2017-2-6) consume time is %ldus", yysys::CTimeUtil::getTime() - start);
                          if(!is_null_cond)
                          //add dragon e
                          ret = right_table_filter->add_filter (filter);
                          if(ret != OB_SUCCESS)
                          {
                            ObSqlExpression::free(filter);
                            YYSYS_LOG(WARN,"[semi join] add filter = {%s} to right table filter failed! ",to_cstring(*filter));
                            join_op.set_is_can_use_semi_join(false);
                            break;
                          }
//                          �ж��Ƿ���now��������
//                          ObSEArray<ObObj, 64> &item_array = filter->get_expr_array();
//                          YYSYS_LOG(DEBUG,"wanglei::filter = %s",to_cstring(*filter));
//                          YYSYS_LOG(DEBUG,"wanglei::item_array = %s",to_cstring(item_array));
//                          int64_t idx =0;
//                          int64_t count = item_array.count ();
//                          int64_t type = 0;
//                          bool is_time_type = false;
//                          while(idx<count)
//                          {
//                              if (OB_SUCCESS != (ret = item_array[idx].get_int(type)))
//                              {
//                                  YYSYS_LOG(WARN, "Fail to get op type. unexpected! ret=%d", ret);
//                                  break;
//                              }
//                              else if(type == ObPostfixExpression::CUR_TIME_OP)
//                              {
//                                  is_time_type =true;
//                                  break;
//                              }
//                              else if(type == ObPostfixExpression::CUR_TIME_HMS_OP)
//                              {
//                                  is_time_type =true;
//                                  break;
//                              }
//                              else if(type == ObPostfixExpression::CUR_DATE_OP)
//                              {
//                                  is_time_type =true;
//                                  break;
//                              }
//                              else if(type == ObPostfixExpression::OP
//                                      ||type == ObPostfixExpression::COLUMN_IDX
//                                      ||type == T_OP_ROW
//                                      ||type == ObPostfixExpression::CONST_OBJ
//                                      ||type == ObPostfixExpression::QUERY_ID
//                                      ||type == ObPostfixExpression::END
//                                      ||type == ObPostfixExpression::UPS_TIME_OP
//                                      ||type == ObPostfixExpression::PARAM_IDX
//                                      ||type == ObPostfixExpression::SYSTEM_VAR
//                                      ||type == ObPostfixExpression::TEMP_VAR
//                                      ||type == ObPostfixExpression::CUR_TIME_OP
//                                      ||type == ObPostfixExpression::CUR_TIME_HMS_OP
//                                      ||type == ObPostfixExpression::CUR_DATE_OP
//                                      ||type == ObPostfixExpression::END_TYPE
//                                      ||type == ObPostfixExpression::BEGIN_TYPE
//                                      )
//                              {
//                                  int64_t tmp = get_type_num(idx,type,item_array);
//                                  idx = idx + tmp;
//                                  if(tmp == -1)
//                                  {
//                                      break;
//                                  }
//                              }
//                              else
//                              {
//                                  YYSYS_LOG(WARN,"wrong expr type: %ld",type);
//                                  break;
//                              }
//                          }
//                          //�Ȳ��ж�ʲô���͵ı���ʽ��
//                          if(!is_time_type)
//                              join_op.add_right_table_filter (filter);
//                          else
//                              ObSqlExpression::free (filter);
                        }
                      }
                    }
                    //���ұ�������filter���ŵ�right_table_filter�У�e
                    if(ret == OB_SUCCESS)
                      join_op.set_right_table_filter (right_table_filter);
                  }
                  else
                  {
                    join_op.set_is_can_use_semi_join(false);
                    ret = OB_ERR_POINTER_IS_NULL;
                    YYSYS_LOG(ERROR,"[semi join] select stmt is null!");
                  }
                }
                else
                {
                  join_op.set_is_can_use_semi_join(false);
                  ret = OB_ERR_POINTER_IS_NULL;
                  YYSYS_LOG(ERROR,"[semi join] right table filter create failed!");
                }
              }
            }*/
            if (OB_SUCCESS == ret && is_cons_right_table_filter)
            {
              ErrStat err_stat;
              ObFilter *right_table_filter = NULL;
              ObBitSet<> table_bitset;
              if (NULL == r_sort.get_child(0) || PHY_TABLE_RPC_SCAN != r_sort.get_child(0)->get_type())
              {
                join_op.set_is_can_use_semi_join(false);
                if (NULL == r_sort.get_child(0)) ret = OB_ERR_POINTER_IS_NULL;
                YYSYS_LOG(WARN,"[semi join] can not use semi join ! right phy is not table rpc scan! ret=%d",ret);
              }
              else if(NULL == right_table_item || NULL == select_stmt)
              {
                ret = OB_ERR_POINTER_IS_NULL;
                YYSYS_LOG(ERROR,"[semi join] right_table_item or select stmt is null!");
              }
              else if(!(table_bitset.add_member(select_stmt->get_table_bit_index(right_table_item->table_id_))))
              {
                ret = OB_ERR_UNEXPECTED;
                YYSYS_LOG(WARN,"bitset add index failed,ret=%d",ret);
              }
              else if(NULL == CREATE_PHY_OPERRATOR(right_table_filter, ObFilter, physical_plan, err_stat)
                      || OB_SUCCESS != (ret = err_stat.err_code_))
              {
                ret = OB_ERR_POINTER_IS_NULL;
                YYSYS_LOG(ERROR,"[semi join] right table filter create failed!");
              }
              else
              {
                for(int32_t i=0; ret == OB_SUCCESS && i < select_stmt->get_condition_size(); i++)
                {
                  ObSqlRawExpr *cnd_expr = NULL;
                  ObSqlExpression *filter = NULL;
                  if (NULL == (cnd_expr = logical_plan->get_expr(select_stmt->get_condition_id(i))))
                  {
                    ret = OB_ERR_POINTER_IS_NULL;
                    YYSYS_LOG(ERROR,"[semi join] condition expr is null!");
                  }
                  else if(false == table_bitset.is_superset(cnd_expr->get_tables_set()))
                  {//do nothing
                  }
                  else if(NULL == (filter = ObSqlExpression::alloc()))
                  {
                    ret = OB_ALLOCATE_MEMORY_FAILED;
                    YYSYS_LOG(WARN,"allocate memory for filter failed");
                  }
                  else if(OB_SUCCESS !=
                          (ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan)))
                  {
                    TRANS_LOG("construct right table filter of semi join plan failed");
                  }
                  else if(ObJoin::INNER_JOIN != join_type && false == cnd_expr->can_push_down_with_outerjoin())
                  {
                    if(NULL != filter)
                    {
                      ObSqlExpression::free(filter);
                      filter = NULL;
                    }
                  }
                  else if(OB_SUCCESS != (ret = right_table_filter->add_filter(filter)))
                  {
                    YYSYS_LOG(WARN,"[semi join] add filter[%d] to right table filter failed! ret=%d", i, ret);
                  }
                  if(OB_SUCCESS != ret)
                  {
                    join_op.set_is_can_use_semi_join(false);
                    if(NULL != filter)
                    {
                      ObSqlExpression::free(filter);
                      filter = NULL;
                    }
                    break;
                  }
                }
              }
              if(OB_SUCCESS != ret)
              {
                join_op.set_is_can_use_semi_join(false);
                if (NULL != right_table_filter)
                {
                  right_table_filter->reset();
                  right_table_filter->~ObFilter();
                  right_table_filter = NULL;
                }
              }
              if(OB_SUCCESS == ret && NULL != right_table_filter)
              {
                join_op.set_right_table_filter(right_table_filter);
              }
            }//end if
            //add wanglei [semi join update] 20160510:e
            /*
            if(ObJoin::INNER_JOIN == join_type && ret == OB_SUCCESS && is_on_expr_push_down)
            {
              int il = 0;
              oceanbase::common::ObList<ObSqlRawExpr*>::iterator cnd_it_ll;
              for (cnd_it_ll = remainder_cnd_list.begin(); cnd_it_ll != remainder_cnd_list.end();++cnd_it_ll )
              {
                if(ret != OB_SUCCESS)
                  break;
                //�жϱ���ʽ�Ƿ��ǵ�ֵ����ʽ�����������������ж��Ƿ������ѹ
                if((*cnd_it_ll)->get_expr()->is_join_cond())
                {
                  continue;
                }
                else
                {
                  //on����ı���ʽ��ѹ���б�����������»�ʧЧ����������Ѿ����
                  //Ŀǰ������sort����������ObTableRpcScan��ObTableMemScan�������������ҵ��������Ĳ��������޷�����ʹ��semi join
                  ObTableRpcScan * t_r_operator = NULL;
                  ObTableMemScan * t_m_operator = NULL;
                  int64_t table_id = OB_INVALID_ID;
                  ObSqlExpression *expr_temp = ObSqlExpression::alloc();
                  if(expr_temp == NULL)
                  {
                    join_op.set_is_can_use_semi_join(false);
                    ret = OB_ALLOCATE_MEMORY_FAILED;
                    YYSYS_LOG(WARN,"[semi join] expression is null!");
                    break;
                  }
                  else
                  {
                    //every repeats will reset the value of ret
                    ret = (*cnd_it_ll)->fill_sql_expression(*expr_temp,this,logical_plan,physical_plan);
                    il++;
                    if(ret != OB_SUCCESS)
                    {
                      ObSqlExpression::free(expr_temp);
                      YYSYS_LOG(WARN,"[semi join] expression is null!");
                      break;
                    }
                    else
                    {
                      ObSEArray<ObObj, 64> &item_array = expr_temp->get_expr_array();
                      //Ĭ�϶�����������ұ���ֵ����������򲻿���ʹ��semi join
                      item_array[1].get_int(table_id);
                      //�ж��Ƿ���t1.c1>t2.id���ֱ���ʽ��b
                      int64_t val = 0;
                      if(item_array.count () >3 && ObIntType == item_array[3].get_type()
                         && OB_SUCCESS == item_array[3].get_int(val)
                         && ObPostfixExpression::COLUMN_IDX == val)
                      {
                        is_non_equal_cond = true;
                      }
                      else
                      {
                        //YYSYS_LOG(WARN,"[semi join] item array count less then 3!");
                      }
                    }
                    //�ж�t1.c1>t2.id���ֱ���ʽ����������ֱ���ʽҲ����ѹ������ִ���
                    if(!is_non_equal_cond && ret == OB_SUCCESS && expr_temp != NULL)
                    {
                      if(table_id == (int64_t)expr1->get_first_ref_id())
                      {
                        //�ݲ��������ʹ�������������Ҳ����right join�ݲ�֧��
                        if(NULL == l_sort.get_child(0))
                        {
                          join_op.set_is_can_use_semi_join(false);
                          ret = OB_ERR_POINTER_IS_NULL;
                          YYSYS_LOG(WARN,"[semi join] left sort op is null!");
                          break;
                        }
                        else
                        {
                          //���Ŀǰֻ����table rpc scan �� table mem scan �������
                          if(l_sort.get_child(0)!= NULL && PHY_TABLE_MEM_SCAN == l_sort.get_child(0)->get_type())
                          {
                            if(NULL != (t_m_operator = dynamic_cast<ObTableMemScan *>(l_sort.get_child(0))))
                            {
                              //�ݲ�֧���Ӳ�ѯ��filter��ѹ���ײ���������
                              ret = t_m_operator->add_filter(expr_temp);
                              if(ret != OB_SUCCESS)
                              {
                                ObSqlExpression::free(expr_temp);
                                YYSYS_LOG(WARN,"[semi join] add expression failed!");
                                break;
                              }
                            }
                            else
                            {
                              join_op.set_is_can_use_semi_join(false);
                              ret = OB_ERR_POINTER_IS_NULL;
                              YYSYS_LOG(WARN,"[semi join] right table memory scan op is null!");
                              break;
                            }
                          }
                          else if(l_sort.get_child(0)!= NULL && PHY_TABLE_RPC_SCAN == l_sort.get_child(0)->get_type())
                          {
                            if(NULL != (t_r_operator = dynamic_cast<ObTableRpcScan *>(l_sort.get_child(0))))
                            {
                              // ������ʹ�õ��ǻر���������ѯ���ݲ���ѹ��
                              if(!t_r_operator->get_rpc_scan().get_is_use_index())
                                ret = t_r_operator->add_filter(expr_temp);
                              else
                              {
                                ObSqlExpression::free(expr_temp);
                                expr_temp = NULL;
                              }
                              if(ret != OB_SUCCESS)
                              {
                                ObSqlExpression::free(expr_temp);
                                YYSYS_LOG(WARN,"[semi join] add expression failed!");
                                break;
                              }
                            }
                            else
                            {
                              join_op.set_is_can_use_semi_join(false);
                              ret = OB_ERR_POINTER_IS_NULL;
                              YYSYS_LOG(WARN,"[semi join] right table rpc scan op is null!");
                              break;
                            }
                          }
                          else
                          {
                            YYSYS_LOG(INFO, "Not supported feature or function, "
                                            "the child of sort is not scan operation");
                          }
                        }
                      }
                      else //�ұ�������filter //�ⲿ��Ϊon����ʽ���漰�����ұ���filter
                      {
                        if(r_sort.get_child(0) == NULL)
                        {
                          join_op.set_is_can_use_semi_join(false);
                          ret = OB_ERR_POINTER_IS_NULL;
                          YYSYS_LOG(WARN,"[semi join] right sort op is null!");
                          break;
                        }
                        else
                        {
                          if(PHY_TABLE_MEM_SCAN == r_sort.get_child(0)->get_type())
                          {
                            if(NULL != (t_m_operator = dynamic_cast<ObTableMemScan *>(r_sort.get_child(0))))
                            {
                              //�ݲ�֧���Ӳ�ѯ��filter��ѹ���ײ���������
                              ret = t_m_operator->add_filter(expr_temp);
                              if(ret != OB_SUCCESS)
                              {
                                ObSqlExpression::free(expr_temp);
                                YYSYS_LOG(WARN,"[semi join] add expression failed!");
                                break;
                              }
                            }
                          }
                          else if(PHY_TABLE_RPC_SCAN == r_sort.get_child(0)->get_type())
                          {
                            if(NULL != (t_r_operator = dynamic_cast<ObTableRpcScan *>(r_sort.get_child(0))))
                            {

                              if(is_use_index && ret == OB_SUCCESS) //�ж��Ƿ�ʹ������
                              {
                                //index_table_id
                                //Ҫ���������ʽ���д������ж����Ƿ������������
                                //�ж������������ж������ڲ����������У�����ڷ���������id
                                //Ȼ�����жϣ�����������on����ʽ���з��ص��������Ƿ�һ�������һ�������ʹ�ã�����ʹ�á�
                                uint64_t expr_temp_cid = OB_INVALID_ID;
                                uint64_t expr_temp_tid = OB_INVALID_ID;
                                expr_temp->find_cid(expr_temp_cid);
                                if (right_main_cid == expr_temp_cid)
                                {
                                  //���������Ŀǰ�ķ����ǲ���ѹ
                                  //t_r_operator->add_filter(expr_temp);
                                  ret = t_r_operator->add_main_filter(expr_temp);
                                  if(ret != OB_SUCCESS)
                                  {
                                    ObSqlExpression::free(expr_temp);
                                    YYSYS_LOG(WARN,"[semi join] add expression failed!");
                                    break;
                                  }
                                }
                                else if(is_this_expr_can_use_index_for_join(expr_temp_cid,
                                                                            expr_temp_tid,
                                                                            right_table_id,
                                                                            sql_context_->schema_manager_))
                                {
                                  if(expr_temp_tid == index_table_id) //�������ʽ����������on����һ����������ѹ
                                  {
                                    if(OB_SUCCESS != (ret = t_r_operator->add_main_filter(expr_temp)))
                                    {
                                      join_op.set_is_can_use_semi_join(false);
                                      ObSqlExpression::free(expr_temp);
                                      YYSYS_LOG(ERROR,"[semi join] add expr to right table faild! ret=%d",ret);
                                      break;
                                    }
                                    //�ı�expr��table idΪ��������table id
                                    ObPostfixExpression& ops = expr_temp->get_decoded_expression_v2();
                                    uint64_t index_of_expr_array=OB_INVALID_ID;
                                    if(OB_SUCCESS == ret && OB_SUCCESS != (ret = expr_temp->change_tid(index_of_expr_array)))
                                    {
                                      join_op.set_is_can_use_semi_join(false);
                                      ObSqlExpression::free(expr_temp);
                                      YYSYS_LOG(ERROR,"[semi join] faild to change tid,filter=%s",to_cstring(*expr_temp));
                                      break;
                                    }
                                    else
                                    {
                                      ObObj& obj = ops.get_expr_by_index(index_of_expr_array);
                                      if(obj.get_type() == ObIntType)
                                        obj.set_int(index_table_id);
                                      if(OB_SUCCESS == ret)
                                      {
                                        if(OB_SUCCESS != (ret = t_r_operator->add_filter(expr_temp)))
                                        {
                                          join_op.set_is_can_use_semi_join(false);
                                          ObSqlExpression::free(expr_temp);
                                          YYSYS_LOG(WARN,"[semi join] add expr to right table faild! ret=%d",ret);
                                          break;
                                        }
                                        else if(OB_SUCCESS != (ret = t_r_operator->add_index_filter_ll ((expr_temp))))
                                        {
                                          join_op.set_is_can_use_semi_join(false);
                                          ObSqlExpression::free(expr_temp);
                                          YYSYS_LOG(WARN,"[semi join] add expr to right table faild! ret=%d",ret);
                                          break;
                                        }
                                      }
                                    }
                                  }
                                  else
                                  {
                                    if(OB_SUCCESS == ret && OB_SUCCESS!=(ret = t_r_operator->add_main_filter(expr_temp)))
                                    {
                                      join_op.set_is_can_use_semi_join(false);
                                      ObSqlExpression::free(expr_temp);
                                      YYSYS_LOG(ERROR,"[semi join] faild to change tid,filter=%s",to_cstring(*expr_temp));
                                    }
                                  }
                                }
                                else
                                {
                                  if(OB_SUCCESS == ret && OB_SUCCESS!=(ret = t_r_operator->add_main_filter(expr_temp)))
                                  {
                                    join_op.set_is_can_use_semi_join(false);
                                    ObSqlExpression::free(expr_temp);
                                    YYSYS_LOG(ERROR,"[semi join] faild to change tid,filter=%s",to_cstring(*expr_temp));
                                  }
                                }
                              }
                              else
                              {
                                if(OB_SUCCESS == ret && OB_SUCCESS!=(ret = t_r_operator->add_filter(expr_temp)))
                                {
                                  join_op.set_is_can_use_semi_join(false);
                                  ObSqlExpression::free(expr_temp);
                                  YYSYS_LOG(ERROR,"[semi join] faild to change tid,filter=%s",to_cstring(*expr_temp));
                                  break;
                                }
                              }
                            }
                            else
                            {
                              join_op.set_is_can_use_semi_join(false);
                              ObSqlExpression::free(expr_temp);
                              ret = OB_ERR_POINTER_IS_NULL;
                              YYSYS_LOG(WARN,"[semi join] right table rpc scan op is null!");
                              break;
                            }
                          }
                          else
                          {
                            YYSYS_LOG(INFO, "Not supported feature or function, "
                                            "the child of sort is not scan operation");
                          }
                        }
                      }
                    }
                  }
                  //when ret is not success, expr_temp must be release
                  if(ret != OB_SUCCESS && expr_temp!=NULL)
                  {
                    ObSqlExpression::free(expr_temp);
                    break;
                  }
                }
              }
              is_add_other_join_cond=true;
            }
            */
            if(ObJoin::INNER_JOIN == join_type && ret == OB_SUCCESS && is_on_expr_push_down)
            {
              if(NULL == expr1)
              {
                ret = OB_INVALID_ARGUMENT;
                YYSYS_LOG(ERROR, "first_op_expr is null,ret=%d",ret);
              }
              if(OB_SUCCESS == ret)
              {
                oceanbase::common::ObList<ObSqlRawExpr *>::iterator cnd_it_ll;
                for (cnd_it_ll = remainder_cnd_list.begin();
                     OB_SUCCESS == ret && cnd_it_ll != remainder_cnd_list.end(); ++cnd_it_ll)
                {
                  uint64_t table_id = OB_INVALID_ID;
                  bool add_suc = true;
                  ObSqlExpression *expr_temp = NULL;
                  if (NULL == (*cnd_it_ll)->get_expr())
                  {
                    ret = OB_ERR_POINTER_IS_NULL;
                    YYSYS_LOG(WARN, "[semi join] ObSqlRawExpr is null!");
                  }
                  else if((*cnd_it_ll)->get_expr()->is_join_cond())
                  {
                    continue;
                  }
                  if( NULL == (expr_temp = ObSqlExpression::alloc()))
                  {
                    ret = OB_ALLOCATE_MEMORY_FAILED;
                    YYSYS_LOG(WARN, "[semi join] expression is null!");
                  }
                  else if(OB_SUCCESS !=
                          (ret = (*cnd_it_ll)->fill_sql_expression(*expr_temp, this,logical_plan, physical_plan)))
                  {
                    YYSYS_LOG(WARN, "[semi join] fill_sql_expression failed!");
                  }
                  else if(expr_temp->is_not_equal_cond(table_id))
                  {
                    if (OB_INVALID_ID == table_id)
                    {
                      YYSYS_LOG(ERROR, "table id in expr is not valid");
                    }
                    if(NULL != expr_temp)
                    {
                      ObSqlExpression::free(expr_temp);
                      expr_temp = NULL;
                    }
                  }
                  else if(table_id == expr1->get_first_ref_id())
                  {
                    if(OB_SUCCESS != (ret = semi_join_add_filter(right_main_cid, right_table_id, index_table_id, l_sort, expr_temp, true, add_suc)))
                    {
                      YYSYS_LOG(WARN, "left sort add filter failed,ret = %d",ret);
                    }
                  }
                  else
                  {
                    if (OB_SUCCESS != (ret = semi_join_add_filter(right_main_cid, right_table_id, index_table_id, r_sort,expr_temp, false,add_suc)))
                    {
                      YYSYS_LOG(WARN, "left sort add filter failed,ret = %d",ret);
                    }
                  }
                  if(OB_SUCCESS != ret || !add_suc)
                  {
                    if (OB_SUCCESS != ret)
                    {
                      join_op.set_is_can_use_semi_join(false);
                    }
                    if (NULL != expr_temp)
                    {
                      ObSqlExpression::free(expr_temp);
                      expr_temp = NULL;
                    }
                  }
                  if(OB_SUCCESS != ret)
                  {
                    break;
                  }
                }//end for
              }
              is_add_other_join_cond = true;
            }
          }
        }
        if (OB_SUCCESS != ret)
        {
          join_op.set_is_can_use_semi_join(false);
        }
      }
    }
  }
  if(OB_SUCCESS == ret)
  {
    if(r_sort.get_child(0) == NULL || l_sort.get_child(0) == NULL)
    {
      ret = OB_ERR_POINTER_IS_NULL;
      YYSYS_LOG(WARN,"[semi join] left sort op is null or right sort op is null");
    }
    else if(PHY_TABLE_MEM_SCAN == r_sort.get_child(0)->get_type())// ||PHY_TABLE_MEM_SCAN == l_sort.get_child(0)->get_type())

    {
      join_op.set_is_can_use_semi_join(false);
    }
    else
    {
      //Ŀǰ������
      /*for(int i = 0;i< logical_plan->get_expr_list_num();i++)
            {
                ObSqlRawExpr * ob_sql_raw_expr = logical_plan->get_expr_for_something(i);
                ObSqlExpression cnd_ll_;
                ob_sql_raw_expr->fill_sql_expression(cnd_ll_,this,logical_plan,physical_plan);
                ObSEArray<ObObj, 64> &item_array = cnd_ll_.get_expr_array();
                int64_t table_id = OB_INVALID_ID;
                item_array[1].get_int(table_id);
                // YYSYS_LOG(WARN, "wl filter list = [%s]",to_cstring(cnd_ll_));
                if(!ob_sql_raw_expr->get_expr()->is_join_cond())
                {
                    if(ObJoin::INNER_JOIN == join_type ||
                            ObJoin::LEFT_OUTER_JOIN == join_type)
                    {
                        if(table_id == (int64_t)expr2->get_first_ref_id())
                        {
                            if(item_array.count() == project_column_item_array_length)//project �е�ÿһ����4��obj���
                            {
                                //nothing to do here
                                continue;
                            }
                            else
                            {
                                join_op.set_is_can_use_semi_join(false);
                                break;
                            }
                        }
                    }
                    else
                    {
                        if(table_id == (int64_t)expr1->get_first_ref_id())
                        {
                            if(item_array.count() == project_column_item_array_length)//project �е�ÿһ����4��obj���
                            {
                                //nothing to do here
                                continue;
                            }
                            else
                            {
                                join_op.set_is_can_use_semi_join(false);
                                break;
                            }
                        }
                    }

                }
            }*/
      /*if(is_left_has_filter && is_right_has_filter)
            {
                join_op.set_is_can_use_semi_join(false);
            }*/
    }
  }
  //add 2016/1/5 for explain
  //    if(OB_SUCCESS == ret)
  //    {
  //        ObBasicStmt *stmt = NULL;
  //        if (ret == OB_SUCCESS)
  //        {
  //            if (query_id == OB_INVALID_ID)
  //                stmt = logical_plan->get_main_stmt();
  //            else
  //                stmt = logical_plan->get_query(query_id);
  //            if (stmt == NULL)
  //            {
  //                ret = OB_ERR_ILLEGAL_ID;
  //                TRANS_LOG("Wrong query id to find query statement");
  //            }
  //        }
  //    }
  //add e
  //    if(ret == OB_SUCCESS)
  //    {
  //        char sql_str_buf[OB_MAX_VARCHAR_LENGTH];
  //        char table_name[50];
  //        memset(table_name,'\0',sizeof(table_name));
  //        snprintf(table_name, sizeof(table_name), "%.*s", left_table_item->table_name_.length(), left_table_item->table_name_.ptr());
  //        snprintf(sql_str_buf, OB_MAX_VARCHAR_LENGTH, "SELECT count(*) FROM %s;",table_name);
  //        ObString get_params_sql_str = ObString::make_string(sql_str_buf);
  //        ObMySQLResultSet *raw_result = (ObMySQLResultSet*)sql_context_->session_info_->get_current_result_set ();
  //        if ((ret = raw_result->init()) != OB_SUCCESS)
  //        {
  //            YYSYS_LOG(ERROR, "Init result set failed, ret = %d", ret);
  //        }
  //        else if ((ret = ObSql::direct_execute(get_params_sql_str, *raw_result, *sql_context_)) != OB_SUCCESS)
  //        {
  //            YYSYS_LOG(ERROR,"Execute sql: %s, failed, ret=%d", sql_str_buf, ret);
  //        }
  //        else if ((ret = raw_result->open()) != OB_SUCCESS)
  //        {
  //            YYSYS_LOG(ERROR, "Failed to open result set, ret=%d", ret);
  //            if (raw_result->close() != OB_SUCCESS)
  //            {
  //                YYSYS_LOG(WARN, "Failed to close result set");
  //            }
  //        }
  //        else if (raw_result->is_with_rows() != true)
  //        {
  //            YYSYS_LOG(WARN, "Sql: '%s', get nothing, ret=%d", sql_str_buf, ret);
  //        }
  //        else
  //        {
  //            ObMySQLRow sql_row;
  //            while ((ret = raw_result->next_row(sql_row)) == OB_SUCCESS)
  //            {
  //                const ObRow *row = sql_row.get_inner_row();
  //                if(ret == OB_SUCCESS)
  //                {
  //                    YYSYS_LOG(ERROR,"wangelei::direct test row:%s",to_cstring(*row));
  //                }
  //            } // end while
  //            if (ret == OB_ITER_END)
  //            {
  //                ret = OB_SUCCESS;
  //            }
  //            else if (ret != OB_SUCCESS)
  //            {
  //                YYSYS_LOG(ERROR, "Get next row from ObMySQLResultSet failed, ret=%d", ret);
  //            }
  //            if (raw_result->close() != OB_SUCCESS)
  //            {
  //                YYSYS_LOG(ERROR, "Failed to close result set");
  //            }
  //        }
  //        if (OB_SUCCESS == ret)
  //        {
  //          if (OB_SUCCESS != (ret = sql_context_->session_info_->update_session_timeout()))
  //          {
  //            YYSYS_LOG(ERROR, "failed to update_session_timeout, ret=%d", ret);
  //          }
  //        }
  //    }
  return ret;
}
//add:e
int ObTransformer::add_merge_join_expr(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ObMergeJoin& join_op,
    ObSort& l_sort,
    ObSort& r_sort,
    ObSqlRawExpr& expr,
    const bool is_table_expr_same_order)
{
  int ret = OB_SUCCESS;
  ObSqlRawExpr join_expr = expr;
  ObBinaryOpRawExpr equal_expr = *(dynamic_cast<ObBinaryOpRawExpr*>(expr.get_expr()));
  join_expr.set_expr(&equal_expr);
  if (OB_UNLIKELY(!expr.get_expr() || expr.get_expr()->get_expr_type() != T_OP_EQ))
  {
    ret = OB_ERR_GEN_PLAN;
    YYSYS_LOG(WARN, "Wrong expression of merge join, ret=%d", ret);
  }
  else
  {
    ObBinaryRefRawExpr *expr1 = NULL;
    ObBinaryRefRawExpr *expr2 = NULL;
    if (is_table_expr_same_order)
    {
      expr1 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_first_op_expr());
      expr2 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_second_op_expr());
    }
    else
    {
      expr2 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_first_op_expr());
      expr1 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_second_op_expr());
      equal_expr.set_op_exprs(expr1, expr2);
    }
    if ((ret = l_sort.add_sort_column(expr1->get_first_ref_id(), expr1->get_second_ref_id(), true)) != OB_SUCCESS
        ||(ret = r_sort.add_sort_column(expr2->get_first_ref_id(), expr2->get_second_ref_id(), true)) != OB_SUCCESS)
    {
      YYSYS_LOG(WARN, "Add sort column faild, ret=%d", ret);
    }
    else
    {
      ObSqlExpression join_op_cnd;
      if ((ret = join_expr.fill_sql_expression(
             join_op_cnd,
             this,
             logical_plan,
             physical_plan)) != OB_SUCCESS)
      {
      }
      else if ((ret = join_op.add_equijoin_condition(join_op_cnd)) != OB_SUCCESS)
      {
        YYSYS_LOG(WARN, "Add condition of join plan faild");
      }
    }
  }
  return ret;
}

int ObTransformer::gen_phy_joins(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObSelectStmt *select_stmt,
    ObJoin::JoinType join_type,
    oceanbase::common::ObList<ObPhyOperator*>& phy_table_list,
    oceanbase::common::ObList<ObBitSet<> >& bitset_list,
    oceanbase::common::ObList<ObSqlRawExpr*>& remainder_cnd_list,
    oceanbase::common::ObList<ObSqlRawExpr*>& none_columnlize_alias,
    bool implied_join,
    bool optimizer_open,
    bool effective_from_opt,
    JoinedTable::JoinOperator opt_join_operator,
    bool effective_opt,
    bool outer_join_scope//add liumz, [outer_join_on_where]20150927
    )
{
  bool is_add_other_join_cond = false;//add wanglei [semi join] 20151225:b
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  oceanbase::common::ObList<ObBitSet<> > bitset_from_list;
  if (effective_from_opt)
  {
    oceanbase::common::ObList<ObBitSet<> >::iterator bitset_it = bitset_list.begin();
    while (ret == OB_SUCCESS
           && bitset_it != bitset_list.end())
    {
      bitset_from_list.push_back((*bitset_it));
      bitset_it++;
    }
  }
  oceanbase::common::ObList<ObSqlRawExpr*> tmp_remainder_cnd_list;
  if (implied_join && remainder_cnd_list.size() > 0)
  {
    oceanbase::common::ObList<ObSqlRawExpr*>::iterator cnd_it;
    oceanbase::common::ObList<ObSqlRawExpr*>::iterator del_it;
    ObVector< ObBitSet<> > joined_formitem_bitsets;

    int32_t num_item = select_stmt->get_from_item_size();
    for (int32_t i = 0; ret == OB_SUCCESS && i < num_item; i++)
    {
      const FromItem& from_item = select_stmt->get_from_item(i);
      if (ret == OB_SUCCESS && from_item.is_joined_)
      {
        JoinedTable *joined_table = select_stmt->get_joined_table(from_item.table_id_);
        if (joined_table == NULL)
        {
          ret = OB_ERR_ILLEGAL_ID;
          YYSYS_LOG(ERROR, "Wrong joined table id '%lu'", from_item.table_id_);
          break;
        }
        OB_ASSERT(joined_table->table_ids_.count() >= 2);
        OB_ASSERT(joined_table->table_ids_.count() - 1 == joined_table->join_types_.count());
        OB_ASSERT(joined_table->join_types_.count() == joined_table->expr_nums_per_join_.count());
        ObBitSet<> joined_table_bit_set;

        for(int32_t j=0; ret == OB_SUCCESS && j < joined_table->table_ids_.count(); j++)
        {
          ret = joined_table_bit_set.add_member(select_stmt->get_table_bit_index(joined_table->table_ids_.at(j)))?OB_SUCCESS:OB_ERROR;
        }
        if (ret == OB_SUCCESS)
        {
          ret = joined_formitem_bitsets.push_back(joined_table_bit_set);
        }
      }
    }
    if (ret == OB_SUCCESS && joined_formitem_bitsets.size() != 0)
    {
      for (cnd_it = remainder_cnd_list.begin(); ret == OB_SUCCESS && cnd_it != remainder_cnd_list.end(); cnd_it++)
      {
        if ((*cnd_it)->get_expr()->is_join_cond_opt())
        {
          for (int32_t j = 0; ret == OB_SUCCESS && j < joined_formitem_bitsets.size(); j++)
          {
            if (joined_formitem_bitsets.at(j).is_superset((*cnd_it)->get_tables_set()))
            {
              del_it = cnd_it;
              if ((ret = tmp_remainder_cnd_list.push_back(*cnd_it)) != OB_SUCCESS)
              {
                TRANS_LOG("Generate join plan faild");
                break;
              }
              else if ((ret = remainder_cnd_list.erase(del_it)) != OB_SUCCESS)
              {
                TRANS_LOG("Generate join plan faild");
                break;
              }
              YYSYS_LOG(DEBUG, "join expr is filter condition");
              break;
            }
          }
        }
      }
    }
  }
  int32_t index_ = 0;
  int32_t same_join_method = 0;
  while (ret == OB_SUCCESS && phy_table_list.size() > 1)
  {
    ObAddProject *project_op = NULL;
    ObMergeJoin *join_op = NULL;
    /*add by wanglei [semi join] 20151231*/
    ObSemiJoin *semi_join_op = NULL;
    //add e
    ObBloomFilterJoin *bloomfilter_join_op = NULL;
    ObHashJoinSingle *hash_join_single_op = NULL;

    if(select_stmt->get_query_hint().join_array_.size()>index_)
    {
      ObJoinTypeArray tmp = select_stmt->get_query_hint().join_array_.at(index_);
      if(tmp.join_type_ == T_BLOOMFILTER_JOIN&&(join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN))
      {
        CREATE_PHY_OPERRATOR(bloomfilter_join_op, ObBloomFilterJoin, physical_plan, err_stat);
        if (OB_SUCCESS == ret)//add qianzm [null operator unjudgement bug1181] 20160520
        {
          bloomfilter_join_op->set_join_type(join_type);
        }
      }
      else if((tmp.join_type_ == T_SEMI_JOIN ||tmp.join_type_ == T_SEMI_BTW_JOIN )
              && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN))
      {
        CREATE_PHY_OPERRATOR(semi_join_op, ObSemiJoin, physical_plan, err_stat);
        if (OB_SUCCESS == ret)//add qianzm [null operator unjudgement bug1181] 20160520
        {
          semi_join_op->set_join_type(join_type);
        }
      }
      else if(tmp.join_type_ == T_HASH_JOIN_SINGLE && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN || join_type == ObJoin::FULL_OUTER_JOIN))
      {
        CREATE_PHY_OPERRATOR(hash_join_single_op, ObHashJoinSingle, physical_plan, err_stat);
        if (OB_SUCCESS == ret)//add qianzm [null operator unjudgement bug1181] 20160520
        {
          hash_join_single_op->set_join_type(join_type);
        }
      }
      else
      {
        CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
        if (OB_SUCCESS == ret)//add qianzm [null operator unjudgement bug1181] 20160520
        {
          join_op->set_join_type(join_type);
        }
      }
    }
    else if(effective_opt)
    {
      switch (opt_join_operator)
      {
        case JoinedTable::SEMI_JOIN:
          CREATE_PHY_OPERRATOR(semi_join_op, ObSemiJoin, physical_plan, err_stat);
          if (OB_SUCCESS == ret)
          {
            semi_join_op->set_join_type(join_type);
          }
          break;
        case JoinedTable::BLOOMFILTER_JOIN:
          CREATE_PHY_OPERRATOR(bloomfilter_join_op, ObBloomFilterJoin, physical_plan, err_stat);
          if (OB_SUCCESS == ret)
          {
            bloomfilter_join_op->set_join_type(join_type);
          }
          break;
        case JoinedTable::HASH_JOIN:
          CREATE_PHY_OPERRATOR(hash_join_single_op, ObHashJoinSingle, physical_plan, err_stat);
          if (OB_SUCCESS == ret)
          {
            hash_join_single_op->set_join_type(join_type);
          }
          break;
        case JoinedTable::MERGE_JOIN:
          CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
          if (OB_SUCCESS == ret)
          {
            join_op->set_join_type(join_type);
          }
          break;
        default:
          /*won't be here*/
          CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
          if (OB_SUCCESS == ret)
          {
            join_op->set_join_type(join_type);
          }
          break;
      }
    }
    else if(effective_from_opt)
    {
      oceanbase::common::ObList<ObFromItemJoinMethodHelper*> * fromitem_method_list = select_stmt->get_from_item_method_list();
      int64_t fromitem_method_list_size = fromitem_method_list->size();

      if (fromitem_method_list_size > 0)
      {
        oceanbase::common::ObList<ObFromItemJoinMethodHelper*>::iterator fromitem_method_opt_it = fromitem_method_list->begin();
        int32_t it_id = 0;
        while (ret == OB_SUCCESS
               && fromitem_method_opt_it != fromitem_method_list->end())
        {
          if (it_id < index_ + same_join_method)
          {
            fromitem_method_opt_it++;
            it_id++;
            continue;
          }
          else
          {
            effective_opt = true;
            break;
          }
        }
        if(fromitem_method_opt_it == fromitem_method_list->end())
        {
          opt_join_operator = JoinedTable::MERGE_JOIN;
          CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
          if (OB_SUCCESS == ret)
          {
            join_op->set_join_type(join_type);
          }
        }
        else
        {
          int join_method = JoinedTable::MERGE_JOIN;
          bool merge_join = false, semi_join = false, bloomfilter_join = false, hash_join = false;
          do
          {
            switch ((*fromitem_method_opt_it)->join_method)
            {
              case JoinedTable::SEMI_JOIN:
                semi_join = true;
                break;
              case JoinedTable::BLOOMFILTER_JOIN:
                bloomfilter_join = true;
                break;
              case JoinedTable::HASH_JOIN:
                hash_join = true;
                break;
              case JoinedTable::MERGE_JOIN:
                merge_join = true;
                break;
              default:
                break;
            }
            fromitem_method_opt_it++;
          }while(fromitem_method_opt_it != fromitem_method_list->end()
                 &&(*fromitem_method_opt_it)->previous_join);
          if (semi_join)
          {
            join_method = JoinedTable::SEMI_JOIN;
          }
          else if(!merge_join && hash_join)
          {
            join_method = JoinedTable::HASH_JOIN;
          }
          else if(bloomfilter_join)
          {
            join_method = JoinedTable::BLOOMFILTER_JOIN;
          }
          YYSYS_LOG(DEBUG, "optimizer's best join_method of fromItems is %d", join_method);
          switch (join_method)
          {
            case JoinedTable::SEMI_JOIN:
              opt_join_operator = JoinedTable::SEMI_JOIN;
              CREATE_PHY_OPERRATOR(semi_join_op, ObSemiJoin, physical_plan, err_stat);
              if (OB_SUCCESS == ret)
              {
                semi_join_op->set_join_type(join_type);
              }
              break;
            case JoinedTable::BLOOMFILTER_JOIN:
              opt_join_operator = JoinedTable::BLOOMFILTER_JOIN;
              CREATE_PHY_OPERRATOR(bloomfilter_join_op, ObBloomFilterJoin, physical_plan, err_stat);
              if (OB_SUCCESS == ret)
              {
                bloomfilter_join_op->set_join_type(join_type);
              }
              break;
            case JoinedTable::HASH_JOIN:
              opt_join_operator = JoinedTable::HASH_JOIN;
              CREATE_PHY_OPERRATOR(hash_join_single_op, ObHashJoinSingle, physical_plan, err_stat);
              if (OB_SUCCESS == ret)
              {
                hash_join_single_op->set_join_type(join_type);
              }
              break;
            case JoinedTable::MERGE_JOIN:
              opt_join_operator = JoinedTable::MERGE_JOIN;
              CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
              if (OB_SUCCESS == ret)
              {
                join_op->set_join_type(join_type);
              }
              break;
            default:
              /*won't be here*/
              opt_join_operator = JoinedTable::MERGE_JOIN;
              CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
              if (OB_SUCCESS == ret)
              {
                join_op->set_join_type(join_type);
              }
              break;
          }
        }
      }
      else
      {
        CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
        if (OB_SUCCESS == ret)
        {
          join_op->set_join_type(join_type);
        }
      }
    }
    else
    {
      CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
      if (OB_SUCCESS == ret)//add qianzm [null operator unjudgement bug1181] 20160520
      {
        join_op->set_join_type(join_type);
      }
    }
    if (ret != OB_SUCCESS)
      break;
    ObBitSet<> join_table_bitset;
    ObBitSet<> l_expr_tab_bitset;
    ObBitSet<> r_expr_tab_bitset;
    ObBitSet<>* l_tab_bitset = NULL;
    ObSort *left_sort = NULL;
    ObSort *right_sort = NULL;
    oceanbase::common::ObList<ObSqlRawExpr*>::iterator cnd_it;
    oceanbase::common::ObList<ObSqlRawExpr*>::iterator del_it;
    ObPhyOperator *l_expr_tab_op = NULL;
    ObPhyOperator *r_expr_tab_op = NULL;
    int id = 0; //add wanglei[semi join on expr] 20160511
    bool is_table_expr_same_order = true;
    bool is_table_join_same_order = true;
    ObJoinTypeArray tmp_semi;
    tmp_semi.join_type_ = T_SEMI_JOIN;
    for (cnd_it = remainder_cnd_list.begin(); ret == OB_SUCCESS && cnd_it != remainder_cnd_list.end(); )
    {
      if ((*cnd_it)->get_expr()->is_join_cond() && join_table_bitset.is_empty())
      {
        is_add_other_join_cond = true;
        ObBinaryOpRawExpr *join_cnd = dynamic_cast<ObBinaryOpRawExpr*>((*cnd_it)->get_expr());
        ObBinaryRefRawExpr *lexpr = dynamic_cast<ObBinaryRefRawExpr*>(join_cnd->get_first_op_expr());
        ObBinaryRefRawExpr *rexpr = dynamic_cast<ObBinaryRefRawExpr*>(join_cnd->get_second_op_expr());
        int32_t left_bit_idx = select_stmt->get_table_bit_index(lexpr->get_first_ref_id());
        int32_t right_bit_idx = select_stmt->get_table_bit_index(rexpr->get_first_ref_id());
        // YYSYS_LOG(DEBUG, "left_bit_idx=%d right_bit_idx=%d left_ref_id=%ld right_ref_id=%ld",
        //           left_bit_idx, right_bit_idx,
        //           lexpr->get_first_ref_id(), rexpr->get_first_ref_id());
        CREATE_PHY_OPERRATOR(left_sort, ObSort, physical_plan, err_stat);
        if (ret != OB_SUCCESS)
          break;
        CREATE_PHY_OPERRATOR(right_sort, ObSort, physical_plan, err_stat);
        if (ret != OB_SUCCESS)
          break;

        //bool is_table_expr_same_order = true;
        is_table_expr_same_order = true;
        oceanbase::common::ObList<ObPhyOperator*>::iterator table_it = phy_table_list.begin();
        oceanbase::common::ObList<ObPhyOperator*>::iterator del_table_it;
        oceanbase::common::ObList<ObBitSet<> >::iterator bitset_it = bitset_list.begin();
        oceanbase::common::ObList<ObBitSet<> >::iterator del_bitset_it;
        //ObPhyOperator *l_expr_tab_op = NULL;
        //ObPhyOperator *r_expr_tab_op = NULL;
        // find table scan operator
        bool l_tab_bitset_is_left = false;
        while (ret == OB_SUCCESS
               && (!l_expr_tab_op || !r_expr_tab_op)
               && table_it != phy_table_list.end()
               && bitset_it != bitset_list.end())
        {
          if (bitset_it->has_member(left_bit_idx))
          {
            //YYSYS_LOG(DEBUG, "left table is generated, left_bit_idx=%d", left_bit_idx);
            //YYSYS_LOG(ERROR, "left table is generated, left_bit_idx=%d", left_bit_idx);
            l_expr_tab_op = *table_it;
            l_expr_tab_bitset = *bitset_it;
            if (!l_tab_bitset)
            {
              l_tab_bitset_is_left = true;
              l_tab_bitset = &l_expr_tab_bitset;
            }
            del_table_it = table_it;
            del_bitset_it = bitset_it;
            table_it++;
            bitset_it++;
            if ((ret = phy_table_list.erase(del_table_it)) != OB_SUCCESS)
              break;
            if ((ret = bitset_list.erase(del_bitset_it)) != OB_SUCCESS)
              break;
            if (r_expr_tab_op)
            {
              // right table of join expr has already been found,
              // so table and join expr has different order
              // E.g.  t1 LEFT JOIN t2 ON t2.id=t1.id
              is_table_expr_same_order = false;
            }
          }
          else if (bitset_it->has_member(right_bit_idx))
          {
            // YYSYS_LOG(DEBUG, "right table is generated, right_bit_idx=%d", right_bit_idx);
            //YYSYS_LOG(ERROR, "right table is generated, right_bit_idx=%d", right_bit_idx);
            r_expr_tab_op = *table_it;
            r_expr_tab_bitset = *bitset_it;
            if (!l_tab_bitset)
            {
              l_tab_bitset = &r_expr_tab_bitset;
            }
            del_table_it = table_it;
            del_bitset_it = bitset_it;
            table_it++;
            bitset_it++;
            if ((ret = phy_table_list.erase(del_table_it)) != OB_SUCCESS)
            {
              TRANS_LOG("Generate join plan faild");
              break;
            }
            if ((ret = bitset_list.erase(del_bitset_it)) != OB_SUCCESS)
            {
              TRANS_LOG("Generate join plan faild");
              break;
            }
          }
          else
          {
            table_it++;
            bitset_it++;
          }
        }
        if (ret != OB_SUCCESS)
          break;

        // Two columns must from different table, that expression from one table has been erased in gen_phy_table()
        OB_ASSERT(l_expr_tab_op && r_expr_tab_op);
        oceanbase::common::ObList<int> * from_item_appear_order_list = select_stmt->get_from_item_appear_order_list();
        if(effective_from_opt)
        {
          int left_from_id = -1;
          int right_from_id = -1;
          int from_id = 0;
          oceanbase::common::ObList<ObBitSet<> >::iterator bitset_from_it = bitset_from_list.begin();
          while (ret == OB_SUCCESS
                 && bitset_from_it != bitset_from_list.end())
          {
            if (bitset_from_it->has_member(left_bit_idx))
            {
              left_from_id = from_id;
            }
            else if (bitset_from_it -> has_member(right_bit_idx))
            {
              right_from_id = from_id;
            }
            bitset_from_it++;
            from_id++;
          }
          OB_ASSERT(left_from_id != -1);
          OB_ASSERT(right_from_id != -1);
          oceanbase::common::ObList<int>::iterator from_item_appear_order_list_it = from_item_appear_order_list->begin();
          oceanbase::common::ObList<int>::iterator from_item_appear_order_list_it_2 = from_item_appear_order_list->begin();
          from_id = 0;
          while (ret == OB_SUCCESS
                 && from_item_appear_order_list_it != from_item_appear_order_list->end()
                 && from_item_appear_order_list_it_2 != from_item_appear_order_list->end())
          {
            from_item_appear_order_list_it_2++;
            if((left_from_id==(*from_item_appear_order_list_it)) && (right_from_id==(*from_item_appear_order_list_it_2)))
            {
              break;
            }
            else if((right_from_id==(*from_item_appear_order_list_it)) && (left_from_id==(*from_item_appear_order_list_it_2)))
            {
              is_table_join_same_order = false;
              break;
            }
            from_item_appear_order_list_it++;
            from_item_appear_order_list_it++;
            from_item_appear_order_list_it_2++;
            from_id++;
            from_id++;
          }
          if(is_table_join_same_order)
          {
            if ((ret = left_sort->set_child(0, *l_expr_tab_op)) != OB_SUCCESS
                || (ret = right_sort->set_child(0, *r_expr_tab_op)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of join plan faild");
              break;
            }
            if (!l_tab_bitset_is_left)
            {
              l_tab_bitset = &l_expr_tab_bitset;
            }
            is_table_expr_same_order = true;
          }
          else
          {
            if ((ret = left_sort->set_child(0, *r_expr_tab_op)) != OB_SUCCESS
                || (ret = right_sort->set_child(0, *l_expr_tab_op)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of join plan faild");
              break;
            }
            is_table_expr_same_order = false;
            if(l_tab_bitset_is_left)
            {
              l_tab_bitset = &r_expr_tab_bitset;
            }
          }
        }
        else
        {
          if (is_table_expr_same_order)
          {
            if ((ret = left_sort->set_child(0, *l_expr_tab_op)) != OB_SUCCESS
                || (ret = right_sort->set_child(0, *r_expr_tab_op)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of join plan faild");
              break;
            }
          }
          else
          {
            if ((ret = left_sort->set_child(0, *r_expr_tab_op)) != OB_SUCCESS
                || (ret = right_sort->set_child(0, *l_expr_tab_op)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of join plan faild");
              break;
            }
          }
        }
        if(select_stmt->get_query_hint().join_array_.size()>index_)
        {
          ObJoinTypeArray tmp = select_stmt->get_query_hint().join_array_.at(index_);
          switch (tmp.join_type_) {
            case T_BLOOMFILTER_JOIN:
            {
              if(join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN)
              {
                if ((ret = add_bloomfilter_join_expr(
                       logical_plan,
                       physical_plan,
                       *bloomfilter_join_op,
                       *left_sort,
                       *right_sort,
                       *(*cnd_it),
                       is_table_expr_same_order)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add condition of join plan faild");
                  break;
                }
              }
              else if ((ret = add_merge_join_expr(
                          logical_plan,
                          physical_plan,
                          *join_op,
                          *left_sort,
                          *right_sort,
                          *(*cnd_it),
                          is_table_expr_same_order)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
              }
            }
              break;
            case T_SEMI_JOIN:
            case T_SEMI_BTW_JOIN:
            {
              if(join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN)
              {
                if (!optimizer_open)
                {
                  if ((ret = add_semi_join_expr(
                         logical_plan,
                         physical_plan,
                         *semi_join_op,
                         *left_sort,
                         *right_sort,
                         *(*cnd_it),
                         is_table_expr_same_order,
                         remainder_cnd_list,
                         is_add_other_join_cond,
                         join_type,
                         select_stmt,
                         id++,
                         tmp)) != OB_SUCCESS)
                  {
                    TRANS_LOG("Add condition of join plan faild");
                    break;
                  }
                }
                else if((ret = add_semi_join_expr_V2(
                           logical_plan,
                           physical_plan,
                           *semi_join_op,
                           *left_sort,
                           *right_sort,
                           *(*cnd_it),
                           is_table_expr_same_order,
                           remainder_cnd_list,
                           is_add_other_join_cond,
                           join_type,
                           select_stmt,
                           id++,
                           tmp)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add condition of join plan faild");
                  break;
                }
              }
              else if ((ret = add_merge_join_expr(
                          logical_plan,
                          physical_plan,
                          *join_op,
                          *left_sort,
                          *right_sort,
                          *(*cnd_it),
                          is_table_expr_same_order)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
              }
            }
              break;
            case T_HASH_JOIN_SINGLE:
            {
              if(join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN || join_type == ObJoin::FULL_OUTER_JOIN)
              {
                if((ret = add_hash_join_single_expr(
                      logical_plan,
                      physical_plan,
                      *hash_join_single_op,
                      *(*cnd_it),
                      is_table_expr_same_order)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add condition of join plan faild");
                  break;
                }
              }
              else if ((ret = add_merge_join_expr(
                          logical_plan,
                          physical_plan,
                          *join_op,
                          *left_sort,
                          *right_sort,
                          *(*cnd_it),
                          is_table_expr_same_order)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
              }
            }
              break;

            default:
            {
              if ((ret = add_merge_join_expr(
                     logical_plan,
                     physical_plan,
                     *join_op,
                     *left_sort,
                     *right_sort,
                     *(*cnd_it),
                     is_table_expr_same_order)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
              }
            }
              break;
          }
        }
        else if(effective_opt)
        {
          switch (opt_join_operator)
          {
            case JoinedTable::SEMI_JOIN:
              if(!optimizer_open)
              {
                if ((ret = add_semi_join_expr(
                       logical_plan,
                       physical_plan,
                       *semi_join_op,
                       *left_sort,
                       *right_sort,
                       *(*cnd_it),
                       is_table_expr_same_order,
                       remainder_cnd_list,
                       is_add_other_join_cond,
                       join_type,
                       select_stmt,
                       id++,
                       tmp_semi)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add condition of join plan faild");
                  break;
                }
              }
              else if ((ret = add_semi_join_expr_V2(
                          logical_plan,
                          physical_plan,
                          *semi_join_op,
                          *left_sort,
                          *right_sort,
                          *(*cnd_it),
                          is_table_expr_same_order,
                          remainder_cnd_list,
                          is_add_other_join_cond,
                          join_type,
                          select_stmt,
                          id++,
                          tmp_semi)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
                break;
              }
              break;
            case JoinedTable::BLOOMFILTER_JOIN:
              if ((ret = add_bloomfilter_join_expr(
                     logical_plan,
                     physical_plan,
                     *bloomfilter_join_op,
                     *left_sort,
                     *right_sort,
                     *(*cnd_it),
                     is_table_expr_same_order)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
                break;
              }
              break;
            case JoinedTable::MERGE_JOIN:
              if ((ret = add_merge_join_expr(
                     logical_plan,
                     physical_plan,
                     *join_op,
                     *left_sort,
                     *right_sort,
                     *(*cnd_it),
                     is_table_expr_same_order)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
              }
              break;
            case JoinedTable::HASH_JOIN:
              if ((ret = add_hash_join_single_expr(
                     logical_plan,
                     physical_plan,
                     *hash_join_single_op,
                     *(*cnd_it),
                     is_table_expr_same_order)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
                break;
              }
              break;
            default:
              if ((ret = add_merge_join_expr(
                     logical_plan,
                     physical_plan,
                     *join_op,
                     *left_sort,
                     *right_sort,
                     *(*cnd_it),
                     is_table_expr_same_order)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
              }
              break;
          }
        }
        else
        {
          //CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
          //join_op->set_join_type(join_type);
          // add equal join condition to merge join
          if ((ret = add_merge_join_expr(
                 logical_plan,
                 physical_plan,
                 *join_op,
                 *left_sort,
                 *right_sort,
                 *(*cnd_it),
                 is_table_expr_same_order)) != OB_SUCCESS)
          {
            TRANS_LOG("Add condition of join plan faild");
            break;
          }
        }
        join_table_bitset.add_members(l_expr_tab_bitset);
        join_table_bitset.add_members(r_expr_tab_bitset);

        del_it = cnd_it;
        cnd_it++;
        if (!outer_join_scope && (ret = remainder_cnd_list.erase(del_it)) != OB_SUCCESS)
        {
          TRANS_LOG("Generate join plan faild");
          break;
        }
      }
      else if ((*cnd_it)->get_expr()->is_join_cond()
               && (*cnd_it)->get_tables_set().is_subset(join_table_bitset))
      {
        is_add_other_join_cond = false;
        same_join_method++;
        ObBinaryOpRawExpr *join_cnd = dynamic_cast<ObBinaryOpRawExpr*>((*cnd_it)->get_expr());
        ObBinaryRefRawExpr *expr1 = dynamic_cast<ObBinaryRefRawExpr*>(join_cnd->get_first_op_expr());
        int32_t bit_idx1 = select_stmt->get_table_bit_index(expr1->get_first_ref_id());
        bool is_table_expr_same_order = true;
        OB_ASSERT(l_tab_bitset);
        if (!(l_tab_bitset->has_member(bit_idx1)))
        {
          is_table_expr_same_order = false;
        }
        if(select_stmt->get_query_hint().join_array_.size()>index_ )
        {
          ObJoinTypeArray tmp = select_stmt->get_query_hint().join_array_.at(index_);
          if(tmp.join_type_ == T_BLOOMFILTER_JOIN&&(join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN))
          {
            //CREATE_PHY_OPERRATOR(bloomfilter_join_op, ObBloomFilterJoin, physical_plan, err_stat);
            //bloomfilter_join_op->set_join_type(join_type);
            if ((ret = add_bloomfilter_join_expr(
                   logical_plan,
                   physical_plan,
                   *bloomfilter_join_op,
                   *left_sort,
                   *right_sort,
                   *(*cnd_it),
                   is_table_expr_same_order)) != OB_SUCCESS)
            {
              TRANS_LOG("Add condition of join plan faild");
              break;
            }
          }
          else  if(tmp.join_type_ == T_SEMI_JOIN && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN))
          {
            if(!optimizer_open)
            {
              if ((ret = add_semi_join_expr(
                     logical_plan,
                     physical_plan,
                     *semi_join_op,
                     *left_sort,
                     *right_sort,
                     *(*cnd_it),
                     is_table_expr_same_order,
                     remainder_cnd_list,
                     is_add_other_join_cond,
                     join_type,
                     select_stmt,
                     id++,
                     tmp)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
                break;
              }
            }
            else if((ret = add_semi_join_expr_V2(
                       logical_plan,
                       physical_plan,
                       *semi_join_op,
                       *left_sort,
                       *right_sort,
                       *(*cnd_it),
                       is_table_expr_same_order,
                       remainder_cnd_list,is_add_other_join_cond,join_type,select_stmt,id++,tmp)) != OB_SUCCESS)
            {
              TRANS_LOG("Add condition of join plan faild");
              break;
            }
          }
          else  if(tmp.join_type_ == T_SEMI_BTW_JOIN && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN))
          {
            if(!optimizer_open)
            {
              if ((ret = add_semi_join_expr(
                     logical_plan,
                     physical_plan,
                     *semi_join_op,
                     *left_sort,
                     *right_sort,
                     *(*cnd_it),
                     is_table_expr_same_order,
                     remainder_cnd_list,is_add_other_join_cond,join_type,select_stmt,id++,tmp)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
                break;
              }
            }
            else if((ret = add_semi_join_expr_V2(
                       logical_plan,
                       physical_plan,
                       *semi_join_op,
                       *left_sort,
                       *right_sort,
                       *(*cnd_it),
                       is_table_expr_same_order,
                       remainder_cnd_list,is_add_other_join_cond,join_type,select_stmt,id++,tmp)) != OB_SUCCESS)
            {
              TRANS_LOG("Add condition of join plan faild");
              break;
            }
          }
          else if (tmp.join_type_ == T_HASH_JOIN_SINGLE && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN || join_type == ObJoin::FULL_OUTER_JOIN))
          {
            if ((ret = add_hash_join_single_expr(
                   logical_plan,
                   physical_plan,
                   *hash_join_single_op,
                   *(*cnd_it),
                   is_table_expr_same_order)) != OB_SUCCESS)
            {
              TRANS_LOG("Add condition of join plan faild");
              break;
            }
          }
          else
          {
            //CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
            //join_op->set_join_type(join_type);
            // add equal join condition to merge join
            if ((ret = add_merge_join_expr(
                   logical_plan,
                   physical_plan,
                   *join_op,
                   *left_sort,
                   *right_sort,
                   *(*cnd_it),
                   is_table_expr_same_order)) != OB_SUCCESS)
            {
              TRANS_LOG("Add condition of join plan faild");
              break;
            }
          }
        }
        else if (effective_opt)
        {
          switch (opt_join_operator)
          {
            case JoinedTable::BLOOMFILTER_JOIN:
              if ((ret = add_bloomfilter_join_expr(
                     logical_plan,
                     physical_plan,
                     *bloomfilter_join_op,
                     *left_sort,
                     *right_sort,
                     *(*cnd_it),
                     is_table_expr_same_order)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
              }
              break;

            case JoinedTable::SEMI_JOIN:
              if(!optimizer_open)
              {
                if ((ret = add_semi_join_expr(
                       logical_plan,
                       physical_plan,
                       *semi_join_op,
                       *left_sort,
                       *right_sort,
                       *(*cnd_it),
                       is_table_expr_same_order,
                       remainder_cnd_list,is_add_other_join_cond,join_type,
                       select_stmt,id++,tmp_semi)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add condition of join plan faild");
                }
              }
              else if((ret = add_semi_join_expr_V2(
                         logical_plan,
                         physical_plan,
                         *semi_join_op,
                         *left_sort,
                         *right_sort,
                         *(*cnd_it),
                         is_table_expr_same_order,
                         remainder_cnd_list,is_add_other_join_cond,join_type,
                         select_stmt,id++,tmp_semi)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
              }
              break;

            case JoinedTable::MERGE_JOIN:
              if ((ret = add_merge_join_expr(
                     logical_plan,
                     physical_plan,
                     *join_op,
                     *left_sort,
                     *right_sort,
                     *(*cnd_it),
                     is_table_expr_same_order)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
              }
              break;


            case JoinedTable::HASH_JOIN:
              if((ret = add_hash_join_single_expr(
                    logical_plan,
                    physical_plan,
                    *hash_join_single_op,
                    *(*cnd_it),
                    is_table_expr_same_order)) != OB_SUCCESS)
              {

                TRANS_LOG("Add condition of join plan faild");

              }
              break;


            default:
              if ((ret = add_merge_join_expr(
                     logical_plan,
                     physical_plan,
                     *join_op,
                     *left_sort,
                     *right_sort,
                     *(*cnd_it),
                     is_table_expr_same_order)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
              }
              break;
          }
        }
        else
        {
          //CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
          //join_op->set_join_type(join_type);
          // add equal join condition to merge join
          if ((ret = add_merge_join_expr(
                 logical_plan,
                 physical_plan,
                 *join_op,
                 *left_sort,
                 *right_sort,
                 *(*cnd_it),
                 is_table_expr_same_order)) != OB_SUCCESS)
          {
            TRANS_LOG("Add condition of join plan faild");
            break;
          }
        }
        del_it = cnd_it;
        cnd_it++;
        if (ret != OB_SUCCESS)
        {
          TRANS_LOG("Generate join plan faild");
          break;
        }
        else
          if (!outer_join_scope && (ret = remainder_cnd_list.erase(del_it)) != OB_SUCCESS)
          {
            TRANS_LOG("Generate join plan faild");
            break;
          }
      }
      else if ((*cnd_it)->get_tables_set().is_subset(join_table_bitset)
               && !((*cnd_it)->is_contain_alias()
                    && (*cnd_it)->get_tables_set().overlap(l_expr_tab_bitset)
                    && (*cnd_it)->get_tables_set().overlap(r_expr_tab_bitset)))
      {
        ObSqlExpression join_other_cnd;
        if(select_stmt->get_query_hint().join_array_.size()>index_)
        {
          ObJoinTypeArray tmp = select_stmt->get_query_hint().join_array_.at(index_);
          if(tmp.join_type_ == T_BLOOMFILTER_JOIN&&(join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN))
          {
            if ((ret = ((*cnd_it)->fill_sql_expression(
                          join_other_cnd,
                          this,
                          logical_plan,
                          physical_plan))) != OB_SUCCESS
                || (ret = bloomfilter_join_op->add_other_join_condition(join_other_cnd)) != OB_SUCCESS)
            {
              TRANS_LOG("Add condition of join plan faild");
              break;
            }
          }
          else  if((tmp.join_type_ == T_SEMI_JOIN||tmp.join_type_ == T_SEMI_BTW_JOIN )
                   && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN))
          {
            if ((ret = ((*cnd_it)->fill_sql_expression(
                          join_other_cnd,
                          this,
                          logical_plan,
                          physical_plan))) != OB_SUCCESS
                || (ret = semi_join_op->add_other_join_condition(join_other_cnd)) != OB_SUCCESS)
            {
              TRANS_LOG("Add condition of join plan faild");
              break;
            }
          }
          else if (tmp.join_type_ == T_HASH_JOIN_SINGLE && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN || join_type == ObJoin::FULL_OUTER_JOIN))
          {
            if ((ret = ((*cnd_it)->fill_sql_expression(
                          join_other_cnd,
                          this,
                          logical_plan,
                          physical_plan))) != OB_SUCCESS
                || (ret = hash_join_single_op->add_other_join_condition(join_other_cnd)) != OB_SUCCESS)
            {
              TRANS_LOG("Add condition of join plan faild");
              break;
            }
          }
          else
          {
            if ((ret = ((*cnd_it)->fill_sql_expression(
                          join_other_cnd,
                          this,
                          logical_plan,
                          physical_plan))) != OB_SUCCESS
                || (ret = join_op->add_other_join_condition(join_other_cnd)) != OB_SUCCESS)
            {
              TRANS_LOG("Add condition of join plan faild");
              break;
            }
          }
        }
        else if(effective_opt)
        {
          switch (opt_join_operator)
          {
            case JoinedTable::BLOOMFILTER_JOIN:
              if ((ret = ((*cnd_it)->fill_sql_expression(
                            join_other_cnd,
                            this,
                            logical_plan,
                            physical_plan))) != OB_SUCCESS
                  || (ret = bloomfilter_join_op->add_other_join_condition(join_other_cnd)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
                break;
              }
              break;
            case JoinedTable::SEMI_JOIN:
              if ((ret = ((*cnd_it)->fill_sql_expression(
                            join_other_cnd,
                            this,
                            logical_plan,
                            physical_plan))) != OB_SUCCESS
                  || (ret = semi_join_op->add_other_join_condition(join_other_cnd)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
                break;
              }
              break;
            case JoinedTable::MERGE_JOIN:
              if ((ret = ((*cnd_it)->fill_sql_expression(
                            join_other_cnd,
                            this,
                            logical_plan,
                            physical_plan))) != OB_SUCCESS
                  || (ret = join_op->add_other_join_condition(join_other_cnd)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
                break;
              }
              break;
            case JoinedTable::HASH_JOIN:
              if ((ret = ((*cnd_it)->fill_sql_expression(
                            join_other_cnd,
                            this,
                            logical_plan,
                            physical_plan))) != OB_SUCCESS
                  || (ret = hash_join_single_op->add_other_join_condition(join_other_cnd)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
                break;
              }
              break;
            default:
              /*won't be here*/
              if ((ret = ((*cnd_it)->fill_sql_expression(
                            join_other_cnd,
                            this,
                            logical_plan,
                            physical_plan))) != OB_SUCCESS
                  || (ret = join_op->add_other_join_condition(join_other_cnd)) != OB_SUCCESS)
              {
                TRANS_LOG("Add condition of join plan faild");
                break;
              }
              break;
          }
        }
        else
        {
          if ((ret = ((*cnd_it)->fill_sql_expression(
                        join_other_cnd,
                        this,
                        logical_plan,
                        physical_plan))) != OB_SUCCESS
              || (ret = join_op->add_other_join_condition(join_other_cnd)) != OB_SUCCESS)
          {
            TRANS_LOG("Add condition of join plan faild");
            break;
          }
        }
        del_it = cnd_it;
        cnd_it++;
        if (ret != OB_SUCCESS)
        {
          TRANS_LOG("Generate join plan faild");
          break;
        }
        else
          if (!outer_join_scope && (ret = remainder_cnd_list.erase(del_it)) != OB_SUCCESS)
          {
            TRANS_LOG("Generate join plan faild");
            break;
          }
      }
      else
      {
        cnd_it++;
      }
    }

    if (ret == OB_SUCCESS)
    {
      if (!join_table_bitset.is_empty())
      {
        if(select_stmt->get_query_hint().join_array_.size()>index_)
        {
          ObJoinTypeArray tmp = select_stmt->get_query_hint().join_array_.at(index_);
          if(tmp.join_type_ == T_BLOOMFILTER_JOIN&&(join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN))
          {
            if ((ret = bloomfilter_join_op->set_child(0, *left_sort)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of join plan faild");
              break;
            }
            if ((ret = bloomfilter_join_op->set_child(1, *right_sort)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of join plan faild");
              break;
            }
          }
          else  if((tmp.join_type_ == T_SEMI_JOIN ||tmp.join_type_ == T_SEMI_BTW_JOIN )
                   && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN))
          {
            // find a join condition, a merge join will be used here
            OB_ASSERT(left_sort != NULL);
            OB_ASSERT(right_sort != NULL);
            if ((ret = semi_join_op->set_child(0, *left_sort)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of join plan faild");
              break;
            }
            if ((ret = semi_join_op->set_child(1, *right_sort)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of join plan faild");
              break;
            }
          }
          else if (tmp.join_type_ == T_HASH_JOIN_SINGLE && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN || join_type == ObJoin::FULL_OUTER_JOIN))
          {
            if (is_table_expr_same_order)
            {
              if ((ret = hash_join_single_op->set_child(0, *l_expr_tab_op)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
              if ((ret = hash_join_single_op->set_child(1, *r_expr_tab_op)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
            }
            else
            {
              if ((ret = hash_join_single_op->set_child(0, *r_expr_tab_op)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
              if ((ret = hash_join_single_op->set_child(1, *l_expr_tab_op)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
            }
          }
          else
          {
            // find a join condition, a merge join will be used here
            OB_ASSERT(left_sort != NULL);
            OB_ASSERT(right_sort != NULL);
            if ((ret = join_op->set_child(0, *left_sort)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of join plan faild");
              break;
            }
            if ((ret = join_op->set_child(1, *right_sort)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of join plan faild");
              break;
            }
          }
        }
        else if (effective_opt)
        {
          switch(opt_join_operator)
          {
            case JoinedTable::SEMI_JOIN:
              OB_ASSERT(left_sort != NULL);
              OB_ASSERT(right_sort != NULL);
              if ((ret = semi_join_op->set_child(0, *left_sort)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
              if ((ret = semi_join_op->set_child(1, *right_sort)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
              break;
            case JoinedTable::BLOOMFILTER_JOIN:
              if ((ret = bloomfilter_join_op->set_child(0, *left_sort)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
              if ((ret = bloomfilter_join_op->set_child(1, *right_sort)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
              break;
            case JoinedTable::MERGE_JOIN:
              OB_ASSERT(left_sort != NULL);
              OB_ASSERT(right_sort != NULL);
              if ((ret = join_op->set_child(0, *left_sort)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
              if ((ret = join_op->set_child(1, *right_sort)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
              break;
            case JoinedTable::HASH_JOIN:
              if (is_table_expr_same_order)
              {
                if ((ret = hash_join_single_op->set_child(0, *l_expr_tab_op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
                if ((ret = hash_join_single_op->set_child(1, *r_expr_tab_op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
              }
              else
              {
                if ((ret = hash_join_single_op->set_child(0, *r_expr_tab_op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
                if ((ret = hash_join_single_op->set_child(1, *l_expr_tab_op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
              }
              break;
            default:
              /*won't be here*/
              OB_ASSERT(left_sort != NULL);
              OB_ASSERT(right_sort != NULL);
              if ((ret = join_op->set_child(0, *left_sort)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
              if ((ret = join_op->set_child(1, *right_sort)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
              break;
          }
        }
        else
        {
          // find a join condition, a merge join will be used here
          OB_ASSERT(left_sort != NULL);
          OB_ASSERT(right_sort != NULL);
          if ((ret = join_op->set_child(0, *left_sort)) != OB_SUCCESS)
          {
            TRANS_LOG("Add child of join plan faild");
            break;
          }
          if ((ret = join_op->set_child(1, *right_sort)) != OB_SUCCESS)
          {
            TRANS_LOG("Add child of join plan faild");
            break;
          }
        }
      }
      else
      {
        // Can not find a join condition, a product join will be used here
        // FIX me, should be ObJoin, it will be fixed when Join is supported
        //ObPhyOperator *op = NULL;
        if(select_stmt->get_query_hint().join_array_.size()>index_)
        {
          ObPhyOperator *op = NULL;
          ObJoinTypeArray tmp = select_stmt->get_query_hint().join_array_.at(index_);
          if(tmp.join_type_ == T_BLOOMFILTER_JOIN&&(join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN))
          {
            CREATE_PHY_OPERRATOR(bloomfilter_join_op, ObBloomFilterJoin, physical_plan, err_stat);
            if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
            {
            }
            else
            {
              bloomfilter_join_op->set_join_type(join_type);
              if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
              {
                TRANS_LOG("Generate join plan faild");
                break;
              }
              if ((ret = bloomfilter_join_op->set_child(0, *op)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
              if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
              {
                TRANS_LOG("Generate join plan faild");
                break;
              }
              if ((ret = bloomfilter_join_op->set_child(1, *op)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
            }
          }
          else  if((tmp.join_type_ == T_SEMI_JOIN ||tmp.join_type_ == T_SEMI_BTW_JOIN )
                   && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN))
          {
            CREATE_PHY_OPERRATOR(semi_join_op, ObSemiJoin, physical_plan, err_stat);
            if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
            {
            }
            else
            {
              semi_join_op->set_join_type(join_type);
              ObPhyOperator *op = NULL;
              //YYSYS_LOG(ERROR, "hushuang 2-2--*op+*op_1");
              if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
              {
                TRANS_LOG("Generate join plan faild");
                break;
              }
              if ((ret = semi_join_op->set_child(0, *op)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
              if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
              {
                TRANS_LOG("Generate join plan faild");
                break;
              }
              if ((ret = semi_join_op->set_child(1, *op)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
            }
          }
          else if(tmp.join_type_ == T_HASH_JOIN_SINGLE && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN || join_type == ObJoin::FULL_OUTER_JOIN))
          {
            CREATE_PHY_OPERRATOR(hash_join_single_op, ObHashJoinSingle, physical_plan, err_stat);
            if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
            {
            }
            else
            {
              hash_join_single_op->set_join_type(join_type);
              if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
              {
                TRANS_LOG("Generate join plan faild");
                break;
              }
              if ((ret = hash_join_single_op->set_child(0, *op)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
              if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
              {
                TRANS_LOG("Generate join plan faild");
                break;
              }
              if ((ret = hash_join_single_op->set_child(1, *op)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
            }
          }
          else
          {
            CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
            if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
            {
            }
            else
            {
              join_op->set_join_type(join_type);
              if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
              {
                TRANS_LOG("Generate join plan faild");
                break;
              }
              if ((ret = join_op->set_child(0, *op)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
              if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
              {
                TRANS_LOG("Generate join plan faild");
                break;
              }
              if ((ret = join_op->set_child(1, *op)) != OB_SUCCESS)
              {
                TRANS_LOG("Add child of join plan faild");
                break;
              }
            }
          }
        }
        else if (effective_opt)
        {
          ObPhyOperator *op = NULL;
          switch (opt_join_operator)
          {
            case JoinedTable::SEMI_JOIN:
              CREATE_PHY_OPERRATOR(semi_join_op, ObSemiJoin, physical_plan, err_stat);
              if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
              {
              }
              else
              {
                semi_join_op->set_join_type(join_type);
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = semi_join_op->set_child(0, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = semi_join_op->set_child(1, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
              }
              break;
            case JoinedTable::BLOOMFILTER_JOIN:
              CREATE_PHY_OPERRATOR(bloomfilter_join_op, ObBloomFilterJoin, physical_plan, err_stat);
              if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
              {
              }
              else
              {
                bloomfilter_join_op->set_join_type(join_type);
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = bloomfilter_join_op->set_child(0, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = bloomfilter_join_op->set_child(1, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
              }
              break;
            case JoinedTable::MERGE_JOIN:
              CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
              if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
              {
              }
              else
              {
                join_op->set_join_type(join_type);
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = join_op->set_child(0, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = join_op->set_child(1, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
              }
              break;
            case JoinedTable::HASH_JOIN:
              CREATE_PHY_OPERRATOR(hash_join_single_op, ObHashJoinSingle, physical_plan, err_stat);
              if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
              {
              }
              else
              {
                hash_join_single_op->set_join_type(join_type);
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = hash_join_single_op->set_child(0, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = hash_join_single_op->set_child(1, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
              }
              break;
            default:
              /*won't be here*/
              CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
              if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
              {
              }
              else
              {
                join_op->set_join_type(join_type);
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = join_op->set_child(0, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = join_op->set_child(1, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
              }
              break;
          }
        }
        else
        {
          CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
          if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
          {
          }
          else
          {
            join_op->set_join_type(join_type);
            ObPhyOperator *op = NULL;
            //YYSYS_LOG(ERROR, "hushuang 2-2--*op+*op_1");
            if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
            {
              TRANS_LOG("Generate join plan faild");
              break;
            }
            if ((ret = join_op->set_child(0, *op)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of join plan faild");
              break;
            }
            if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
            {
              TRANS_LOG("Generate join plan faild");
              break;
            }
            if ((ret = join_op->set_child(1, *op)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of join plan faild");
              break;
            }
          }
        }
        bitset_list.pop_front(l_expr_tab_bitset);
        join_table_bitset.add_members(l_expr_tab_bitset);
        bitset_list.pop_front(r_expr_tab_bitset);
        join_table_bitset.add_members(r_expr_tab_bitset);
      }
    }

    // add other join conditions
    for (cnd_it = remainder_cnd_list.begin(); ret == OB_SUCCESS && cnd_it != remainder_cnd_list.end(); )
    {
      if ((*cnd_it)->is_contain_alias()
          && (*cnd_it)->get_tables_set().overlap(l_expr_tab_bitset)
          && (*cnd_it)->get_tables_set().overlap(r_expr_tab_bitset))
      {
        cnd_it++;
      }
      else if ((*cnd_it)->get_tables_set().is_subset(join_table_bitset))
      {
        ObSqlExpression other_cnd;
        if(select_stmt->get_query_hint().join_array_.size()>index_)
        {
          ObJoinTypeArray tmp = select_stmt->get_query_hint().join_array_.at(index_);
          if(tmp.join_type_ == T_BLOOMFILTER_JOIN&&(join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN))
          {
            if ((ret = (*cnd_it)->fill_sql_expression(
                   other_cnd,
                   this,
                   logical_plan,
                   physical_plan)) != OB_SUCCESS
                || (ret = bloomfilter_join_op->add_other_join_condition(other_cnd)) != OB_SUCCESS)
            {
              TRANS_LOG("Add condition of join plan faild");
              break;
            }
          }
          else if((tmp.join_type_ == T_SEMI_JOIN ||tmp.join_type_ == T_SEMI_BTW_JOIN ) && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN))
          {
            // YYSYS_LOG(ERROR,"wl add other join conditions");
            if ((ret = (*cnd_it)->fill_sql_expression(
                   other_cnd,
                   this,
                   logical_plan,
                   physical_plan)) != OB_SUCCESS
                || (ret = semi_join_op->add_other_join_condition(other_cnd)) != OB_SUCCESS)
            {
              TRANS_LOG("Add condition of join plan faild");
              break;
            }
          }
          else if (tmp.join_type_ == T_HASH_JOIN_SINGLE && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN || join_type == ObJoin::FULL_OUTER_JOIN))
          {
            if ((ret = (*cnd_it)->fill_sql_expression(
                   other_cnd,
                   this,
                   logical_plan,
                   physical_plan)) != OB_SUCCESS
                || (ret = hash_join_single_op->add_other_join_condition(other_cnd)) != OB_SUCCESS)
            {
              TRANS_LOG("Add condition of join plan faild");
              break;
            }
          }
          else
          {
            if ((ret = (*cnd_it)->fill_sql_expression(
                   other_cnd,
                   this,
                   logical_plan,
                   physical_plan)) != OB_SUCCESS
                || (ret = join_op->add_other_join_condition(other_cnd)) != OB_SUCCESS)
            {
              TRANS_LOG("Add condition of join plan faild");
              break;
            }
          }
        }
        else if (effective_opt)
        {
          ObPhyOperator *op = NULL;
          switch (opt_join_operator)
          {
            case JoinedTable::SEMI_JOIN:
              CREATE_PHY_OPERRATOR(semi_join_op, ObSemiJoin, physical_plan, err_stat);
              if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
              {
              }
              else
              {
                semi_join_op->set_join_type(join_type);
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = semi_join_op->set_child(0, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = semi_join_op->set_child(1, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
              }
              break;
            case JoinedTable::BLOOMFILTER_JOIN:
              CREATE_PHY_OPERRATOR(bloomfilter_join_op, ObBloomFilterJoin, physical_plan, err_stat);
              if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
              {
              }
              else
              {
                bloomfilter_join_op->set_join_type(join_type);
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = bloomfilter_join_op->set_child(0, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = bloomfilter_join_op->set_child(1, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
              }
              break;
            case JoinedTable::MERGE_JOIN:
              CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
              if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
              {
              }
              else
              {
                join_op->set_join_type(join_type);
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = join_op->set_child(0, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = join_op->set_child(1, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
              }
              break;
            case JoinedTable::HASH_JOIN:
              CREATE_PHY_OPERRATOR(hash_join_single_op, ObHashJoinSingle, physical_plan, err_stat);
              if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
              {
              }
              else
              {
                hash_join_single_op->set_join_type(join_type);
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = hash_join_single_op->set_child(0, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = hash_join_single_op->set_child(1, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
              }
              break;
            default:
              /*won't be here*/
              CREATE_PHY_OPERRATOR(join_op, ObMergeJoin, physical_plan, err_stat);
              if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
              {
              }
              else
              {
                join_op->set_join_type(join_type);
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = join_op->set_child(0, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
                if ((ret = phy_table_list.pop_front(op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate join plan faild");
                  break;
                }
                if ((ret = join_op->set_child(1, *op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Add child of join plan faild");
                  break;
                }
              }
              break;
          }
        }
        else
        {
          if ((ret = (*cnd_it)->fill_sql_expression(
                 other_cnd,
                 this,
                 logical_plan,
                 physical_plan)) != OB_SUCCESS
              || (ret = join_op->add_other_join_condition(other_cnd)) != OB_SUCCESS)
          {
            TRANS_LOG("Add condition of join plan faild");
            break;
          }
        }
        del_it = cnd_it;
        cnd_it++;
        if (!outer_join_scope && (ret = remainder_cnd_list.erase(del_it)) != OB_SUCCESS)
        {
          TRANS_LOG("Generate join plan faild");
          break;
        }
      }
      else
      {
        cnd_it++;
      }
    }

    // columnlize the alias expression

    oceanbase::common::ObList<ObSqlRawExpr*>::iterator alias_it;
    for (alias_it = none_columnlize_alias.begin(); ret == OB_SUCCESS && alias_it != none_columnlize_alias.end(); )
    {
      if ((*alias_it)->is_columnlized())
      {
        common::ObList<ObSqlRawExpr*>::iterator del_alias = alias_it;
        alias_it++;
        if ((ret = none_columnlize_alias.erase(del_alias)) != OB_SUCCESS)
        {
          TRANS_LOG("Generate join plan faild");
          break;
        }
      }
      else if ((*alias_it)->get_tables_set().is_subset(join_table_bitset))
      {
        (*alias_it)->set_columnlized(true);
        if (project_op == NULL)
        {
          CREATE_PHY_OPERRATOR(project_op, ObAddProject, physical_plan, err_stat);
          if (ret != OB_SUCCESS)
            break;
          if(select_stmt->get_query_hint().join_array_.size()>index_ )
          {
            ObJoinTypeArray tmp = select_stmt->get_query_hint().join_array_.at(index_);
            if(tmp.join_type_ == T_BLOOMFILTER_JOIN&&(join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN))
            {
              if ((ret = project_op->set_child(0, *bloomfilter_join_op)) != OB_SUCCESS)
              {
                TRANS_LOG("Generate project operator on join plan faild");
                break;
              }
            }
            else  if((tmp.join_type_ == T_SEMI_JOIN ||tmp.join_type_ == T_SEMI_BTW_JOIN )
                     && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN))
            {
              if ((ret = project_op->set_child(0, *semi_join_op)) != OB_SUCCESS)
              {
                TRANS_LOG("Generate project operator on join plan faild");
                break;
              }
            }
            else if (tmp.join_type_ == T_HASH_JOIN_SINGLE && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN || join_type == ObJoin::FULL_OUTER_JOIN))
            {
              if ((ret = project_op->set_child(0, *hash_join_single_op)) != OB_SUCCESS)
              {
                TRANS_LOG("Generate project operator on join plan faild");
                break;
              }
            }
            else
            {
              if ((ret = project_op->set_child(0, *join_op)) != OB_SUCCESS)
              {
                TRANS_LOG("Generate project operator on join plan faild");
                break;
              }
            }
          }
          else if (effective_opt)
          {
            switch (opt_join_operator)
            {
              case JoinedTable::SEMI_JOIN:
                if((ret = project_op->set_child(0, *semi_join_op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate project operator on join plan faild");
                  break;
                }
                break;
              case JoinedTable::BLOOMFILTER_JOIN:
                if((ret = project_op->set_child(0, *bloomfilter_join_op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate project operator on join plan faild");
                  break;
                }
                break;
              case JoinedTable::MERGE_JOIN:
                if((ret = project_op->set_child(0, *join_op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate project operator on join plan faild");
                  break;
                }
                break;
              case JoinedTable::HASH_JOIN:
                if((ret = project_op->set_child(0, *hash_join_single_op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate project operator on join plan faild");
                  break;
                }
                break;
              default:
                /*won't be here*/
                if((ret = project_op->set_child(0, *join_op)) != OB_SUCCESS)
                {
                  TRANS_LOG("Generate project operator on join plan faild");
                  break;
                }
                break;
            }
          }
          else
          {
            if ((ret = project_op->set_child(0, *join_op)) != OB_SUCCESS)
            {
              TRANS_LOG("Generate project operator on join plan faild");
              break;
            }
          }
        }
        ObSqlExpression alias_expr;
        if ((ret = (*alias_it)->fill_sql_expression(
               alias_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS
            || (ret = project_op->add_output_column(alias_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add project column on join plan faild");
          break;
        }
        common::ObList<ObSqlRawExpr*>::iterator del_alias = alias_it;
        alias_it++;
        if ((ret = none_columnlize_alias.erase(del_alias)) != OB_SUCCESS)
        {
          TRANS_LOG("Generate join plan faild");
          break;
        }

      }
      else
      {
        alias_it++;
      }

    }

    if (ret == OB_SUCCESS)
    {
      ObPhyOperator *result_op = NULL;
      if (project_op == NULL)
      {
        if(select_stmt->get_query_hint().join_array_.size()>index_ )
        {
          ObJoinTypeArray tmp = select_stmt->get_query_hint().join_array_.at(index_);
          if(tmp.join_type_ == T_BLOOMFILTER_JOIN&&(join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN))
          {
            result_op = bloomfilter_join_op;
          }
          else  if((tmp.join_type_ == T_SEMI_JOIN ||tmp.join_type_ == T_SEMI_BTW_JOIN )
                   && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN))
          {
            result_op = semi_join_op ;
          }
          else if(tmp.join_type_ == T_HASH_JOIN_SINGLE && (join_type == ObJoin::INNER_JOIN || join_type == ObJoin::LEFT_OUTER_JOIN || join_type == ObJoin::RIGHT_OUTER_JOIN || join_type == ObJoin::FULL_OUTER_JOIN))
          {
            result_op = hash_join_single_op;
          }
          else
          {
            result_op = join_op ;
          }
        }
        else if(effective_opt)
        {
          switch (opt_join_operator)
          {
            case JoinedTable::SEMI_JOIN:
              result_op = semi_join_op;
              break;
            case JoinedTable::BLOOMFILTER_JOIN:
              result_op = bloomfilter_join_op;
              break;
            case JoinedTable::MERGE_JOIN:
              result_op = join_op;
              break;
            case JoinedTable::HASH_JOIN:
              result_op = hash_join_single_op;
              break;
            default:
              /*won't be here*/
              result_op = join_op;
              break;
          }
        }
        else
        {
          result_op = join_op ;
        }
      }

      else
      {
        result_op = project_op;
      }
      if ((ret = phy_table_list.push_front(result_op)) != OB_SUCCESS
          || (ret = bitset_list.push_front(join_table_bitset)) != OB_SUCCESS)
      {
        TRANS_LOG("Generate join plan failed");
        break;
      }
      join_table_bitset.clear();
    }
    index_++;
    effective_opt = false;
  }
  if(index_ == 1)
  {
    select_stmt->get_query_hint().join_array_.remove(0);
  }

  if(ret == OB_SUCCESS && implied_join)
  {
    oceanbase::common::ObList<ObSqlRawExpr*>::iterator cnd_it;
    for (cnd_it = tmp_remainder_cnd_list.begin(); ret == OB_SUCCESS && cnd_it != tmp_remainder_cnd_list.end(); cnd_it++)
    {
      if ((ret = remainder_cnd_list.push_back(*cnd_it)) != OB_SUCCESS)
      {
        YYSYS_LOG(ERROR, "push back join expr filter into remainder_cnd_list fail, ret=%d",ret);
      }
    }
  }
  return ret;
}
//modify:e

int ObTransformer::gen_phy_tables(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObSelectStmt *select_stmt,
    bool& group_agg_pushed_down,
    bool& limit_pushed_down,
    oceanbase::common::ObList<ObPhyOperator*>& phy_table_list,
    oceanbase::common::ObList<ObBitSet<> >& bitset_list,
    oceanbase::common::ObList<ObSqlRawExpr*>& remainder_cnd_list,
    oceanbase::common::ObList<ObSqlRawExpr*>& none_columnlize_alias,
    ObPhyOperator *sequence_op, //add liuzy [sequence select] 20150525:", ObPhyOperator *sequence_op"
    bool optimizer_open
    )
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObPhyOperator *table_op = NULL;
  ObBitSet<> bit_set;

  int32_t num = select_stmt->get_select_item_size();
  for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
  {
    const SelectItem& select_item = select_stmt->get_select_item(i);
    if (select_item.is_real_alias_)
    {
      ObSqlRawExpr *alias_expr = logical_plan->get_expr(select_item.expr_id_);
      if (alias_expr == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Add alias to internal list failed");
        break;
      }
      else if (alias_expr->is_columnlized() == false
               && (ret = none_columnlize_alias.push_back(alias_expr)) != OB_SUCCESS)
      {
        TRANS_LOG("Add alias to internal list failed");
        break;
      }
    }
  }

  int32_t num_table = select_stmt->get_from_item_size();
  // no from clause of from DUAL
  if (ret == OB_SUCCESS && num_table <= 0)
  {
    ObDualTableScan *dual_table_op = NULL;
    if (CREATE_PHY_OPERRATOR(dual_table_op, ObDualTableScan, physical_plan, err_stat) == NULL)
    {
      TRANS_LOG("Generate dual table operator failed, ret=%d", ret);
    }
    if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
    {
    }
    else if ((ret = phy_table_list.push_back(dual_table_op)) != OB_SUCCESS)
    {
      TRANS_LOG("Add table to internal list failed");
    }
    // add empty bit set
    else if ((ret = bitset_list.push_back(bit_set)) != OB_SUCCESS)
    {
      TRANS_LOG("Add bitset to internal list failed");
    }
  }
  for(int32_t i = 0; ret == OB_SUCCESS && i < num_table; i++)
  {
    const FromItem& from_item = select_stmt->get_from_item(i);
    if (from_item.is_joined_ == false)
    {
      /* base-table or temporary table */
      if ((ret = gen_phy_table(
             logical_plan,
             physical_plan,
             err_stat,
             select_stmt,
             from_item.table_id_,
             table_op,
             &group_agg_pushed_down,
             &limit_pushed_down,
             sequence_op,//add liuzy ", sequence_op" [sequence select]20150616
             false,
             optimizer_open
             )) != OB_SUCCESS)
        break;
      bit_set.add_member(select_stmt->get_table_bit_index(from_item.table_id_));
      if (select_stmt->get_table_bit_index(from_item.table_id_) < 0)
      {
        YYSYS_LOG(ERROR, "negative bitmap values,table_id=%ld" ,from_item.table_id_);
      }
    }
    else
    {
      /* Outer Join */
      JoinedTable *joined_table = select_stmt->get_joined_table(from_item.table_id_);
      if (joined_table == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Wrong joined table id '%lu'", from_item.table_id_);
        break;
      }
      OB_ASSERT(joined_table->table_ids_.count() >= 2);
      OB_ASSERT(joined_table->table_ids_.count() - 1 == joined_table->join_types_.count());
      OB_ASSERT(joined_table->join_types_.count() == joined_table->expr_nums_per_join_.count());
      //add liumz, [outer_join_on_where]20151019:b
      bool outer_join_scope = false;
      for (int32_t j = 1; ret == OB_SUCCESS && !outer_join_scope && j < joined_table->table_ids_.count(); j++)
      {
        if(ret == OB_SUCCESS)
        {
          switch (joined_table->join_types_.at(j - 1))
          {
            case JoinedTable::T_FULL:
              outer_join_scope = true;
              break;
            case JoinedTable::T_LEFT:
              outer_join_scope = true;
              break;
            case JoinedTable::T_RIGHT:
              outer_join_scope = true;
              break;
            case JoinedTable::T_INNER:
              break;
            default:
              /* won't be here */
              break;
          }
        }
      }
      //add:e
      if ((ret = gen_phy_table(
             logical_plan,
             physical_plan,
             err_stat,
             select_stmt,
             joined_table->table_ids_.at(0),
             table_op,
             /*add liumz, [outer_join_on_where]20150927:b*/
             NULL,
             NULL,
             NULL,
             outer_join_scope,/*add:e*/
             optimizer_open
             )) != OB_SUCCESS)
      {
        break;
      }
      bit_set.add_member(select_stmt->get_table_bit_index(joined_table->table_ids_.at(0)));
      if (select_stmt->get_table_bit_index(joined_table->table_ids_.at(0)) < 0)
      {
        YYSYS_LOG(ERROR, "negative bitmap values,table_id=%ld" ,joined_table->table_ids_.at(0));
      }

      ObPhyOperator *right_op = NULL;
      ObSqlRawExpr *join_expr = NULL;
      int64_t join_expr_position = 0;
      int64_t join_expr_num = 0;
      for (int32_t j = 1; ret == OB_SUCCESS && j < joined_table->table_ids_.count(); j++)
      {
        if ((ret = gen_phy_table(
               logical_plan,
               physical_plan,
               err_stat,
               select_stmt,
               joined_table->table_ids_.at(j),
               right_op,
               /*add liumz, [outer_join_on_where]20150927:b*/
               NULL,
               NULL,
               NULL,
               outer_join_scope,/*add:e*/
               optimizer_open
               )) != OB_SUCCESS)
        {
          break;
        }
        ObList<ObPhyOperator*>  outer_join_tabs;
        ObList<ObBitSet<> >        outer_join_bitsets;
        ObList<ObSqlRawExpr*>   outer_join_cnds;
        if (OB_SUCCESS != (ret = outer_join_tabs.push_back(table_op))
            || OB_SUCCESS != (ret = outer_join_tabs.push_back(right_op))
            || OB_SUCCESS != (ret = outer_join_bitsets.push_back(bit_set)))
        {
          YYSYS_LOG(WARN, "fail to push op to outer_join tabs. ret=%d", ret);
          break;
        }
        ObBitSet<> right_table_bitset;
        int32_t  right_table_bit_index = select_stmt->get_table_bit_index(joined_table->table_ids_.at(j));
        right_table_bitset.add_member(right_table_bit_index);
        bit_set.add_member(right_table_bit_index);
        if (right_table_bit_index < 0)
        {
          YYSYS_LOG(ERROR, "negative bitmap values,table_id=%ld" ,joined_table->table_ids_.at(j));
        }
        if (OB_SUCCESS != (ret = outer_join_bitsets.push_back(right_table_bitset)))
        {
          YYSYS_LOG(WARN, "fail to push bitset to list. ret=%d", ret);
          break;
        }
        join_expr_num = joined_table->expr_nums_per_join_.at(j - 1);
        for(int64_t join_index = 0; join_index < join_expr_num; ++join_index)
        {
          join_expr = logical_plan->get_expr(joined_table->expr_ids_.at(join_expr_position + join_index));
          if (join_expr == NULL)
          {
            ret = OB_ERR_ILLEGAL_INDEX;
            TRANS_LOG("Add outer join condition faild");
            break;
          }
          else if (OB_SUCCESS != (ret = outer_join_cnds.push_back(join_expr)))
          {
            YYSYS_LOG(WARN, "fail to push bitset to list. ret=%d", ret);
            break;
          }
        }

        if (OB_SUCCESS == ret)
        {
          join_expr_position += join_expr_num;
        }
        else
        {
          break;
        }

        ObJoin::JoinType join_type = ObJoin::INNER_JOIN;
        if(ret == OB_SUCCESS)
        {
          switch (joined_table->join_types_.at(j - 1))
          {
            case JoinedTable::T_FULL:
              join_type = ObJoin::FULL_OUTER_JOIN;
              break;
            case JoinedTable::T_LEFT:
              join_type = ObJoin::LEFT_OUTER_JOIN;
              break;
            case JoinedTable::T_RIGHT:
              join_type = ObJoin::RIGHT_OUTER_JOIN;
              break;
            case JoinedTable::T_INNER:
              join_type = ObJoin::INNER_JOIN;
              break;
              //case JoinedTable::T_SEMI:
              //    join_type = ObJoin::SEMI_JOIN;
              //    break;
              //case JoinedTable::T_SEMI_LEFT:
              //    join_type = ObJoin::LEFT_SEMI_JOIN;
              //    break;
              //case JoinedTable::T_SEMI_RIGHT:
              //    join_type = ObJoin::RIGHT_SEMI_JOIN;
              //    break;
            default:
              /* won't be here */
              join_type = ObJoin::INNER_JOIN;
              break;
          }
        }
        JoinedTable::JoinOperator opt_join_operator = JoinedTable::MERGE_JOIN;
        bool opt_switch = false;
        if(ret == OB_SUCCESS && optimizer_open)
        {
          if (joined_table->optimized_join_operator_.count() >= j)
          {
            opt_switch = true;
            switch (joined_table->optimized_join_operator_.at(j-1))
            {
              case JoinedTable::SEMI_JOIN:
                opt_join_operator = JoinedTable::SEMI_JOIN;
                break;
              case JoinedTable::MERGE_JOIN:
                opt_join_operator = JoinedTable::MERGE_JOIN;
                break;
              case JoinedTable::HASH_JOIN:
                opt_join_operator = JoinedTable::HASH_JOIN;
                break;
              case JoinedTable::BLOOMFILTER_JOIN:
                opt_join_operator = JoinedTable::BLOOMFILTER_JOIN;
                break;
              default:
                /* won't be here */
                opt_join_operator = JoinedTable::MERGE_JOIN;
                break;
            }
          }
        }
        // Now we don't optimize outer join
        // outer_join_cnds is empty, we will do something when optimizing.
        if ((ret = gen_phy_joins(
               logical_plan,
               physical_plan,
               err_stat,
               select_stmt,
               join_type,
               outer_join_tabs,
               outer_join_bitsets,
               outer_join_cnds,
               none_columnlize_alias,
               false,
               optimizer_open,
               false,
               opt_join_operator,
               opt_switch
               )) != OB_SUCCESS)
        {
          break;
        }
        else if ((ret = outer_join_tabs.pop_front(table_op)) != OB_SUCCESS)
        {
          break;
        }
      }
    }
    if (ret == OB_SUCCESS && (ret = phy_table_list.push_back(table_op)) != OB_SUCCESS)
    {
      TRANS_LOG("Add table to internal list failed");
      break;
    }
    if (ret == OB_SUCCESS && (ret = bitset_list.push_back(bit_set)) != OB_SUCCESS)
    {
      TRANS_LOG("Add bitset to internal list failed");
      break;
    }
    bit_set.clear();
  }

  num = select_stmt->get_condition_size();
  for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
  {
    uint64_t expr_id = select_stmt->get_condition_id(i);
    ObSqlRawExpr *where_expr = logical_plan->get_expr(expr_id);
    if (where_expr && where_expr->is_apply() == false
        && (ret = remainder_cnd_list.push_back(where_expr)) != OB_SUCCESS)
    {
      TRANS_LOG("Add condition to internal list failed");
      break;
    }
  }

  return ret;
}
//add fanqiushi_index
int ObTransformer::gen_phy_table_for_storing(              //uncertainty �����������ݸ���
                                                           ObLogicalPlan *logical_plan,
                                                           ObPhysicalPlan *physical_plan,
                                                           ErrStat& err_stat,
                                                           ObStmt *stmt,
                                                           uint64_t table_id,
                                                           ObPhyOperator*& table_op,
                                                           bool* group_agg_pushed_down,
                                                           bool* limit_pushed_down,
                                                           bool is_use_storing_column,
                                                           uint64_t index_tid,
                                                           Expr_Array *filter_array,
                                                           Expr_Array *project_array)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  TableItem* table_item = NULL;
  ObSqlReadStrategy sql_read_strategy;
  int64_t num = 0;
  int64_t sub_query_num = 0;//add fanqiushi_index_in  tianz
  bool is_ailias_table=false;
  ObRpcScanHint hint;
  uint64_t source_tid=OB_INVALID_ID;
  ObTableScan *table_scan_op = NULL;
  UNUSED(logical_plan);

  if (table_id == OB_INVALID_ID || (table_item = stmt->get_table_item_by_id(table_id)) == NULL)
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("Wrong table id");
  }
  else if(filter_array == NULL || project_array == NULL)
  {
    ret=OB_ERROR;
    YYSYS_LOG(ERROR,"filter_array==NULL or project_array == NULL");
  }
  else
  {
    source_tid=table_item->ref_id_;
    if(table_item->type_ == TableItem::ALIAS_TABLE)
    {
      is_ailias_table=true;
    }
    if(is_use_storing_column)
    {
      table_item->ref_id_=index_tid;
    }
  }
  /*
    //add huangcc [fix transaction read uncommit bug]2016/11/21
    if (OB_SUCCESS == ret)
    {
        hint.read_consistency_ = stmt->get_query_hint().read_consistency_;
    }
    //add end
    */
  if (ret == OB_SUCCESS)
  {
    switch (table_item->type_)
    {
      case TableItem::BASE_TABLE:
        /* get through */
      case TableItem::ALIAS_TABLE:
      {
        const ObTableSchema *table_schema = NULL;
        if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_item->ref_id_)))
        {
          ret = OB_ERROR;
          TRANS_LOG("Fail to get table schema for table[%ld]",table_item->ref_id_);
        }
        else
        {
          if (stmt->get_query_hint().read_consistency_ != NO_CONSISTENCY)
          {
            hint.read_consistency_ = stmt->get_query_hint().read_consistency_;
          }
          else
          {
            if (table_schema->is_merge_dynamic_data())
            {
              hint.read_consistency_ = NO_CONSISTENCY;
            }
            else
            {
              hint.read_consistency_ = STATIC;
            }
            if (hint.read_consistency_ == NO_CONSISTENCY)
            {
              ObString name = ObString::make_string(OB_READ_CONSISTENCY);
              ObObj value;
              int64_t read_consistency_level_val = 0;
              hint.read_consistency_ = common::STRONG;
              if (OB_SUCCESS != (ret = sql_context_->session_info_->get_sys_variable_value(name, value)))
              {
                YYSYS_LOG(WARN, "get system variable %.*s failed, ret=%d", name.length(), name.ptr(), ret);
                ret = OB_SUCCESS;
              }
              else if(OB_SUCCESS != (ret = value.get_int(read_consistency_level_val)))
              {
                YYSYS_LOG(WARN, "get int failed, ret=%d",ret);
                ret = OB_SUCCESS;
              }
              else
              {
                hint.read_consistency_ = static_cast<ObConsistencyLevel>(read_consistency_level_val);
              }
              if (sql_context_->merge_service_->get_config().using_strong_consistency)
              {
                hint.read_consistency_ = common::STRONG;
              }
            }
          }
        }
        ObTableRpcScan *table_rpc_scan_op = NULL;
        CREATE_PHY_OPERRATOR(table_rpc_scan_op, ObTableRpcScan, physical_plan, err_stat);
        if(is_ailias_table==false)
        {
          if (ret == OB_SUCCESS
              && (ret = table_rpc_scan_op->set_table(table_item->ref_id_, table_item->ref_id_)) != OB_SUCCESS)
          {
            TRANS_LOG("ObTableRpcScan set table faild");
          }
        }
        else
        {
          if (ret == OB_SUCCESS && (ret = table_rpc_scan_op->set_table(table_item->table_id_, table_item->ref_id_)) != OB_SUCCESS)
          {
            TRANS_LOG("ObTableRpcScan set table faild");
          }
        }
        //YYSYS_LOG(ERROR,"test::fanqs,,table_item->table_id_=%ld,table_item->ref_id_=%ld",table_item->table_id_,table_item->ref_id_);
        table_rpc_scan_op->set_is_index_for_storing(true,index_tid);

        num = project_array->count();
        ObRowDesc desc_for_storing;
        for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
        {
          ObSqlExpression output_expr=project_array->at(i);
          if (OB_SUCCESS != (ret = desc_for_storing.add_column_desc(output_expr.get_table_id(), output_expr.get_column_id())))
          {
            YYSYS_LOG(WARN, "fail to add column desc:ret[%d]", ret);
          }
        }
        if(OB_SUCCESS == ret)
          table_rpc_scan_op->set_is_use_index_for_storing(source_tid,desc_for_storing);



        /// determin request type: scan/get
        if (OB_SUCCESS == ret)
        {
          const ObTableSchema *table_schema = NULL;
          if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_item->ref_id_)))
          {
            ret = OB_ERROR;
            TRANS_LOG("Fail to get table schema for table[%ld]", table_item->ref_id_);
          }
          else
          {
            sql_read_strategy.set_rowkey_info(table_schema->get_rowkey_info());
            if ((ret = physical_plan->add_base_table_version(
                   table_item->ref_id_,
                   table_schema->get_schema_version()
                   )) != OB_SUCCESS)
            {
              TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d", table_item->ref_id_, ret);
            }
          }
        }
        if ( OB_SUCCESS == ret)
        {
          int32_t read_method = ObSqlReadStrategy::USE_SCAN;
          hint.read_method_ = read_method;
        }

        if (ret == OB_SUCCESS)
        {
          ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
          if (select_stmt
              && select_stmt->get_group_expr_size() <= 0
              && select_stmt->get_having_expr_size() <= 0
              && select_stmt->get_order_item_size() <= 0
              && hint.read_method_ != ObSqlReadStrategy::USE_GET)
          {
            hint.max_parallel_count = 1;
          }
          //add by maosy [FIX_SUPPORT_READ_ATOMIC]20170627 b:
          //todo
          if(select_stmt !=NULL)
          {
            common::ObReadAtomicLevel& read_atomic_level = select_stmt->get_query_hint().read_atomic_level_;
            if (read_atomic_level >= common::READ_ATOMIC_WEAK)
            {
              read_atomic_level = common::NO_READ_ATOMIC_LEVEL;
            }
          }
          // add by maosy e
          //add duyr [MultiUPS] [READ_ATOMIC] [read_part] 20151224:b
          if (stmt->get_query_hint().read_atomic_level_ != NO_READ_ATOMIC_LEVEL)
          {
            hint.read_atomic_level_ = stmt->get_query_hint().read_atomic_level_;
            if (stmt->get_query_hint().read_atomic_level_ == READ_ATOMIC_WEAK)
            {
              hint.read_atomic_weak_time_limit_ = stmt->get_query_hint().read_atomic_weak_time_limit_;
            }
          }
          //add duyr 20151224:e
          if ((ret = table_rpc_scan_op->init(sql_context_, &hint)) != OB_SUCCESS)
          {
            TRANS_LOG("ObTableRpcScan init faild");
          }
          //add liumz, [optimize group_order by index]20170419:b
          else
          {
            table_rpc_scan_op->set_indexed_group(select_stmt->is_indexed_group());
          }
          //add:e
        }
        if (ret == OB_SUCCESS)
          table_scan_op = table_rpc_scan_op;
        break;
      }
      default:
        // won't be here
        OB_ASSERT(0);
        break;
    }
  }

  //add dragon [Bugfix 1224] 2016-8-24 13:35:03
  //û�б�Ҫ�ı�table_item��ref_id_��ֵ���ᵼ��semijoin��bug�����bug�ţ������ʹ����֮����Ļ���
  if(is_use_storing_column && table_item->table_id_ != table_item->ref_id_)
  {
    table_item->ref_id_ = source_tid;
  }
  //add e

  if(OB_SUCCESS == ret)
  {
    num = filter_array->count();
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      ObSqlExpression *filter = ObSqlExpression::alloc();
      if (NULL == filter)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        TRANS_LOG("no memory");
        break;
      }
      else
      {
        *filter=filter_array->at(i);
        //����ж���еı���ʽ����û�н����ж�
        //add wanglei [second index fix] 20160425:b
        if(filter->is_expr_has_more_than_two_columns ())
        {
          sub_query_num = sub_query_num + filter->get_sub_query_num();
          if(is_use_storing_column==true &&is_ailias_table==false)
          {
            ObPostfixExpression& ops=filter->get_decoded_expression_v2();
            ObArray<uint64_t> index_of_expr_array=OB_INVALID_ID;
            if(OB_SUCCESS!=(ret=filter->get_tid_indexs (index_of_expr_array)))
            {
              YYSYS_LOG(ERROR,"faild to change tid,filter=%s",to_cstring(*filter));
            }
            for(int i=0;i<index_of_expr_array.count ();i++)
            {
              ObObj& obj=ops.get_expr_by_index(index_of_expr_array.at (i));
              if(obj.get_type()==ObIntType)
                obj.set_int(index_tid);
            }
          }
        }
        else
        {
          sub_query_num = sub_query_num + filter->get_sub_query_num();
          //add:e
          if(is_use_storing_column==true &&is_ailias_table==false)
          {
            uint64_t f_cid = OB_INVALID_ID;
            if (OB_SUCCESS == (ret = filter->get_cid(f_cid)))
            {
              ObPostfixExpression& ops=filter->get_decoded_expression_v2();
              uint64_t index_of_expr_array=OB_INVALID_ID;
              //mod dragon [Bugfix] 2016-12-20
              //���query����1=1����������ԭ������־���ӡERROR��־����ʵ��������������Ӱ�쵽ʵ�ʵĽ������ΪWARN
              if(OB_SUCCESS == (ret = filter->change_tid(index_of_expr_array)))
              {
                ObObj& obj=ops.get_expr_by_index(index_of_expr_array);
                if(obj.get_type()==ObIntType)
                  obj.set_int(index_tid);
              }
              /*else
                            {
                              YYSYS_LOG(WARN,"filter get cid failed, if sql has 1 = 1 filter, it dosent matter");
                            }*/
              /*---old---
                            if(OB_SUCCESS!=(ret=filter->change_tid(index_of_expr_array)))
                            {
                                YYSYS_LOG(ERROR,"faild to change tid,filter=%s",to_cstring(*filter));

                            }
                            ObObj& obj=ops.get_expr_by_index(index_of_expr_array);
                            if(obj.get_type()==ObIntType)
                                obj.set_int(index_tid);
                                ---old---*/
              //mod e
            }
            else if(OB_ENTRY_NOT_EXIST ==  ret)
            {
              ret = OB_SUCCESS;
              YYSYS_LOG(WARN, "filter get cid failed, if sql has 1 = 1 filter, it dosent matter");
            }
          }
        }

        //YYSYS_LOG(ERROR,"test::fanqs,,cid=%ld,tid=%ld,filter=%s",filter->get_column_id(),filter->get_table_id(),to_cstring(*filter));
        if(OB_SUCCESS == ret && (ret = table_scan_op->add_filter(filter)) != OB_SUCCESS)
        {
          TRANS_LOG("Add table filter condition faild");
          //break;
        }
        if (OB_SUCCESS != ret && NULL != filter)
        {
          ObSqlExpression::free(filter);
          break;
        }
      }
    }

    // add output columns
    num = project_array->count();
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {

      ObSqlExpression output_expr=project_array->at(i);
      if(is_use_storing_column)
      {
        if(is_ailias_table==false)
        {
          ObArray<uint64_t> index_column_array;
          if(OB_SUCCESS==output_expr.get_all_cloumn(index_column_array))
          {
            for(int32_t i=0;i<index_column_array.count();i++)
            {
              ObPostfixExpression& ops=output_expr.get_decoded_expression_v2();
              ObObj& obj=ops.get_expr_by_index(index_column_array.at(i));
              if(obj.get_type()==ObIntType)
                obj.set_int(index_tid);
            }
          }
        }
        //output_expr.set_tid_cid();
        //YYSYS_LOG(ERROR,"test::fanqs,,output_expr.get_tid=%ld,,output_expr=%s",output_expr.get_table_id(),to_cstring(output_expr));
        if(output_expr.get_table_id() == source_tid)
        {
          output_expr.set_table_id(index_tid);
        }
        if((ret = table_scan_op->add_output_column(output_expr, !is_ailias_table)) != OB_SUCCESS)//mod liumz, [optimize group_order by index]20170419
        {
          TRANS_LOG("Add table output columns faild");
          break;
        }

      }
    }
  }

  if (ret == OB_SUCCESS)
    table_op = table_scan_op;

  *group_agg_pushed_down = false;
  //*limit_pushed_down = false;

  //add liumz, [bugfix_limit_push_down]20160822:b
  bool group_down = false;//add liumz, [optimize group_order by index]20170419
  bool limit_down = false;
  ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
  //add liumz, [optimize group_order by index]20170419:b
  /* Try to push down aggregations */
  if (ret == OB_SUCCESS && group_agg_push_down_param_ && select_stmt)
  {
    ret = try_push_down_group_agg_for_storing(
            logical_plan,
            physical_plan,
            err_stat,
            select_stmt,
            group_down,
            table_op,
            index_tid,
            is_ailias_table);
    if (group_agg_pushed_down)
      *group_agg_pushed_down = group_down;
  }
  /* Try to push down limit */
  //add:e
  if (ret == OB_SUCCESS && select_stmt)
  {
    ret = try_push_down_limit(
            logical_plan,
            physical_plan,
            err_stat,
            select_stmt,
            limit_down,
            table_op);
    if (limit_pushed_down)
      *limit_pushed_down = limit_down;
  }
  //add:e

  //add by fanqiushi_index_in tianz
  ObMultiBind *multi_bind_op = NULL;
  if(ret == OB_SUCCESS && (sub_query_num>0))
    //if(ret!=OB_SUCCESS)
  {
    physical_plan->need_extend_time();
    int32_t main_query_idx= 0;
    if (CREATE_PHY_OPERRATOR(multi_bind_op, ObMultiBind, physical_plan, err_stat) == NULL
        || (ret = multi_bind_op->set_child(main_query_idx, *table_op)) != OB_SUCCESS)
    {
      TRANS_LOG("fail to set child:ret[%d]",ret);
    }
    else if (table_scan_op->is_base_table_id_valid())//mod zhaoqiong [TableMemScan_Subquery_BUGFIX] 20151118
    {
      ObTableRpcScan *table_rpc_scan_op = dynamic_cast<ObTableRpcScan *>( table_scan_op);
      if(NULL == table_rpc_scan_op )
      {
        ret = OB_ERROR;
        TRANS_LOG("wrong get table_rpc_scan_op, can't dynamic cast");
      }
      else
      {
        //for every sub_query
        //1.get it's physical plan index from main query(ObTableRpcScan)
        //2.get it's top physical operator address from ObPhysicalPlan by it's physical plan index
        //3.bind it's top physical operator address to ObMultiBind
        for(int32_t sub_query_idx = 1;sub_query_idx<=sub_query_num;sub_query_idx++)
        {
          int32_t index = OB_INVALID_INDEX;
          ObPhyOperator * sub_operator = NULL;
          if((ret = table_rpc_scan_op->get_sub_query_index(sub_query_idx,index))!=OB_SUCCESS)
          {
            TRANS_LOG("wrong get sub query index");
          }
          else if(NULL == (sub_operator = physical_plan->get_phy_query(index)))
          {
            ret = OB_INVALID_INDEX;
            TRANS_LOG("wrong get sub query operator");
          }
          else if(OB_SUCCESS != (ret = multi_bind_op->set_child(sub_query_idx, *sub_operator)))
          {
            TRANS_LOG("fail to set child:ret[%d]",ret);
          }

        }
      }
    }
    //add zhaoqiong [TableMemScan_Subquery_BUGFIX] 20151118:b
    else
    {
      ObTableMemScan *table_mem_scan_op = dynamic_cast<ObTableMemScan*>( table_scan_op);
      if(NULL == table_mem_scan_op )
      {
        ret = OB_ERROR;
        TRANS_LOG("wrong get table_mem_scan_op, can't dynamic cast");
      }
      else
      {
        //for every sub_query
        //1.get it's physical plan index from main query(ObTableMemScan)
        //2.get it's top physical operator address from ObPhysicalPlan by it's physical plan index
        //3.bind it's top physical operator address to ObMultiBind
        for(int32_t sub_query_idx = 1;sub_query_idx<=sub_query_num;sub_query_idx++)
        {
          int32_t index = OB_INVALID_INDEX;
          ObPhyOperator * sub_operator = NULL;
          if((ret = table_mem_scan_op->get_sub_query_index(sub_query_idx,index))!=OB_SUCCESS)
          {
            TRANS_LOG("wrong get sub query index");
          }
          else if(NULL == (sub_operator = physical_plan->get_phy_query(index)))
          {
            ret = OB_INVALID_INDEX;
            TRANS_LOG("wrong get sub query operator");
          }
          else if(OB_SUCCESS != (ret = multi_bind_op->set_child(sub_query_idx, *sub_operator)))
          {
            TRANS_LOG("fail to set child:ret[%d]",ret);
          }

        }
      }
    }
    //add:e
    //set multi_bind_op as top opertator
    if (ret == OB_SUCCESS)
      table_op = multi_bind_op;
  }



  //add:e
  return ret;
}

//add fanqiushi_index
//add fanqiushi_index
int ObTransformer::gen_phy_table_without_storing(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObStmt *stmt,
    uint64_t table_id,
    ObPhyOperator*& table_op,
    bool* group_agg_pushed_down,
    bool* limit_pushed_down ,
    uint64_t index_tid_without_storing,
    Expr_Array * filter_array,
    Expr_Array * project_array,
    Join_column_Array *join_column//add by wanglei [semi join second index] 20151231
    )
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  TableItem* table_item = NULL;
  ObSqlReadStrategy sql_read_strategy;
  int64_t num = 0;
  ObRpcScanHint hint;
  ObTableScan *table_scan_op = NULL;


  if (table_id == OB_INVALID_ID || (table_item = stmt->get_table_item_by_id(table_id)) == NULL)
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("Wrong table id");
  }
  /*
    //add huangcc [fix transaction read uncommit bug]2016/11/21
    if (OB_SUCCESS == ret)
    {
        hint.read_consistency_ = stmt->get_query_hint().read_consistency_;
    }
    //add end
    */
  if (ret == OB_SUCCESS)
  {
    // YYSYS_LOG(ERROR,"test::fanqs,,,table_item->type_=%d",table_item->type_);
    switch (table_item->type_)
    {
      case TableItem::BASE_TABLE:
        /* get through */
      case TableItem::ALIAS_TABLE:
      {
        const ObTableSchema *table_schema = NULL;
        if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_item->ref_id_)))
        {
          ret = OB_ERROR;
          TRANS_LOG("Fail to get table schema for table[%ld]", table_item->ref_id_);
        }
        else
        {
          if (stmt->get_query_hint().read_consistency_ != NO_CONSISTENCY)
          {
            hint.read_consistency_ = stmt->get_query_hint().read_consistency_;
          }
          else
          {
            //no hint
            if (table_schema->is_merge_dynamic_data())
            {
              hint.read_consistency_ = NO_CONSISTENCY;
            }
            else
            {
              hint.read_consistency_ = STATIC;
            }
            if (hint.read_consistency_ == NO_CONSISTENCY)
            {
              ObString name = ObString::make_string(OB_READ_CONSISTENCY);
              ObObj value;
              int64_t read_consistency_level_val = 0;
              hint.read_consistency_ = common::STRONG;
              if (OB_SUCCESS != (ret = sql_context_->session_info_->get_sys_variable_value(name, value)))
              {
                YYSYS_LOG(WARN, "get system variable %.*s failed, ret=%d", name.length(), name.ptr(), ret);
                ret = OB_SUCCESS;
              }
              else if(OB_SUCCESS != (ret = value.get_int(read_consistency_level_val)))
              {
                YYSYS_LOG(WARN, "get int failed, ret=%d",ret);
                ret = OB_SUCCESS;
              }
              else
              {
                hint.read_consistency_ = static_cast<ObConsistencyLevel>(read_consistency_level_val);
              }
              if (sql_context_->merge_service_->get_config().using_strong_consistency)
              {
                hint.read_consistency_ = common::STRONG;
              }
            }
          }
        }
        ObTableRpcScan *table_rpc_scan_op = NULL;
        CREATE_PHY_OPERRATOR(table_rpc_scan_op, ObTableRpcScan, physical_plan, err_stat);
        if (ret == OB_SUCCESS
            && (ret = table_rpc_scan_op->set_table(table_item->table_id_, index_tid_without_storing)) != OB_SUCCESS)
        {
          TRANS_LOG("ObTableRpcScan set table faild");
        }

        //mod dragon [Nullptr] 2016-9-22b
        /*---new---*/
        if(OB_SUCCESS == ret)
        {
          table_rpc_scan_op->set_main_tid(table_item->ref_id_);
          table_rpc_scan_op->set_is_use_index_without_storing();
          table_rpc_scan_op->set_is_index_without_storing(true,index_tid_without_storing);
        }
        /*---old
            table_rpc_scan_op->set_main_tid(table_item->ref_id_);
            table_rpc_scan_op->set_is_use_index_without_storing();
            table_rpc_scan_op->set_is_index_without_storing(true,index_tid_without_storing);
            ---old---*/
        //mod 2016-9-22e

        const ObTableSchema *main_table_schema = NULL;
        if (NULL == (main_table_schema = sql_context_->schema_manager_->get_table_schema(table_item->ref_id_)))
        {
          ret = OB_ERROR;
          TRANS_LOG("Fail to get table schema for table[%ld]", index_tid_without_storing);
        }
        else
        {
          table_rpc_scan_op->set_main_rowkey_info(main_table_schema->get_rowkey_info());
        }

        /// determin request type: scan/get
        if (OB_SUCCESS == ret)
        {
          const ObTableSchema *table_schema = NULL;
          if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(index_tid_without_storing)))
          {
            ret = OB_ERROR;
            TRANS_LOG("Fail to get table schema for table[%ld]", index_tid_without_storing);
          }
          else
          {
            sql_read_strategy.set_rowkey_info(table_schema->get_rowkey_info());
            if ((ret = physical_plan->add_base_table_version(
                   index_tid_without_storing,
                   table_schema->get_schema_version()
                   )) != OB_SUCCESS)
            {
              TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d", index_tid_without_storing, ret);
            }
          }
        }
        if ( OB_SUCCESS == ret)
        {
          int32_t read_method = ObSqlReadStrategy::USE_SCAN;
          hint.read_method_ = read_method;
        }

        if (ret == OB_SUCCESS)
        {
          ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
          //add by maosy [FIX_SUPPORT_READ_ATOMIC]20170627 b:
          if(select_stmt !=NULL)
          {
            common::ObReadAtomicLevel& read_atomic_level = select_stmt->get_query_hint().read_atomic_level_;
            if (read_atomic_level >= common::READ_ATOMIC_WEAK)
            {
              read_atomic_level = common::NO_READ_ATOMIC_LEVEL;
            }
          }
          // add by maosy e
          if (select_stmt
              && select_stmt->get_group_expr_size() <= 0
              && select_stmt->get_having_expr_size() <= 0
              && select_stmt->get_order_item_size() <= 0
              && hint.read_method_ != ObSqlReadStrategy::USE_GET)
          {
            hint.max_parallel_count = 1;
          }
          if ((ret = table_rpc_scan_op->init(sql_context_, &hint)) != OB_SUCCESS)
          {
            TRANS_LOG("ObTableRpcScan init faild");
          }
        }
        if (ret == OB_SUCCESS)
          table_scan_op = table_rpc_scan_op;
        break;
      }
      default:
        // won't be here
        OB_ASSERT(0);
        break;
    }
  }

  if(OB_SUCCESS == ret && filter_array != NULL && project_array != NULL)
  {
    num = filter_array->count();
    //add by wanglei [semi join] 20151231
    //add wanglei:���numΪ�㣬˵�����п�������Ϊjoin��on�Ӿ������漰�����ڱ����������У�
    //��������£�filter�Ĺ������semi join��open�׶ν��У���ˣ���ʱ���µĲ�������ʧЧ
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      ObSqlExpression *filter = ObSqlExpression::alloc();
      if(filter == NULL)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR,"[semi join] there is no memory left!");
      }
      else
      {
        *filter=filter_array->at(i);
        //YYSYS_LOG(ERROR,"test::fanqs,,filter=%s,,filter->get_sub_query_num()=%ld",to_cstring(*filter),filter->get_sub_query_num());
        if((ret = table_scan_op->add_main_filter(filter)) != OB_SUCCESS)
        {
          ObSqlExpression::free (filter);
          TRANS_LOG("Add table filter condition faild");
          break;
        }

        bool need_free = true;//add liumz, [bugfix: index memory overflow]20170105
        //YYSYS_LOG(ERROR,"test::fanqs,,cid=%ld,tid=%ld,filter=%s",filter->get_column_id(),filter->get_table_id(),to_cstring(*filter));
        uint64_t f_cid=OB_INVALID_ID;
        if(!filter->is_expr_has_more_than_two_columns ())//add wanglei [second index fix] 20160425
        {
          if(OB_SUCCESS == (ret = filter->get_cid(f_cid)))
          {
            int64_t bool_result=is_cid_in_index_table(f_cid,index_tid_without_storing);
            //YYSYS_LOG(ERROR,"test::fanqs,,bool_result=%ld",bool_result);
            if(bool_result!=0)
            {
              ObPostfixExpression& ops=filter->get_decoded_expression_v2();
              uint64_t index_of_expr_array = OB_INVALID_ID;
              if(OB_SUCCESS!=(ret=filter->change_tid(index_of_expr_array)))
              {
                YYSYS_LOG(ERROR,"faild to change tid,filter=%s",to_cstring(*filter));

              }
              ObObj& obj=ops.get_expr_by_index(index_of_expr_array);
              if(obj.get_type()==ObIntType)
                obj.set_int(index_tid_without_storing);
              if((ret = table_scan_op->add_filter(filter)) != OB_SUCCESS)
              {
                ObSqlExpression::free (filter);
                TRANS_LOG("Add table filter condition faild");
                break;
              }
              else if((ret = table_scan_op->add_index_filter_ll(filter)) != OB_SUCCESS)// add wanglei [semi join] 20160108
              {
                ObSqlExpression::free (filter);
                TRANS_LOG("Add table filter condition faild");
                break;
              }
              else
              {
                need_free = false;
              }
            }
          }
          else if (OB_ENTRY_NOT_EXIST == ret)
          {
            ret = OB_SUCCESS;
            YYSYS_LOG(WARN,"filter get cid failed, if sql has 1 = 1 filter, it dosent matter");
            if ((ret = table_scan_op->add_filter(filter)) != OB_SUCCESS)
            {
              ObSqlExpression::free(filter);
              TRANS_LOG("Add table filter condition faild");
              break;
            }
            else if ((ret = table_scan_op->add_index_filter_ll(filter)) != OB_SUCCESS)
            {
              ObSqlExpression::free(filter);
              TRANS_LOG("Add table filter condition faild");
              break;
            }
            else
            {
              need_free = false;
            }
          }
        }
        //add liumz, [bugfix: index memory overflow]20170105:b
        if(need_free && NULL != filter)
        {
          ObSqlExpression::free(filter);
        }
        //add:e
      }
    }

    // add output columns
    num = project_array->count();
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      ObSqlExpression output_expr=project_array->at(i);
      //YYSYS_LOG(ERROR,"test::fanqs,,output_expr=%s",to_cstring(output_expr));
      if((ret = table_scan_op->add_main_output_column(output_expr)) != OB_SUCCESS)
      {
        TRANS_LOG("Add table output columns faild");
        break;
      }


    }

    if(OB_SUCCESS == ret)
    {
      ObRowDesc row_desc;
      if(OB_SUCCESS!=(ret=table_scan_op->cons_second_row_desc(row_desc)))
      {
        YYSYS_LOG(WARN,"faild to cons_second_row_desc,ret=%d",ret);
      }
      else if(OB_SUCCESS!=(ret=table_scan_op->set_second_row_desc(&row_desc)))
      {
        YYSYS_LOG(WARN,"faild to set_second_row_desc,ret=%d",ret);
      }
    }
    if(OB_SUCCESS == ret)
    {
      const ObTableSchema *index_table_schema = NULL;
      if (NULL == (index_table_schema = sql_context_->schema_manager_->get_table_schema(index_tid_without_storing)))
      {
        ret = OB_ERROR;
        TRANS_LOG("Fail to get table schema for table[%ld]", index_tid_without_storing);
      }
      else
      {
        uint64_t cid=OB_INVALID_ID;
        int64_t rowkey_column=index_table_schema->get_rowkey_info().get_size();
        for(int64_t j=0;j<rowkey_column;j++)
        {
          if(OB_SUCCESS!=(ret=index_table_schema->get_rowkey_info().get_column_id(j,cid)))
          {
            YYSYS_LOG(ERROR,"get column schema failed,cid[%ld]",cid);
            ret=OB_SCHEMA_ERROR;
          }
          else
          {
            ObBinaryRefRawExpr col_expr(index_tid_without_storing, cid, T_REF_COLUMN);
            ObSqlRawExpr col_raw_expr(
                  common::OB_INVALID_ID,
                  index_tid_without_storing,
                  cid,
                  &col_expr);
            ObSqlExpression output_expr;
            if ((ret = col_raw_expr.fill_sql_expression(
                   output_expr,
                   this,
                   logical_plan,
                   physical_plan)) != OB_SUCCESS)

            {
              TRANS_LOG("Add table output columns faild");
              break;
            }
            else if((ret = table_scan_op->add_output_column(output_expr)) != OB_SUCCESS )
            {
              TRANS_LOG("Add table output columns faild");
              break;
            }
            else if((ret = table_scan_op->add_index_output_column_ll(output_expr))!= OB_SUCCESS)// add wanglei [semi join] 20160108
            {
              TRANS_LOG("Add table output columns faild");
              break;
            }
          }
        }

      }

    }
    //add wanglei [semi join second index] 20160107 :b
    //��on����ʽ�е��м��뵽�����
    if(join_column == NULL)
    {
      ret = OB_ERR_POINTER_IS_NULL;
      YYSYS_LOG(WARN,"on expression join column array is null!");
    }
    else
    {
      for(int l=0;l<join_column->count();l++)
      {
        uint64_t tmp_cid = join_column->at(l);
        int64_t bool_result = is_cid_in_index_table(tmp_cid,index_tid_without_storing);
        if(bool_result == 2)
        {
          ObBinaryRefRawExpr col_expr(index_tid_without_storing, tmp_cid, T_REF_COLUMN);
          ObSqlRawExpr col_raw_expr(
                common::OB_INVALID_ID,
                index_tid_without_storing,
                tmp_cid,
                &col_expr);
          ObSqlExpression output_expr;
          if ((ret = col_raw_expr.fill_sql_expression(
                 output_expr,
                 this,
                 logical_plan,
                 physical_plan)) != OB_SUCCESS)

          {
            TRANS_LOG("Add table output columns faild");
            break;
          }
          else if((ret = table_scan_op->add_output_column(output_expr)) != OB_SUCCESS)
          {
            TRANS_LOG("Add table output columns faild");
            break;
          }
        }
      }
    }
    //add:e
    ObSqlExpression *filter = NULL;//add liumz, [bugfix: index memory overflow]20170105
    num = filter_array->count();
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      //mod liumz, [bugfix: index memory overflow]20170105:b
      //ObSqlExpression *filter = ObSqlExpression::alloc();
      if(NULL != filter)
      {
        ObSqlExpression::free(filter);
      }
      filter = ObSqlExpression::alloc();
      if (NULL == filter)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR, "no memory");
        break;
      }
      //mod:e
      *filter=filter_array->at(i);
      //YYSYS_LOG(ERROR,"wanglei::filter:%s",to_cstring(*filter));
      uint64_t cid=OB_INVALID_ID;
      if(!filter->is_expr_has_more_than_two_columns ())//add wanglei [second index fix] 20160425
      {
        if(OB_SUCCESS== (ret = filter->get_cid(cid)))
        {
          int64_t bool_result=is_cid_in_index_table(cid,index_tid_without_storing);
          //YYSYS_LOG(ERROR,"wanglei::,,bool_result=%ld",bool_result);
          if(bool_result==2)
          {
            ObBinaryRefRawExpr col_expr(index_tid_without_storing, cid, T_REF_COLUMN);
            ObSqlRawExpr col_raw_expr(
                  common::OB_INVALID_ID,
                  index_tid_without_storing,
                  cid,
                  &col_expr);
            ObSqlExpression output_expr;
            if ((ret = col_raw_expr.fill_sql_expression(
                   output_expr,
                   this,
                   logical_plan,
                   physical_plan)) != OB_SUCCESS)

            {
              TRANS_LOG("Add table output columns faild");
              break;
            }
            const ObRowDesc *row_desc = NULL;
            if (OB_SUCCESS == (ret = static_cast<ObTableRpcScan *>(table_scan_op)->get_rpc_row_desc(row_desc)))
            {
              if (OB_INVALID_INDEX != row_desc->get_idx(output_expr.get_table_id(), output_expr.get_column_id()))
              {
                //NOTHING TODO
              }
              else if((ret = table_scan_op->add_output_column(output_expr)) != OB_SUCCESS )
              {
                TRANS_LOG("Add table output columns faild");
                break;
              }
              else if((ret = table_scan_op->add_index_output_column_ll(output_expr))!= OB_SUCCESS)// add wanglei [semi join] 20160108
              {
                TRANS_LOG("Add table output columns faild");
                break;
              }
            }
          }
          else if(bool_result==0)
          {
            if((ret=table_scan_op->add_index_filter(filter))!=OB_SUCCESS )
            {
              YYSYS_LOG(WARN,"faild to add index_filter,ret=%d",ret);
            }
          }
        }
        else if(OB_ENTRY_NOT_EXIST == ret)
        {
          ret = OB_SUCCESS;
          YYSYS_LOG(WARN,"filter get cid failed, if sql has 1 = 1 filter, it dose not matter");
        }
      }
      else
      {
        if((ret=table_scan_op->add_index_filter(filter))!=OB_SUCCESS )
        {
          YYSYS_LOG(WARN,"faild to add index_filter,ret=%d",ret);
        }
      }
    }
    //mod liumz, [bugfix: index memory overflow]20170105:b
    if(NULL != filter)
    {
      ObSqlExpression::free(filter);
    }
    //add:e

  }

  if (ret == OB_SUCCESS)
    table_op = table_scan_op;
  *group_agg_pushed_down = false;
  //*limit_pushed_down = false;

  //add liumz, [bugfix_limit_push_down]20160822:b
  bool limit_down = false;
  ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
  if (ret == OB_SUCCESS && select_stmt)
  {
    ret = try_push_down_limit(
            logical_plan,
            physical_plan,
            err_stat,
            select_stmt,
            limit_down,
            table_op);
    if (limit_pushed_down)
      *limit_pushed_down = limit_down;
  }
  //add:e

  return ret;
}



bool ObTransformer::handle_index_for_one_table(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObStmt *stmt,
    uint64_t table_id,
    ObPhyOperator*& table_op,
    ObPhyOperator *sequence_op,//add liumz, [index_sequence_filter]20170704
    bool* group_agg_pushed_down,
    bool* limit_pushed_down,
    bool outer_join_scope,//add liumz, [outer_join_on_where]20150927
    bool optimizer_open
    )
{

  Expr_Array filter_array;
  common::ObArray<ObSqlExpression*>  fp_array; //add wenghaixing 20150909 fix memory overflow bug for se_index
  Expr_Array project_array;
  //add liumz, [optimize group_order by index]20170419:b
  Expr_Array order_array;
  Expr_Array group_array;
  //add:e
  Join_column_Array join_column;//add wanglei [semi join] 20160106
  ObArray<uint64_t> alias_exprs;
  bool not_use_index = false;//add zhuyanchao secondary index20150708
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  bool return_ret=false;
  //add BUG
  bool is_gen_table = false;
  //add:e
  TableItem* table_item = NULL;
  ObBitSet<> table_bitset;
  int32_t num = 0;
  UNUSED(group_agg_pushed_down);
  UNUSED(limit_pushed_down);
  bool can_use_rel_opt = false;
  ObOptimizerRelation * rel_opt = NULL;

  if(NULL == stmt)
  {
    YYSYS_LOG(ERROR,"enter this  stmt=NULL");
  }
  else
  {
    table_item = stmt->get_table_item_by_id(table_id);
    not_use_index = stmt->get_query_hint().not_use_index_;
    //find rel_opt
    ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
    if (select_stmt != NULL && optimizer_open)
    {
      common::ObList<ObOptimizerRelation*> * rel_opt_list = select_stmt->get_rel_opt_list();
      common::ObList<ObOptimizerRelation*>::const_iterator iter = rel_opt_list->begin();
      for (;iter != rel_opt_list->end();iter++)
      {
        if ((*iter) != NULL && table_id == (*iter)->get_table_id())
        {
          can_use_rel_opt = true;
          rel_opt = (*iter);
          break;
        }
      }
    }
  }
  if(table_item!=NULL)
  {
    if(table_item->type_!=TableItem::BASE_TABLE&&table_item->type_!=TableItem::ALIAS_TABLE)
    {
      ret = OB_NOT_SUPPORTED;
      //add BUG
      is_gen_table = true;
      //add:e
      YYSYS_LOG(DEBUG," not support this type, table_item->type_=%d",table_item->type_);
    }
  }
  else
  {
    YYSYS_LOG(WARN,"  table_item=NULL");
    ret = OB_NOT_SUPPORTED;
  }
  //YYSYS_LOG(ERROR,"enter this2,table_id=%ld",table_id);

  //add liumz, [range_index_bug]20170511:b
  ObSelectStmt *sel_stmt = NULL;
  if (NULL != stmt)
  {
    sel_stmt = dynamic_cast<ObSelectStmt*>(stmt);
  }

  if (NULL != sel_stmt && sel_stmt->get_has_range())
  {
    return_ret = false;
  }
  //add:e
  else if(not_use_index)
  {
    return_ret = false;
  }
  else if (optimizer_open && can_use_rel_opt && rel_opt != NULL && !sel_stmt->is_max_min_eliminate())
  {
    rel_opt->print_rel_opt_info_V2();
    //find index table
    if (rel_opt->get_index_table_array().size() == 0)
    {
      return_ret = false;
    }
    else
    {
      int32_t cheapest_index_table_idx = 0;
      double tmp_cheapest_cost = rel_opt->get_index_table_array().at(0).cost_;
      for (int32_t i = 1; i < rel_opt->get_index_table_array().size();i++)
      {
        if (rel_opt->get_index_table_array().at(i).cost_ < tmp_cheapest_cost)
        {
          tmp_cheapest_cost = rel_opt->get_index_table_array().at(i).cost_;
          cheapest_index_table_idx = i;
        }
      }

      const ObIndexTableInfo & index_table_info = rel_opt->get_index_table_array().at(cheapest_index_table_idx);
      if (tmp_cheapest_cost > rel_opt->get_seq_scan_cost())
      {
        return_ret = false;
      }
      else
      {
        if(OB_SUCCESS == ret)    //�ܾ�table_bitset����sql�������ñ��йص�filter������ж��浽��Ӧ����������
        {
          int32_t bit_index = stmt->get_table_bit_index(table_item->table_id_);
          table_bitset.add_member(bit_index);

          if (bit_index < 0)
          {
            YYSYS_LOG(ERROR, "negative bitmap values,table_id=%ld" ,table_item->table_id_);
          }
          //add filter
          num = stmt->get_condition_size();
          for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
          {
            ObSqlRawExpr *cnd_expr = logical_plan->get_expr(stmt->get_condition_id(i));
            if (cnd_expr && table_bitset.is_superset(cnd_expr->get_tables_set()))
            {
              if (!outer_join_scope)//add liumz, [outer_join_on_where]20150927
              {
                cnd_expr->set_applied(true);
              }

              //add duyr [join_without_pushdown_is_null] 20151214:b
              if (outer_join_scope && !cnd_expr->can_push_down_with_outerjoin())
              {
                continue;
              }
              //add duyr 20151214:e

              ObSqlExpression *filter = ObSqlExpression::alloc();
              if (NULL == filter)
              {
                ret = OB_ALLOCATE_MEMORY_FAILED;
                TRANS_LOG("no memory");
                break;
              }
              else if ((ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan)) != OB_SUCCESS)
              {
                TRANS_LOG("Add table filter condition faild");
                ObSqlExpression::free(filter);
                break;
              }
              else if(OB_SUCCESS != (ret = filter_array.push_back(*filter)))
              {
                TRANS_LOG("push back to filter array failed");
                ObSqlExpression::free(filter);
                break;
              }
              else if(OB_SUCCESS != (ret = fp_array.push_back(filter)))
              {
                ObSqlExpression::free(filter);
                TRANS_LOG("push back to filter array ptr failed");
                break;
              }
            }
          }
          // add join column
          //�����õĴ���
          //Ŀǰ��֧���Զ�ʶ��on��table��˳����from��table��˳���Ƿ�һ�¡�
          for(int i = 0;i< logical_plan->get_expr_list_num();i++)
          {
            ObSqlRawExpr * ob_sql_raw_expr = logical_plan->get_expr_for_something(i);
            if(NULL == ob_sql_raw_expr)
            {
              ret = OB_ERR_POINTER_IS_NULL;
              YYSYS_LOG(WARN, "logical plan expression is null!");
            }
            else
            {
              ObSqlExpression *cnd_ll_= ObSqlExpression::alloc();
              if(cnd_ll_ == NULL)
              {
                ret = OB_ALLOCATE_MEMORY_FAILED;
                YYSYS_LOG(WARN, "no memory");
              }
              else if(ob_sql_raw_expr->get_expr()->is_join_cond())
              {
                if(OB_SUCCESS != (ret = ob_sql_raw_expr->fill_sql_expression(*cnd_ll_,
                                                                             this,
                                                                             logical_plan,
                                                                             physical_plan)))
                {
                  YYSYS_LOG(WARN, "get equijoin_cond faild!");
                }
                else
                {
                  ExprItem::SqlCellInfo c1;
                  ExprItem::SqlCellInfo c2;
                  cnd_ll_->is_equijoin_cond(c1,c2);
                  //table_id �����Ǳ���id��Ҳ������ԭ��id
                  if(c1.tid == table_id)
                  {
                    join_column.push_back(c1.cid);
                  }
                  else
                    if(c2.tid == table_id)
                    {
                      join_column.push_back(c2.cid);
                    }
                }
              }
              if(cnd_ll_ != NULL)
              {
                ObSqlExpression::free(cnd_ll_);
              }
            }
          }
          //add:e
          // add output columns
          num = stmt->get_column_size();
          for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
          {
            const ColumnItem *col_item = stmt->get_column_item(i);
            if (col_item && col_item->table_id_ == table_item->table_id_)
            {
              ObBinaryRefRawExpr col_expr(col_item->table_id_, col_item->column_id_, T_REF_COLUMN);
              ObSqlRawExpr col_raw_expr(
                    common::OB_INVALID_ID,
                    col_item->table_id_,
                    col_item->column_id_,
                    &col_expr);
              ObSqlExpression output_expr;
              if ((ret = col_raw_expr.fill_sql_expression(
                     output_expr,
                     this,
                     logical_plan,
                     physical_plan)) != OB_SUCCESS)
              {
                TRANS_LOG("Add table output columns faild");
                break;
              }
              else
              {
                project_array.push_back(output_expr);
              }
              //add fanqiushi_index
              //YYSYS_LOG(ERROR,"test::fanqs,,,output_expr=%s",to_cstring(output_expr));
              //add:e
            }
          }
          //add project array
          ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
          if (ret == OB_SUCCESS && select_stmt)
          {
            num = select_stmt->get_select_item_size();
            for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
            {
              const SelectItem& select_item = select_stmt->get_select_item(i);
              if (select_item.is_real_alias_)
              {
                ObSqlRawExpr *alias_expr = logical_plan->get_expr(select_item.expr_id_);
                if (alias_expr && alias_expr->is_columnlized() == false
                    && table_bitset.is_superset(alias_expr->get_tables_set()))
                {
                  ObSqlExpression output_expr;
                  if ((ret = alias_expr->fill_sql_expression(
                         output_expr,
                         this,
                         logical_plan,
                         physical_plan)) != OB_SUCCESS)
                  {
                    TRANS_LOG("Add table output columns faild");
                    break;
                  }
                  else
                  {
                    project_array.push_back(output_expr);
                  }
                  //add fanqiushi_index
                  // YYSYS_LOG(ERROR,"test::fanqs,,,output_expr=%s",to_cstring(output_expr));
                  //add:e
                  alias_exprs.push_back(select_item.expr_id_);
                  alias_expr->set_columnlized(true);
                }
                //add liummz, [alias in expr subquery bug] 20171024
                else if (alias_expr && alias_expr->is_columnlized() == true
                         && alias_expr->get_expr()->is_column()
                         && table_bitset.is_superset(alias_expr->get_tables_set()))
                {
                  ObSqlExpression output_expr;
                  if ((ret = alias_expr->fill_sql_expression(
                         output_expr,
                         this,
                         logical_plan,
                         physical_plan)) != OB_SUCCESS)
                  {
                    TRANS_LOG("Add table output columns faild");
                    break;
                  }
                  else
                  {
                    project_array.push_back(output_expr);
                  }
                }
                //add :e
              }
            }
          }
        }
        bool group_down = false;
        bool limit_down = false;
        ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);

        int64_t sub_query_num = 0;
        int64_t num = 0;
        num = filter_array.count();
        for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
        {
          sub_query_num = sub_query_num + filter_array.at(i).get_sub_query_num();
        }

        if (sub_query_num == 0)
        {
          //handle group by and order by
          if (index_table_info.group_by_applyed_)
          {
            for (int32_t i = 0; ret == OB_SUCCESS && i < select_stmt->get_group_expr_size(); i++)
            {
              select_stmt->get_group_expr_flag(i) = 1;
            }
          }
          if (index_table_info.order_by_applyed_)
          {
            for (int32_t i = 0; ret == OB_SUCCESS && i < select_stmt->get_order_item_size(); i++)
            {
              select_stmt->get_order_item_flag(i) = 1;
            }
          }
          //generate table_op
          if (index_table_info.is_back_)
          {
            ret = gen_phy_table_without_storing(
                    logical_plan,
                    physical_plan,
                    err_stat,
                    stmt,
                    table_id,
                    table_op,
                    &group_down,
                    &limit_down,
                    index_table_info.index_table_id_,
                    &filter_array,
                    &project_array,
                    &join_column
                    );
          }
          else
          {
            ret = gen_phy_table_for_storing(
                    logical_plan,
                    physical_plan,
                    err_stat,
                    stmt,
                    table_id,
                    table_op,
                    &group_down,
                    &limit_down,
                    true,
                    index_table_info.index_table_id_,
                    &filter_array,
                    &project_array
                    );
          }
          if (group_agg_pushed_down)
            *group_agg_pushed_down = group_down;
          if (limit_pushed_down)
            *limit_pushed_down = limit_down;
        }
        else
        {
          YYSYS_LOG(WARN, "sub_query_num != 0");
          return_ret = false;
        }

        if(ret != OB_SUCCESS)
        {
          YYSYS_LOG(WARN, "gen_phy_table is fail. => %d",ret);
        }
        else
        {
          return_ret = true;
        }

        if ((OB_SUCCESS != ret) || !return_ret)
        {
          if (index_table_info.group_by_applyed_)
          {
            for (int32_t i = 0; ret == OB_SUCCESS && i < select_stmt->get_group_expr_size(); i++)
            {
              select_stmt->get_group_expr_flag(i) = 0;
            }
          }
          if (index_table_info.order_by_applyed_)
          {
            for (int32_t i = 0; ret == OB_SUCCESS && i < select_stmt->get_order_item_size(); i++)
            {
              select_stmt->get_order_item_flag(i) = 0;
            }
          }
          {
            for (int32_t i = 0; i<alias_exprs.count();i++)
            {
              ObSqlRawExpr *alias_expr = logical_plan->get_expr(alias_exprs.at(i));
              if (alias_expr)
              {
                alias_expr->set_columnlized(false);
              }
            }
          }
        }
      }
    }

    if (!return_ret)
    {
      if (rel_opt->get_seq_scan_info().group_by_applyed_)
      {
        for (int32_t i = 0; ret == OB_SUCCESS && i < rel_opt->get_group_by_num(); i++)
        {
          sel_stmt->get_group_expr_flag(i) = 1;
        }
      }
      if (rel_opt->get_seq_scan_info().order_by_applyed_)
      {
        for (int32_t i = 0; ret == OB_SUCCESS && i < rel_opt->get_order_by_num(); i++)
        {
          sel_stmt->get_order_item_flag(i) = 1;
        }
      }
    }
  }
  else
  {
    ObSequenceSelect *sequence_select_op = NULL;
    if (sequence_op != NULL)
    {
      sequence_select_op = dynamic_cast<ObSequenceSelect*>(sequence_op);
    }
    if (NULL != sequence_select_op)
    {
      ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
      sequence_select_op->reset_sequence_names_idx(select_stmt->get_column_has_sequene_count());
    }
    if (OB_SUCCESS == ret)
    {
      int32_t bit_index = stmt->get_table_bit_index(table_item->table_id_);
      table_bitset.add_member(bit_index);
      if (bit_index < 0)
      {
        YYSYS_LOG(ERROR, "negative bitmap values,table_id=%ld", table_item->table_id_);
      }
      //add filter
      num = stmt->get_condition_size();
      for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
      {
        ObSqlRawExpr *cnd_expr = logical_plan->get_expr(stmt->get_condition_id(i));
        if (cnd_expr && table_bitset.is_superset(cnd_expr->get_tables_set()))
        {
          if (!outer_join_scope)
          {
            cnd_expr->set_applied(true);
          }
          if (outer_join_scope && !cnd_expr->can_push_down_with_outerjoin())
          {
            continue;
          }
          ObSqlExpression *filter = ObSqlExpression::alloc();
          if (NULL == filter)
          {
            ret = OB_ALLOCATE_MEMORY_FAILED;
            TRANS_LOG("no memory");
            break;
          }
          else if ((ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan)) != OB_SUCCESS)
          {
            TRANS_LOG("Add table filter condition faild");
            ObSqlExpression::free(filter);
            break;
          }
          else
          {
            if (OB_SUCCESS == ret && NULL != sequence_select_op)
            {
              if (sequence_select_op->can_fill_sequence_info())
              {
                uint64_t temp_id = stmt->get_condition_id(i);
                if (sequence_select_op->is_sequence_cond_id(temp_id))
                {
                  if (OB_SUCCESS != (ret = sequence_select_op->fill_the_sequence_info_to_cond_expr(filter, OB_INVALID_ID)))
                  {
                    TRANS_LOG("Failed deal the sequence condition filter,err=%d",ret);
                    break;
                  }
                }
              }
            }
            if (OB_SUCCESS != (ret = filter_array.push_back(*filter)))
            {
              TRANS_LOG("push back to filter array failed");
              ObSqlExpression::free(filter);
              break;
            }
            else if(OB_SUCCESS != (ret = fp_array.push_back(filter)))
            {
              ObSqlExpression::free(filter);
              TRANS_LOG("push back to filter array ptr failed");
              break;
            }
          }
        }
      }
      ObVector<TableItem> table_item_v;
      for (int i = 0; i< stmt->get_table_size(); i++)
      {
        TableItem tmp;
        tmp = stmt->get_table_item(i);
        table_item_v.push_back(tmp);
      }
      for(int i = 0; i < logical_plan->get_expr_list_num(); i++)
      {
        bool is_same_order = false;
        ExprItem::SqlCellInfo c1;
        ExprItem::SqlCellInfo c2;
        ObSqlRawExpr *ob_sql_raw_expr = logical_plan->get_expr_for_something(i);
        if (NULL == ob_sql_raw_expr)
        {
          ret = OB_ERR_POINTER_IS_NULL;
          YYSYS_LOG(WARN, "logical plan expression is null!");
        }
        else
        {
          ObSqlExpression *cond_expr = ObSqlExpression::alloc();
          if (cond_expr == NULL)
          {
            ret = OB_ALLOCATE_MEMORY_FAILED;
            YYSYS_LOG(WARN, "no memory");
          }
          else if (ob_sql_raw_expr->get_expr()->is_join_cond())
          {
            if (OB_SUCCESS != (ret = ob_sql_raw_expr->fill_sql_expression(
                                 *cond_expr,
                                 this,
                                 logical_plan,
                                 physical_plan)))
            {
              YYSYS_LOG(WARN,"get equijoin_cond faild! ret[%d]",ret);
            }
            else
            {
              cond_expr->is_equijoin_cond(c1, c2);
              for (int i = 0; i < table_item_v.size(); i++)
              {
                uint64_t tmp_tid = table_item_v.at(i).table_id_;
                if (c1.tid == tmp_tid)
                {
                  i++;
                  for (; i < table_item_v.size(); i++)
                  {
                    tmp_tid = table_item_v.at(i).table_id_;
                    if (c2.tid == tmp_tid)
                    {
                      is_same_order = true;
                      break;
                    }
                  }
                }
              }
            }
            if (is_same_order)
            {
              if (c2.tid == table_id)
              {
                join_column.push_back(c2.cid);
              }
            }
            else
            {
              if (c1.tid == table_id)
              {
                join_column.push_back(c1.cid);
              }
            }
          }
          if (cond_expr != NULL)
          {
            ObSqlExpression::free(cond_expr);
            cond_expr = NULL;
          }
        }
      }
      num = stmt->get_column_size();
      for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
      {
        const ColumnItem *col_item = stmt->get_column_item(i);
        if (col_item && col_item->table_id_ == table_item->table_id_)
        {
          ObBinaryRefRawExpr col_expr(col_item->table_id_, col_item->column_id_, T_REF_COLUMN);
          ObSqlRawExpr col_raw_expr(
                common::OB_INVALID_ID,
                col_item->table_id_,
                col_item->column_id_,
                &col_expr);
          ObSqlExpression output_expr;
          if ((ret = col_raw_expr.fill_sql_expression(
                 output_expr,
                 this,
                 logical_plan,
                 physical_plan)) != OB_SUCCESS)
          {
            TRANS_LOG("Add table output columns faild");
            break;
          }
          else
          {
            project_array.push_back(output_expr);
          }
        }
      }
      ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
      if (ret == OB_SUCCESS && select_stmt)
      {
        num = select_stmt->get_select_item_size();
        for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
        {
          const SelectItem& select_item = select_stmt->get_select_item(i);
          if (select_item.is_real_alias_)
          {
            ObSqlRawExpr *alias_expr = logical_plan->get_expr(select_item.expr_id_);
            if (alias_expr && alias_expr->is_columnlized() == false
                && table_bitset.is_superset(alias_expr->get_tables_set()))
            {
              ObSqlExpression output_expr;
              if ((ret = alias_expr->fill_sql_expression(
                     output_expr,
                     this,
                     logical_plan,
                     physical_plan)) != OB_SUCCESS)
              {
                TRANS_LOG("Add table output columns faild");
                break;
              }
              else
              {
                project_array.push_back(output_expr);
              }
              //add fanqiushi_index
              // YYSYS_LOG(ERROR,"test::fanqs,,,output_expr=%s",to_cstring(output_expr));
              //add:e
              alias_exprs.push_back(select_item.expr_id_);
              alias_expr->set_columnlized(true);
            }
            else if (alias_expr && alias_expr->is_columnlized() == true
                     && alias_expr->get_expr()->is_column()
                     && table_bitset.is_superset(alias_expr->get_tables_set()))
            {
              ObSqlExpression output_expr;
              if ((ret = alias_expr->fill_sql_expression(
                     output_expr,
                     this,
                     logical_plan,
                     physical_plan)) != OB_SUCCESS)
              {
                TRANS_LOG("Add table output columns faild");
                break;
              }
              else
              {
                project_array.push_back(output_expr);
              }
            }
          }
        }
        //add liumz, [optimize group_order by index]20170419:b
        num = select_stmt->get_order_item_size();
        for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
        {
          const OrderItem& order_item = select_stmt->get_order_item(i);
          ObSqlRawExpr *order_expr = logical_plan->get_expr(order_item.expr_id_);
          //put all order items into order_array without concerning table_bitset
          if (order_expr)
          {
            ObSqlExpression output_expr;
            if ((ret = order_expr->fill_sql_expression(
                   output_expr,
                   this,
                   logical_plan,
                   physical_plan)) != OB_SUCCESS)
            {
              TRANS_LOG("Add table output columns faild");
              break;
            }
            else
            {
              order_array.push_back(output_expr);
            }
          }
        }//end for
        num = select_stmt->get_group_expr_size();
        for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
        {
          uint64_t expr_id = select_stmt->get_group_expr_id(i);
          ObSqlRawExpr* group_expr = logical_plan->get_expr(expr_id);
          //put all group expr into order_array without concerning table_bitset
          if (group_expr)
          {
            ObSqlExpression output_expr;
            if ((ret = group_expr->fill_sql_expression(
                   output_expr,
                   this,
                   logical_plan,
                   physical_plan)) != OB_SUCCESS)
            {
              TRANS_LOG("Add table output columns faild");
              break;
            }
            else
            {
              group_array.push_back(output_expr);
            }
          }
        }//end for
        //add:e
      }
    }
    if(OB_SUCCESS == ret)
    {
      bool is_use_hint=false;    //�ж��Ƿ�ʹ���û������hint
      uint64_t hint_tid=OB_INVALID_ID;     //�û������hint�е���������tid
      bool use_hint_for_storing=false;     //�ж�hint�е��������ܷ�ʹ�ò��ر�������
      bool use_hint_without_storing=false;  //�ж�hint�е��������ܷ�ʹ�ûر�������

      bool is_use_storing_column=false;   //���յ�: �ж��Ƿ�ʹ�ò��ر��������ı��� //repaired from messy code by zhuxh 20151014
      bool is_use_index_without_storing=false;  //���յ�: �ж��Ƿ�ʹ�ûر��������ı���
      uint64_t index_id=OB_INVALID_ID;       //���յ�: ����ò��ر�����������������tid
      uint64_t index_id_without_storing=OB_INVALID_ID;  //���յ�: ����ûر�����������������tid

      if(stmt->get_query_hint().has_index_hint())
      {
        for(int i=0;i<stmt->get_query_hint().use_index_array_.size();i++)//add by wanglei [semi join] 20151231 for many index hint
        {
          ObIndexTableNamePair tmp=stmt->get_query_hint().use_index_array_.at(i);
          //ObIndexTableNamePair tmp=stmt->get_query_hint().use_index_array_.at(0);

          hint_tid=tmp.index_table_id_;
          //YYSYS_LOG(ERROR,"test::fanqs,,tmp.src_table_id_=%ld,,table_item->ref_id_=%ld",tmp.src_table_id_,table_item->ref_id_);
          if(tmp.src_table_id_ == table_item->ref_id_)
          {
            is_use_hint=true;
            use_hint_for_storing = is_can_use_hint_for_storing_V2(&filter_array,&project_array,tmp.index_table_id_,&join_column,stmt);//add wanglei [semi join ] &join_column,stmt //�ж�hint�е��������ܷ�ʹ�ò��ر��������ĺ���
            //YYSYS_LOG(ERROR,"test::fanqs,,use_hint_for_storing=%d",use_hint_for_storing);
            if(!use_hint_for_storing)
              use_hint_without_storing=is_can_use_hint_index_V2(&filter_array,tmp.index_table_id_,&join_column,stmt);//add wanglei [semi join ] &join_column,stmt // �ж�hint�е��������ܷ�ʹ�ûر��������ĺ���
            break;
          }

        }
        if(use_hint_for_storing==false&&use_hint_without_storing==false)
        {
          is_use_hint=false;
        }
      }
      if(!is_use_hint)      //���û��hint
      {
        is_use_storing_column=decide_is_use_storing_or_not_V2(&filter_array,
                                                              &project_array,
                                                              index_id,
                                                              table_item->ref_id_,
                                                              &join_column,
                                                              stmt,
                                                              logical_plan,
                                                              &order_array,
                                                              &group_array);   //add wanglei [semi join ] &join_column,stmt //����û�û������hint�����ݼ򵥵Ĺ����ж��Ƿ��ܹ�ʹ�ò��ر�������
        bool is_max_min_eliminate = sel_stmt->is_max_min_eliminate();
        if (!is_use_storing_column && is_max_min_eliminate)
        {
          uint64_t tid = table_item->ref_id_;
          uint64_t column_id = sel_stmt->get_eliminate_index_col_id();
          const ObTableSchema *mian_table_schema = NULL;
          if (NULL == (mian_table_schema = sql_context_->schema_manager_->get_table_schema(tid)))
          {
            YYSYS_LOG(WARN, "Fail to get table schema for table[%ld]",table_item->ref_id_);
          }
          else
          {
            const ObRowkeyInfo *rowkey_info = &mian_table_schema->get_rowkey_info();
            if (!rowkey_info->is_rowkey_column(column_id))
            {
              uint64_t tmp_index_tid[OB_MAX_INDEX_NUMS];
              for (int32_t m = 0; m < OB_MAX_INDEX_NUMS; m++)
              {
                tmp_index_tid[m] = OB_INVALID_ID;
              }
              if (sql_context_->schema_manager_->is_cid_in_index(column_id, tid, tmp_index_tid))
              {
                index_id_without_storing = tmp_index_tid[0];
                is_use_index_without_storing = true;
              }
            }
            else
            {
              YYSYS_LOG(DEBUG, "max_min_eliminate rowkey choose origin table");
            }
          }
        }
        if(!is_use_storing_column && !is_max_min_eliminate)  //�������ʹ�ò��ر������������ж��Ƿ���ʹ�ûر�������
        {
          //YYSYS_LOG(ERROR,"test::fanqs,,enter this 991,from_item.table_id_=%lu",from_item.table_id_);
          const ObTableSchema *mian_table_schema = NULL;
          if (NULL == (mian_table_schema = sql_context_->schema_manager_->get_table_schema(table_item->ref_id_)))
          {
            YYSYS_LOG(WARN,"Fail to get table schema for table[%ld]",table_item->ref_id_);
          }
          else
          {
            const ObRowkeyInfo *rowkey_info = &mian_table_schema->get_rowkey_info();
            uint64_t main_cid=OB_INVALID_ID;
            rowkey_info->get_column_id(0,main_cid);
            if(!is_wherecondition_have_main_cid_V2(&filter_array,main_cid))
            {
              //add by wanglei [semi join] 20151231:b
              //�ж��ұ��Ƿ��п��õ�����,���hint����semi join��ִ��
              bool is_semi_join =false;
              if(stmt ==NULL)
              {
                ret = OB_ERR_POINTER_IS_NULL;
                YYSYS_LOG(WARN,"[semi join] stmt is null!");
              }
              else  if(stmt->get_query_hint().join_array_.size()>0)
              {
                ObJoinTypeArray tmp_join_type = stmt->get_query_hint().join_array_.at(0);
                if(tmp_join_type.join_type_ == T_SEMI_JOIN ||tmp_join_type.join_type_ == T_SEMI_BTW_JOIN)
                {
                  //mod dragon [SEMI JOIN] 2016-10-21
                  //ԭ��������������������ж��Ƿ�ʹ�ò��ر�������
                  if(0 != join_column.count())
                  {
                    is_semi_join = true;
                  }
                  //below is original code
                  //is_semi_join = true;
                  //mod e
                  for(int l=0;l<join_column.count();l++)
                  {
                    uint64_t tmp_cid = join_column.at(l);
                    if(is_this_expr_can_use_index_for_join(tmp_cid,index_id_without_storing,table_item->ref_id_,sql_context_->schema_manager_))
                    {
                      //YYSYS_LOG(WARN,"wl is_this_expr_can_use_index_for_join");
                      is_use_index_without_storing=true;
                      break;
                    }
                  }
                }
              }
              //add:e
              int64_t c_num=filter_array.count();
              if(is_semi_join) //�����semi joinʱ�ж���ʹ����������ô�Ͳ������ж�where���Ƿ��з�������������
              {
                //��˵�����������ר������semi join�Ĺ���ʹ�õģ�������join����£����where��û�����ű��Ĺ�������
                //�ǻᱨ���ġ�
              }
              else
              {
                //add liumz, [optimize group_order by index]20170419:b
                bool index_group = false;
                bool index_order = false;
                uint64_t index_group_table_id = OB_INVALID_ID;
                uint64_t index_order_table_id = OB_INVALID_ID;
                ObArray<uint64_t> idx_tids;
                //add:e
                for(int32_t j=0;j<c_num;j++)
                {
                  ObSqlExpression c_filter=filter_array.at(j);
                  if(c_filter.is_this_expr_can_use_index(index_id_without_storing,table_item->ref_id_,sql_context_->schema_manager_))
                  {
                    //mod liumz, [optimize group_order by index]20170419:b
                    idx_tids.push_back(index_id_without_storing);
                    is_use_index_without_storing=true;
                    //break;
                    //mod:e
                  }
                }
                //add liumz, [optimize group_order by index]20170419:b
                if (is_use_index_without_storing && idx_tids.count() > 0)
                {
                  index_id_without_storing = idx_tids.at(0);//pick the first index table, default
                  index_group_table_id = idx_tids.at(0);//pick the first index table, default
                  index_order_table_id = idx_tids.at(0);//pick the first index table, default
                  if (group_array.count() > 0 && OB_SUCCESS != (ret = optimize_group_by_index(idx_tids, table_item->ref_id_, index_group_table_id, index_group, stmt, logical_plan)))
                  {
                    YYSYS_LOG(WARN, "optimize_order_by_index failed, ret = %d", ret);
                  }
                  if (OB_SUCCESS == ret && order_array.count() > 0)
                  {
                    if (index_group)
                    {
                      idx_tids.clear();
                      idx_tids.push_back(index_group_table_id);
                    }
                    if ((index_group || 0 == group_array.count())
                        && OB_SUCCESS != (ret = optimize_order_by_index(idx_tids, table_item->ref_id_, index_order_table_id, index_order, stmt, logical_plan)))
                    {
                      YYSYS_LOG(WARN, "optimize_order_by_index failed, ret = %d", ret);
                    }
                  }
                }
                else
                {
                  if (group_array.count() > 0)
                  {
                    idx_tids.clear();
                    ObSqlExpression c_filter = group_array.at(0);
                    if(c_filter.is_this_expr_can_use_index(index_id_without_storing,table_item->ref_id_,sql_context_->schema_manager_))
                    {
                      idx_tids.push_back(index_id_without_storing);
                      if (OB_SUCCESS != (ret = optimize_group_by_index(idx_tids, table_item->ref_id_, index_group_table_id, index_group, stmt, logical_plan)))
                      {
                        YYSYS_LOG(WARN, "optimize_order_by_index failed, ret = %d", ret);
                      }
                    }
                  }
                  if (OB_SUCCESS == ret && order_array.count() > 0)
                  {

                    idx_tids.clear();
                    if (index_group)
                    {
                      idx_tids.push_back(index_group_table_id);
                      if (OB_SUCCESS != (ret = optimize_order_by_index(idx_tids, table_item->ref_id_, index_order_table_id, index_order, stmt, logical_plan)))
                      {
                        YYSYS_LOG(WARN, "optimize_order_by_index failed, ret = %d", ret);
                      }
                    }
                    else if (0 == group_array.count())
                    {
                      ObSqlExpression c_filter = order_array.at(0);
                      if(c_filter.is_this_expr_can_use_index(index_id_without_storing,table_item->ref_id_,sql_context_->schema_manager_))
                      {
                        idx_tids.push_back(index_id_without_storing);
                        if (OB_SUCCESS != (ret = optimize_order_by_index(idx_tids, table_item->ref_id_, index_order_table_id, index_order, stmt, logical_plan)))
                        {
                          YYSYS_LOG(WARN, "optimize_order_by_index failed, ret = %d", ret);
                        }
                      }
                    }
                  }
                  if (OB_SUCCESS == ret && !index_group && !index_order)
                  {
                    uint64_t unused_idx_tid = OB_INVALID_ID;
                    bool unused_ret = false;
                    idx_tids.clear();
                    idx_tids.push_back(table_item->ref_id_);
                    if (group_array.count() > 0 && OB_SUCCESS != (ret = optimize_group_by_index(idx_tids, table_item->ref_id_, unused_idx_tid, unused_ret, stmt, logical_plan)))
                    {
                      YYSYS_LOG(WARN, "optimize_group_by_index failed, ret = %d", ret);
                    }
                    if (OB_SUCCESS == ret && (unused_ret || 0 == group_array.count()) && order_array.count() > 0
                        && OB_SUCCESS != (ret = optimize_order_by_index(idx_tids, table_item->ref_id_, unused_idx_tid, unused_ret, stmt, logical_plan)))
                    {
                      YYSYS_LOG(WARN, "optimize_order_by_index failed, ret = %d", ret);
                    }
                  }
                }
                //set return_ret & index_table_id
                if (index_group)
                {
                  is_use_index_without_storing = index_group;
                  index_id_without_storing = index_group_table_id;
                }
                else if (index_order)
                {
                  is_use_index_without_storing = index_order;
                  index_id_without_storing = index_order_table_id;
                }
                //add liumz, [optimize group_order by index]20170419:e
              }
            }
            //add by wanglei [semi join] 20151231:b
            else
            {
              if(stmt ==NULL)
              {
                ret = OB_ERR_POINTER_IS_NULL;
                YYSYS_LOG(WARN,"[semi join] stmt is null!");
              }
              else if(stmt->get_query_hint().join_array_.size()>0)
              {
                ObJoinTypeArray tmp_join_type = stmt->get_query_hint().join_array_.at(0);
                if(tmp_join_type.join_type_ == T_SEMI_JOIN ||tmp_join_type.join_type_ == T_SEMI_BTW_JOIN)
                {
                  for(int l=0;l<join_column.count();l++)
                  {
                    uint64_t tmp_cid = join_column.at(l);
                    if(is_this_expr_can_use_index_for_join(tmp_cid,index_id_without_storing,table_item->ref_id_,sql_context_->schema_manager_))
                    {
                      //YYSYS_LOG(WARN,"wl is_this_expr_can_use_index_for_join");
                      is_use_index_without_storing=true;
                    }
                  }
                }
              }
              //add liumz, [optimize group_order by index]20170419:b
              if (!is_use_index_without_storing)
              {
                uint64_t unused_idx_tid = OB_INVALID_ID;
                bool unused_ret = false;
                ObArray<uint64_t> idx_tids;
                idx_tids.push_back(table_item->ref_id_);
                if (group_array.count() > 0 && OB_SUCCESS != (ret = optimize_group_by_index(idx_tids, table_item->ref_id_, unused_idx_tid, unused_ret, stmt, logical_plan)))
                {
                  YYSYS_LOG(WARN, "optimize_group_by_index failed, ret = %d", ret);
                }
                if (OB_SUCCESS == ret && (unused_ret || 0 == group_array.count()) && order_array.count() > 0
                    && OB_SUCCESS != (ret = optimize_order_by_index(idx_tids, table_item->ref_id_, unused_idx_tid, unused_ret, stmt, logical_plan)))
                {
                  YYSYS_LOG(WARN, "optimize_order_by_index failed, ret = %d", ret);
                }
              }
              //add liumz, [optimize group_order by index]20170419:e
            }
            //add:e
          }
          //YYSYS_LOG(ERROR,"test::fanqs,,is_use_index_without_storing=%d",is_use_index_without_storing);
        }
      }
      else   //����û�ʹ����hint�����ݽ����Ĳ����ж���ʹ�ûر��Ļ��ǲ��ر������� //repaired from messy code by zhuxh 20151014
      {
        if(use_hint_for_storing)
        {
          is_use_storing_column=true;
          index_id=hint_tid;
          //return_ret=true;
        }
        else if(use_hint_without_storing)
        {
          is_use_index_without_storing=true;
          index_id_without_storing=hint_tid;

        }
      }
      if(is_use_storing_column==true||is_use_index_without_storing==true)
        return_ret=true;
      // YYSYS_LOG(ERROR,"test::fanqs,,is_use_storing_column=%d,is_use_index_without_storing=%d,,hint_tid=%ld",is_use_storing_column,is_use_index_without_storing,hint_tid);
      bool group_down=false;
      bool limit_down=false;

      //add fanqiushi_index_in
      int64_t sub_query_num=0;
      int64_t num = 0;
      num = filter_array.count();
      for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
      {
        sub_query_num = sub_query_num + filter_array.at(i).get_sub_query_num();
      }
      if(OB_SUCCESS == ret && sub_query_num==0)
      {
        if(is_use_storing_column)
        {
          ret = gen_phy_table_for_storing(
                  logical_plan,
                  physical_plan,
                  err_stat,
                  stmt,
                  table_id,
                  table_op,
                  &group_down,
                  &limit_down,
                  is_use_storing_column,
                  index_id,
                  &filter_array,
                  &project_array
                  );

        }
        else if(is_use_index_without_storing)
        {


          ret = gen_phy_table_without_storing(
                  logical_plan,
                  physical_plan,
                  err_stat,
                  stmt,
                  table_id,
                  table_op,
                  &group_down,
                  &limit_down,
                  //is_use_storing_column,
                  index_id_without_storing,
                  &filter_array,
                  &project_array,
                  &join_column //add by wanglei [semi join second index] 20151231
                  );

        }
        //add liumz, [bugfix_limit_push_down]20160822:b
        if (group_agg_pushed_down)
          *group_agg_pushed_down = group_down;//add liumz, [optimize group_order by index]20170419
        if (limit_pushed_down)
          *limit_pushed_down = limit_down;
        //add:e
      }
      else
        return_ret=false;
      //add:e

      if(OB_SUCCESS!=ret)
        return_ret=false;

      if((is_use_index_without_storing == false && is_use_storing_column == false)||(OB_SUCCESS!=ret)||!return_ret)  //�����������������Ҫ����Ӧ��alias�ĳ�ԭ��������gen_phy_table�ڴ���û������������²Ų��ᱨ��
      {
        for(int32_t i=0;i<alias_exprs.count();i++)
        {
          ObSqlRawExpr *alias_expr = logical_plan->get_expr(alias_exprs.at(i));
          if (alias_expr)
          {
            //add fanqiushi_index
            // YYSYS_LOG(ERROR,"test::fanqs,,,alias_expr->set_columnlized(false)");
            //add:e
            alias_expr->set_columnlized(false);
          }
        }
      }
    }
    //add BUG
    if(OB_SUCCESS !=  ret && is_gen_table==true)
      ret=OB_SUCCESS;
    //add:e
  }
  //add wenghaixing [secondary index]20150909 fix memory overflow bug
  for (int64_t i = 0; i < fp_array.count();i++)
  {
    ObSqlExpression* filter = fp_array.at(i);
    if(NULL != filter)
    {
      ObSqlExpression::free(filter);
    }
  }
  //add e
  //add wanglei [semi join]:b
  join_column.clear();
  //add e
  return return_ret;
}
//add:e
int ObTransformer::gen_phy_table(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObStmt *stmt,
    uint64_t table_id,
    ObPhyOperator*& table_op,
    bool* group_agg_pushed_down,
    bool* limit_pushed_down, ObPhyOperator *sequence_op//add liuzy [sequence select] 20150525:", ObPhyOperator *sequence_op"
    , bool outer_join_scope,//add liumz, [outer_join_on_where]20150927
    bool optimizer_open
    )
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  //add fanqiushi_index
  bool handle_index_ret=false;
  ObPhyOperator* tmp_table_op=NULL;
  handle_index_ret=handle_index_for_one_table(logical_plan,physical_plan,err_stat,stmt,table_id,tmp_table_op,sequence_op,group_agg_pushed_down,limit_pushed_down,outer_join_scope,optimizer_open);
  //add:e
  if(!handle_index_ret)   //add fanqiushi_index
  {
    TableItem* table_item = NULL;
    ObSqlReadStrategy sql_read_strategy;
    ObBitSet<> table_bitset;
    int32_t num = 0;
    int64_t sub_query_num = 0;//add tianz [SubQuery_for_Instmt] [JHOBv0.1] 20140528
    /*Exp:used for count the num of sub_query,if main query has sub_query, alter physical plan*/
    if (table_id == OB_INVALID_ID || (table_item = stmt->get_table_item_by_id(table_id)) == NULL)
    {
      ret = OB_ERR_ILLEGAL_ID;
      TRANS_LOG("Wrong table id");
    }

    ObRpcScanHint hint;
    //del dyr [From_MaxTmpTable_BugFix] [JHOBv0.1] 20140807:b
    /**���ⲿ�ִ����ƶ�����case TableItem::ALIAS_TABLE֮��
    ���from�Ӿ����Ӳ�ѯ����ʱ��Fail to get table schema for table�Ĵ���**/
    //  if (OB_SUCCESS == ret)
    //  {
    //    const ObTableSchema *table_schema = NULL;
    //    if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_item->ref_id_)))
    //    {
    //      ret = OB_ERROR;
    //      TRANS_LOG("Fail to get table schema for table[%ld]", table_item->ref_id_);
    //    }
    //    else
    //    {
    //      if (stmt->get_query_hint().read_consistency_ != NO_CONSISTENCY)
    //      {
    //        hint.read_consistency_ = stmt->get_query_hint().read_consistency_;
    //      }
    //      else
    //      {
    //        // no hint
    //        // ����Ҫ��041���ݣ�Ŀǰ����consistency_level��ʹ��is_merge_dynamic_data //repaired from messy code by zhuxh 20151014
    //        //hint.read_consistency_ = table_schema->get_consistency_level();
    //        if (table_schema->is_merge_dynamic_data())
    //        {
    //          hint.read_consistency_ = NO_CONSISTENCY;
    //        }
    //        else
    //        {
    //          hint.read_consistency_ = STATIC;
    //        }
    //        if (hint.read_consistency_ == NO_CONSISTENCY)
    //        {
    //          ObString name = ObString::make_string(OB_READ_CONSISTENCY);
    //          ObObj value;
    //          int64_t read_consistency_level_val = 0;
    //          hint.read_consistency_ = common::STRONG;
    //          if (OB_SUCCESS != (ret = sql_context_->session_info_->get_sys_variable_value(name, value)))
    //          {
    //            YYSYS_LOG(WARN, "get system variable %.*s failed, ret=%d", name.length(), name.ptr(), ret);
    //            ret = OB_SUCCESS;
    //          }
    //          else if (OB_SUCCESS != (ret = value.get_int(read_consistency_level_val)))
    //          {
    //            YYSYS_LOG(WARN, "get int failed, ret=%d", ret);
    //            ret = OB_SUCCESS;
    //          }
    //          else
    //          {
    //            hint.read_consistency_ = static_cast<ObConsistencyLevel>(read_consistency_level_val);
    //          }
    //        }
    //      }
    //    }
    //  }
    //del 20140807:e
    //add liuzy [sequence select] 20150616:b
    ObSequenceSelect *sequence_select_op = NULL;
    if (sequence_op != NULL)
    {
      sequence_select_op = dynamic_cast<ObSequenceSelect *>(sequence_op);
    }
    //20150616:e
    ObTableScan *table_scan_op = NULL;
    if (ret == OB_SUCCESS)
    {
      switch (table_item->type_)
      {
        case TableItem::BASE_TABLE:
          /* get through */
        case TableItem::ALIAS_TABLE:
        {
          //add dyr [From_MaxTmpTable_BugFix] [JHOBv0.1] 20140807:b
          if (OB_SUCCESS == ret)
          {
            const ObTableSchema *table_schema = NULL;
            if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_item->ref_id_)))
            {
              ret = OB_ERROR;
              TRANS_LOG("Fail to get table schema for table[%ld]", table_item->ref_id_);
            }
            else
            {
              //add duyr [MultiUPS] [READ_ATOMIC] [read_part] 20151224:b
              if (stmt->get_query_hint().read_atomic_level_ != NO_READ_ATOMIC_LEVEL)
              {
                hint.read_atomic_level_ = stmt->get_query_hint().read_atomic_level_;
                if (stmt->get_query_hint().read_atomic_level_ == READ_ATOMIC_WEAK)
                {
                  hint.read_atomic_weak_time_limit_ = stmt->get_query_hint().read_atomic_weak_time_limit_;
                }
              }
              //add duyr 20151224:e

              if (stmt->get_query_hint().read_consistency_ != NO_CONSISTENCY)
              {
                hint.read_consistency_ = stmt->get_query_hint().read_consistency_;
              }
              else
              {
                // no hint
                // ��������һ���Լ���������Ҫ��041���ݣ�Ŀǰ����consistency_level��ʹ��is_merge_dynamic_data
                //hint.read_consistency_ = table_schema->get_consistency_level();
                if (table_schema->is_merge_dynamic_data())
                {
                  hint.read_consistency_ = NO_CONSISTENCY;
                }
                else
                {
                  hint.read_consistency_ = STATIC;
                }
                if (hint.read_consistency_ == NO_CONSISTENCY)
                {
                  ObString name = ObString::make_string(OB_READ_CONSISTENCY);
                  ObObj value;
                  int64_t read_consistency_level_val = 0;
                  hint.read_consistency_ = common::STRONG;
                  if (OB_SUCCESS != (ret = sql_context_->session_info_->get_sys_variable_value(name, value)))
                  {
                    YYSYS_LOG(WARN, "get system variable %.*s failed, ret=%d", name.length(), name.ptr(), ret);
                    ret = OB_SUCCESS;
                  }
                  else if (OB_SUCCESS != (ret = value.get_int(read_consistency_level_val)))
                  {
                    YYSYS_LOG(WARN, "get int failed, ret=%d", ret);
                    ret = OB_SUCCESS;
                  }
                  else
                  {
                    hint.read_consistency_ = static_cast<ObConsistencyLevel>(read_consistency_level_val);
                  }
                  //add pangtianze [Paxos strong_consistency_read] 20170825:b
                  if (sql_context_->merge_service_->get_config().using_strong_consistency)
                  {
                    hint.read_consistency_ = common::STRONG;
                  }
                  //add:e
                }
              }
            }
          }
          //add 20140807:e
          ObTableRpcScan *table_rpc_scan_op = NULL;
          CREATE_PHY_OPERRATOR(table_rpc_scan_op, ObTableRpcScan, physical_plan, err_stat);
          if (ret == OB_SUCCESS
              && (ret = table_rpc_scan_op->set_table(table_item->table_id_, table_item->ref_id_)) != OB_SUCCESS)
          {
            TRANS_LOG("ObTableRpcScan set table faild");
          }
          //add fanqiushi_index
          //YYSYS_LOG(ERROR,"test::fanqs,,table_item->table_id_=%ld,,table_item->ref_id_=%ld",table_item->table_id_,table_item->ref_id_);
          //add:e
          /// determin request type: scan/get
          if (ret == OB_SUCCESS)
          {
            int32_t bit_index = stmt->get_table_bit_index(table_item->table_id_);
            table_bitset.add_member(bit_index);
            if (bit_index < 0)
            {
              YYSYS_LOG(ERROR, "negative bitmap values,table_id=%ld" ,table_item->table_id_);
            }
          }
          if (OB_SUCCESS == ret)
          {
            const ObTableSchema *table_schema = NULL;
            if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_item->ref_id_)))
            {
              ret = OB_ERROR;
              TRANS_LOG("Fail to get table schema for table[%ld]", table_item->ref_id_);
            }
            else
            {
              sql_read_strategy.set_rowkey_info(table_schema->get_rowkey_info());
              if ((ret = physical_plan->add_base_table_version(
                     table_item->ref_id_,
                     table_schema->get_schema_version()
                     )) != OB_SUCCESS)
              {
                TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d", table_item->ref_id_, ret);
              }
            }
          }
          //add liuzy [sequence select]20150616:b
          if (NULL != sequence_select_op)
          {
            ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
            sequence_select_op->reset_sequence_names_idx(select_stmt->get_column_has_sequene_count());
          }
          //add 20150616:e
          num = stmt->get_condition_size();
          for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
          {
            ObSqlRawExpr *cnd_expr = logical_plan->get_expr(stmt->get_condition_id(i));
            if (cnd_expr && table_bitset.is_superset(cnd_expr->get_tables_set()))
            {
              if (!outer_join_scope)//add liumz, [outer_join_on_where]20150927
              {
                cnd_expr->set_applied(true);
              }

              //add duyr [join_without_pushdown_is_null] 20151214:b
              if (outer_join_scope && !cnd_expr->can_push_down_with_outerjoin())
              {
                continue;
              }
              //add duyr 20151214:e

              ObSqlExpression filter;
              if ((ret = cnd_expr->fill_sql_expression(filter, this, logical_plan, physical_plan)) != OB_SUCCESS)
              {
                TRANS_LOG("Add table filter condition faild");
                break;
              }
              //add liuzy [sequence select] 20150515:b
              if (OB_SUCCESS == ret && NULL != sequence_select_op)
              {
                if(sequence_select_op->can_fill_sequence_info())
                {
                  uint64_t temp_id = stmt->get_condition_id(i);
                  if (sequence_select_op->is_sequence_cond_id(temp_id))
                  {
                    if (OB_SUCCESS != (ret = sequence_select_op->fill_the_sequence_info_to_cond_expr(&filter, OB_INVALID_ID)))
                    {
                      TRANS_LOG("Failed deal the sequence condition filter,err=%d",ret);
                      break;
                    }
                  }
                  else if (OB_SUCCESS != ret)
                  {
                    break;
                  }
                }
              }
              //20150515:e
              filter.set_owner_op(table_rpc_scan_op);
              if (OB_SUCCESS != (ret = sql_read_strategy.add_filter(filter)))
              {
                YYSYS_LOG(WARN, "fail to add filter:ret[%d]", ret);
                break;
              }
              // add by maosy [FIX_SUPPORT_READ_ATOMIC] 20170628:b
              //TODO ����һ�ֶ��Ӳ�ѯor�����Ӳ�ѯΪ�յ�ʱ�������⣬�������������Ϊ����ֹ�������
              else if(hint.read_atomic_level_ >= READ_ATOMIC_WEAK
                      &&(filter.get_sub_query_num() >= 1 && filter.get_expr_obj_size()>=20))
              {
                hint.read_atomic_level_= NO_READ_ATOMIC_LEVEL;
                hint.read_atomic_weak_time_limit_ =-1 ;
              }
              // add by  maosy e
            }
          }
          if ( OB_SUCCESS == ret)
          {
            int32_t read_method = ObSqlReadStrategy::USE_SCAN;
            // Determine Scan or Get?
            ObArray<ObRowkey> rowkey_array;
            // TODO: rowkey obj storage needed. varchar use orginal buffer, will be copied later
            PageArena<ObObj,ModulePageAllocator> rowkey_objs_allocator(
                  PageArena<ObObj, ModulePageAllocator>::DEFAULT_PAGE_SIZE,ModulePageAllocator(ObModIds::OB_SQL_TRANSFORMER));
            // ObObj rowkey_objs[OB_MAX_ROWKEY_COLUMN_NUMBER];

            if (OB_SUCCESS != (ret = sql_read_strategy.get_read_method(rowkey_array, rowkey_objs_allocator, read_method)))
            {
              YYSYS_LOG(WARN, "fail to get read method:ret[%d]", ret);
            }
            else
            {
              YYSYS_LOG(DEBUG, "use [%s] method", read_method == ObSqlReadStrategy::USE_SCAN ? "SCAN" : "GET");
            }
            hint.read_method_ = read_method;
          }

          if (ret == OB_SUCCESS)
          {
            ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
            if (select_stmt
                && select_stmt->get_group_expr_size() <= 0
                && select_stmt->get_having_expr_size() <= 0
                && select_stmt->get_order_item_size() <= 0
                && hint.read_method_ != ObSqlReadStrategy::USE_GET)
            {
              hint.max_parallel_count = 1;
            }
            if (select_stmt->get_from_item_size() > 0 && (select_stmt->get_table_id() == OB_ALL_SERVER_STAT_TID || select_stmt->get_table_id() == OB_ALL_SERVER_SESSION_TID))
            {
              hint.read_method_ = ObSqlReadStrategy::USE_SCAN;
            }
            if (select_stmt->get_has_range())
            {
              hint.read_method_ = ObSqlReadStrategy::USE_SCAN;
            }
            if ((ret = table_rpc_scan_op->init(sql_context_, &hint)) != OB_SUCCESS)
            {
              TRANS_LOG("ObTableRpcScan init faild");
            }
            //add liumz, [optimize group_order by index]20170419:b
            else
            {
              table_rpc_scan_op->set_indexed_group(select_stmt->is_indexed_group());
            }
            //add:e
            //add gaojt [ListAgg][JHOBv0.1]20150104:b
            /* Exp: if push down listagg,add the order column to table_rpc_scan */
            if(select_stmt->get_order_item_for_listagg_size()>0)
            {
              ObSqlRawExpr *order_expr;
              int32_t num = select_stmt->get_order_item_for_listagg_size();
              for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
              {
                const OrderItem& order_item = select_stmt->get_order_item_for_listagg(i);
                order_expr = logical_plan->get_expr(order_item.expr_id_);
                if (order_expr->get_expr()->is_const())
                {
                  // do nothing, const column is of no usage for sorting
                }
                else if (order_expr->get_expr()->get_expr_type() == T_REF_COLUMN)
                {
                  ObBinaryRefRawExpr *col_expr = dynamic_cast<ObBinaryRefRawExpr*>(order_expr->get_expr());
                  if ((ret = table_rpc_scan_op->add_sort_column_for_listagg(
                         col_expr->get_first_ref_id(),
                         col_expr->get_second_ref_id(),
                         order_item.order_type_ == OrderItem::ASC ? true : false
                         )) != OB_SUCCESS)
                  {
                    TRANS_LOG("Add sort column to table rpc scan failed");
                    break;
                  }
                }
                else
                {
                  ObSqlExpression col_expr;
                  if ((ret = order_expr->fill_sql_expression(
                         col_expr,
                         this,
                         logical_plan,
                         physical_plan)) != OB_SUCCESS)
                  {
                    TRANS_LOG("Add output column to project plan failed");
                    break;
                  }
                  else if ((ret = table_rpc_scan_op->add_sort_column_for_listagg(
                              order_expr->get_table_id(),
                              order_expr->get_column_id(),
                              order_item.order_type_ == OrderItem::ASC ? true : false
                              )) != OB_SUCCESS)
                  {
                    TRANS_LOG("Add sort column to table rpc scan failed");
                    break;
                  }
                }
              }
              if(OB_SUCCESS == ret)
              {
                table_rpc_scan_op->set_is_listagg(true);
              }
            }
          }
          //add 20150104:e
          if (ret == OB_SUCCESS)
            table_scan_op = table_rpc_scan_op;
          break;
        }
        case TableItem::GENERATED_TABLE:
        {
          ObTableMemScan *table_mem_scan_op = NULL;
          int32_t idx = OB_INVALID_INDEX;
          ret = gen_physical_select(logical_plan, physical_plan, err_stat, table_item->ref_id_, &idx, optimizer_open);
          if (ret == OB_SUCCESS)
            CREATE_PHY_OPERRATOR(table_mem_scan_op, ObTableMemScan, physical_plan, err_stat);
          // the sub-query's physical plan is set directly, so base_table_id is no need to set
          if (ret == OB_SUCCESS
              && (ret = table_mem_scan_op->set_table(table_item->table_id_, OB_INVALID_ID)) != OB_SUCCESS)
          {
            TRANS_LOG("ObTableMemScan set table faild,ret=%d",ret);
          }
          if (ret == OB_SUCCESS
              && (ret = table_mem_scan_op->set_child(0, *(physical_plan->get_phy_query(idx)))) != OB_SUCCESS)
          {
            TRANS_LOG("Set child of ObTableMemScan operator faild,ret=%d",ret);
          }
          if (ret == OB_SUCCESS)
          {
            int32_t bit_index = stmt->get_table_bit_index(table_item->table_id_);
            table_bitset.add_member(bit_index);
            if (bit_index < 0)
            {
              YYSYS_LOG(ERROR, "negative bitmap values,table_id=%ld" ,table_item->table_id_);
            }
          }
          if (ret == OB_SUCCESS)
            table_scan_op = table_mem_scan_op;
          break;
        }
        default:
          // won't be here
          OB_ASSERT(0);
          break;
      }
    }
    //add liuzy [sequence select]20150616:b
    if (NULL != sequence_select_op)
    {
      ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
      sequence_select_op->reset_sequence_names_idx(select_stmt->get_column_has_sequene_count());
    }
    //add 20150616:e
    num = stmt->get_condition_size();
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      ObSqlRawExpr *cnd_expr = logical_plan->get_expr(stmt->get_condition_id(i));
      if (cnd_expr && table_bitset.is_superset(cnd_expr->get_tables_set()))
      {
        if (!outer_join_scope)//add liumz, [outer_join_on_where]20150927
        {
          cnd_expr->set_applied(true);
        }

        //add duyr [join_without_pushdown_is_null] 20151214:b
        if (outer_join_scope && !cnd_expr->can_push_down_with_outerjoin())
        {
          continue;
        }
        //add duyr 20151214:e

        ObSqlExpression *filter = ObSqlExpression::alloc();
        if (NULL == filter)
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
          TRANS_LOG("no memory");
          break;
        }
        //mod liuzy [sequence select] 20150515:b
        else if ((ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan)) != OB_SUCCESS
                 /*Exp: before this statement, add "fill_the_sequence_info_to_cond_expr()"*/
                 //              || (ret = table_scan_op->add_filter(filter)) != OB_SUCCESS
                 )
        {
          TRANS_LOG("Add table filter condition faild");
          break;
        }
        //add liuzy [sequence select] 20150515:b
        else if (NULL != sequence_select_op
                 && sequence_select_op->can_fill_sequence_info()
                 && sequence_select_op->is_sequence_cond_id(stmt->get_condition_id(i))
                 && (OB_SUCCESS != (ret = sequence_select_op->fill_the_sequence_info_to_cond_expr(filter, OB_INVALID_ID))))
        {
          TRANS_LOG("Failed deal the sequence condition filter,err=%d",ret);
          break;
        }
        else if (OB_SUCCESS != ret)
        {
          break;
        }
        //add 20150515:e
        else if ((ret = table_scan_op->add_filter(filter)) != OB_SUCCESS)
        {
          TRANS_LOG("Add table filter condition faild");
          break;
        }
        //mod 20150515:e

        //add tianz [SubQuery_for_Instmt] [JHOBv0.1] 20140416:b
        /*Exp:add sub_query num of every filter expression together*/
        else
        {
          sub_query_num = sub_query_num + filter->get_sub_query_num();
        }
        //add 20140416:e
      }
    }

    // add output columns
    num = stmt->get_column_size();
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      const ColumnItem *col_item = stmt->get_column_item(i);
      if (col_item && col_item->table_id_ == table_item->table_id_)
      {
        ObBinaryRefRawExpr col_expr(col_item->table_id_, col_item->column_id_, T_REF_COLUMN);
        ObSqlRawExpr col_raw_expr(
              common::OB_INVALID_ID,
              col_item->table_id_,
              col_item->column_id_,
              &col_expr);
        ObSqlExpression output_expr;
        if ((ret = col_raw_expr.fill_sql_expression(
               output_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS
            || (ret = table_scan_op->add_output_column(output_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add table output columns faild");
          break;
        }
        //add fanqiushi_index
        // YYSYS_LOG(ERROR,"test::fanqs,,,output_expr=%s",to_cstring(output_expr));
        //add:e
      }
    }
    ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
    if (ret == OB_SUCCESS && select_stmt)
    {
      num = select_stmt->get_select_item_size();
      for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
      {
        const SelectItem& select_item = select_stmt->get_select_item(i);
        if (select_item.is_real_alias_)
        {
          //YYSYS_LOG(ERROR,"test::fanqs,,,select_item.is_real_alias_=ture");
          ObSqlRawExpr *alias_expr = logical_plan->get_expr(select_item.expr_id_);
          // YYSYS_LOG(ERROR,"test::fanqs,,,alias_expr->is_columnlized()=%d,table_bitset.is_superset(alias_expr->get_tables_set()=%d",alias_expr->is_columnlized(),table_bitset.is_superset(alias_expr->get_tables_set()));
          if (alias_expr && alias_expr->is_columnlized() == false
              && table_bitset.is_superset(alias_expr->get_tables_set()))
          {
            ObSqlExpression output_expr;
            if ((ret = alias_expr->fill_sql_expression(
                   output_expr,
                   this,
                   logical_plan,
                   physical_plan)) != OB_SUCCESS
                || (ret = table_scan_op->add_output_column(output_expr)) != OB_SUCCESS)
            {
              TRANS_LOG("Add table output columns faild");
              break;
            }
            //add fanqiushi_index
            //YYSYS_LOG(ERROR,"gen_phy_table:fanqs,,,output_expr=%s",to_cstring(output_expr));
            //add:e
            alias_expr->set_columnlized(true);
          }
          //add peiouya [BUG_FIX] 20151029:b
          //process the case:alias_expr not be added in output_column of subquery
          else if (alias_expr && alias_expr->is_columnlized() == true
                   && table_bitset.is_superset(alias_expr->get_tables_set()))
          {
            const ObRowDesc *row_desc = NULL;
            ObSqlExpression output_expr;
            // bool is_include_column = false;  //del peiouya [alias_expr_in_subquery_bug] 20160520
            if (OB_SUCCESS != (ret = alias_expr->fill_sql_expression(
                                 output_expr,
                                 this,
                                 logical_plan,
                                 physical_plan)))
            {
              TRANS_LOG("faild to fill alias_expr");
              break;
            }
            //del peiouya [alias_expr_in_subquery_bug] 20160520:e
            //ret = output_expr.is_column_index_expr(is_include_column);
            //is_include_column = true;
            //del peiouya [alias_expr_in_subquery_bug] 20160520:e
            if (OB_SUCCESS != ret)
            {
              TRANS_LOG("invalid expr");
              break;
            }
            //mod peiouya [alias_pushdown_bug] 20160525:b
            ////if output_expr doesn't contain "COLUMN_IDX", it cannot be processed at this step
            ////mod peiouya [alias_expr_in_subquery_bug] 20160520:b
            ////if (OB_INVALID_ID == output_expr.get_table_id() && !is_include_column)
            ////{
            ////    //NOTHING TODO
            ////}
            ////check output_expr has been added in table_scan_op. if false, add it to table_scan_op; if true, nothing todo
            ////else if (OB_SUCCESS == (ret = table_scan_op->get_row_desc(row_desc)))
            //if (OB_SUCCESS == (ret = table_scan_op->get_row_desc(row_desc)))
            ////mod peiouya [alias_expr_in_subquery_bug] 20160520:e
            if (!alias_expr->get_expr ()->is_column ())
            {
              //NOTHING TODO
            }
            else if (OB_SUCCESS == (ret = table_scan_op->get_row_desc(row_desc)))
              //mod peiouya [alias_pushdown_bug] 20160525:e
            {
              if (OB_INVALID_INDEX != row_desc->get_idx(output_expr.get_table_id(),output_expr.get_column_id()))
              {
                //NOTHING TODO
              }
              else if (OB_SUCCESS != (ret = table_scan_op->add_output_column(output_expr)))
              {
                TRANS_LOG("Add table output columns faild");
                break;
              }
              else
              {
                //NOTHING TODO
              }
            }
            //special process if none columns have been added in table_scan_op
            else
            {
              if (OB_SUCCESS != (ret = table_scan_op->add_output_column(output_expr)))
              {
                TRANS_LOG("Add table output columns faild");
                break;
              }
            }
          }
          //add end
        }
      }
    }

    if (ret == OB_SUCCESS)
      table_op = table_scan_op;

    bool group_down = false;
    bool limit_down = false;

    //mod tianz [SubQuery_for_Instmt] [JHOBv0.1] 20140516:b
    /*Exp: stmt which has sub_query do not push Aggregate Functions down,else client will get wrong result*/
    //if (hint.read_method_ == ObSqlReadStrategy::USE_SCAN)
    if ((hint.read_method_ == ObSqlReadStrategy::USE_SCAN)&& (0 ==sub_query_num))
      //mod 20140516:e
    {
      bool down_flag = true;
      if (select_stmt->get_from_item_size() > 0 && (select_stmt->get_table_id() == OB_ALL_SERVER_STAT_TID || select_stmt->get_table_id() == OB_ALL_SERVER_SESSION_TID))
      {
        down_flag = false;
      }
      /* Try to push down aggregations */
      if (ret == OB_SUCCESS && group_agg_push_down_param_ && select_stmt && down_flag)
      {
        ret = try_push_down_group_agg(
                logical_plan,
                physical_plan,
                err_stat,
                select_stmt,
                group_down,
                table_op);
        if (group_agg_pushed_down)
          *group_agg_pushed_down = group_down;
      }
      /* Try to push down limit */
      if (ret == OB_SUCCESS && select_stmt)
      {
        ret = try_push_down_limit(
                logical_plan,
                physical_plan,
                err_stat,
                select_stmt,
                limit_down,
                table_op);
        if (limit_pushed_down)
          *limit_pushed_down = limit_down;
      }
    }
    else
    {
      if (group_agg_pushed_down)
        *group_agg_pushed_down = false;
      if (limit_pushed_down)
        *limit_pushed_down = false;
    }
    //delete by xionghui [subquery_final] 20160216 b:
    /*
        //add zhujun [fix equal-subquery bug] 20151013:b
        //add a if-else branch to distinguish in-subquery and equal-subquery
        if(select_stmt->get_is_equal_subquery() && (sub_query_num>0))
        {
            ObMultiEqualBind *equal_bind_op = NULL;
            physical_plan->need_extend_time();
            int32_t main_query_idx= 0;
            if (CREATE_PHY_OPERRATOR(equal_bind_op, ObMultiEqualBind, physical_plan, err_stat) == NULL
                    || (ret = equal_bind_op->set_child(main_query_idx, *table_op)) != OB_SUCCESS)
            {
                TRANS_LOG("fail to set child:ret[%d]",ret);
            }
            else if (table_scan_op->is_base_table_id_valid())//mod zhaoqiong [TableMemScan_Subquery_BUGFIX] 20151118
            {
                ObTableRpcScan *table_rpc_scan_op = dynamic_cast<ObTableRpcScan *>( table_scan_op);
                equal_bind_op->set_table_id(table_id);
                if(NULL == table_rpc_scan_op )
                {
                    ret = OB_ERROR;
                    TRANS_LOG("wrong get table_rpc_scan_op, can't dynamic cast");
                }
                else
                {
                    //for one sub_query because equal need one subquery

                    for(int32_t sub_query_idx = 1;sub_query_idx<=sub_query_num;sub_query_idx++)
                    {
                        int32_t index = OB_INVALID_INDEX;
                        ObPhyOperator * sub_operator = NULL;
                        if((ret = table_rpc_scan_op->get_sub_query_index(sub_query_idx,index))!=OB_SUCCESS)
                        {
                            TRANS_LOG("wrong get sub query index");
                        }
                        else if(NULL == (sub_operator = physical_plan->get_phy_query(index)))
                        {
                            ret = OB_INVALID_INDEX;
                            TRANS_LOG("wrong get sub query operator");
                        }
                        else if(OB_SUCCESS != (ret = equal_bind_op->set_child(sub_query_idx, *sub_operator)))
                        {
                            TRANS_LOG("fail to set child:ret[%d]",ret);
                        }

                    }

                    //        int32_t sub_query_idx = 1;
                    //        int32_t index = OB_INVALID_INDEX;
                    //        ObPhyOperator * sub_operator = NULL;
                    //        if((ret = table_rpc_scan_op->get_sub_query_index(sub_query_idx,index))!=OB_SUCCESS)
                    //        {
                    //            TRANS_LOG("wrong get sub query index");
                    //        }
                    //        else if(NULL == (sub_operator = physical_plan->get_phy_query(index)))
                    //        {
                    //            ret = OB_INVALID_INDEX;
                    //            TRANS_LOG("wrong get sub query operator");
                    //        }
                    //        else if(OB_SUCCESS != (ret = equal_bind_op->set_child(sub_query_idx, *sub_operator)))
                    //        {
                    //            TRANS_LOG("fail to set child:ret[%d]",ret);
                    //        }
                }
            }

            //add zhaoqiong [TableMemScan_Subquery_BUGFIX] 20151118:b
            else
            {
                ObTableMemScan *table_mem_scan_op = dynamic_cast<ObTableMemScan *>( table_scan_op);
                equal_bind_op->set_table_id(table_id);
                if(NULL == table_mem_scan_op )
                {
                    ret = OB_ERROR;
                    TRANS_LOG("wrong get table_mem_scan_op, can't dynamic cast");
                }
                else
                {
                    //for one sub_query because equal need one subquery

                    for(int32_t sub_query_idx = 1;sub_query_idx<=sub_query_num;sub_query_idx++)
                    {
                        int32_t index = OB_INVALID_INDEX;
                        ObPhyOperator * sub_operator = NULL;
                        if((ret = table_mem_scan_op->get_sub_query_index(sub_query_idx,index))!=OB_SUCCESS)
                        {
                            TRANS_LOG("wrong get sub query index");
                        }
                        else if(NULL == (sub_operator = physical_plan->get_phy_query(index)))
                        {
                            ret = OB_INVALID_INDEX;
                            TRANS_LOG("wrong get sub query operator");
                        }
                        else if(OB_SUCCESS != (ret = equal_bind_op->set_child(sub_query_idx, *sub_operator)))
                        {
                            TRANS_LOG("fail to set child:ret[%d]",ret);
                        }

                    }
                }
            }
            //add:e
            //set equal_bind_op as top opertator


            if (ret == OB_SUCCESS)
                table_op = equal_bind_op;
        }
        //add xionghui [fix like-subquery bug] 20151015:b
        else if(select_stmt->get_is_like_subquery()&&(sub_query_num>0))
        {
            ObMultiLikeBind *like_bind_op = NULL;
            physical_plan->need_extend_time();
            int32_t main_query_idx= 0;
            if (CREATE_PHY_OPERRATOR(like_bind_op, ObMultiLikeBind, physical_plan, err_stat) == NULL
                    || (ret = like_bind_op->set_child(main_query_idx, *table_op)) != OB_SUCCESS)
            {
                TRANS_LOG("fail to set child:ret[%d]",ret);
            }
            else if (table_scan_op->is_base_table_id_valid())
            {
                ObTableRpcScan *table_rpc_scan_op = dynamic_cast<ObTableRpcScan *>( table_scan_op);
                like_bind_op->set_table_id(table_id);
                if(NULL == table_rpc_scan_op )
                {
                    ret = OB_ERROR;
                    TRANS_LOG("wrong get table_rpc_scan_op, can't dynamic cast");
                }
                else
                {
                    //for one sub_query because equal need one subquery

                    for(int32_t sub_query_idx = 1;sub_query_idx<=sub_query_num;sub_query_idx++)
                    {
                        int32_t index = OB_INVALID_INDEX;
                        ObPhyOperator * sub_operator = NULL;
                        if((ret = table_rpc_scan_op->get_sub_query_index(sub_query_idx,index))!=OB_SUCCESS)
                        {
                            TRANS_LOG("wrong get sub query index");
                        }
                        else if(NULL == (sub_operator = physical_plan->get_phy_query(index)))
                        {
                            ret = OB_INVALID_INDEX;
                            TRANS_LOG("wrong get sub query operator");
                        }
                        else if(OB_SUCCESS != (ret = like_bind_op->set_child(sub_query_idx, *sub_operator)))
                        {
                            TRANS_LOG("fail to set child:ret[%d]",ret);
                        }

                    }
                }
            }
            else
            {
                ObTableMemScan *table_mem_scan_op = dynamic_cast<ObTableMemScan *>( table_scan_op);
                like_bind_op->set_table_id(table_id);
                if(NULL == table_mem_scan_op )
                {
                    ret = OB_ERROR;
                    TRANS_LOG("wrong get table_mem_scan_op, can't dynamic cast");
                }
                else
                {
                    //for one sub_query because equal need one subquery

                    for(int32_t sub_query_idx = 1;sub_query_idx<=sub_query_num;sub_query_idx++)
                    {
                        int32_t index = OB_INVALID_INDEX;
                        ObPhyOperator * sub_operator = NULL;
                        if((ret = table_mem_scan_op->get_sub_query_index(sub_query_idx,index))!=OB_SUCCESS)
                        {
                            TRANS_LOG("wrong get sub query index");
                        }
                        else if(NULL == (sub_operator = physical_plan->get_phy_query(index)))
                        {
                            ret = OB_INVALID_INDEX;
                            TRANS_LOG("wrong get sub query operator");
                        }
                        else if(OB_SUCCESS != (ret = like_bind_op->set_child(sub_query_idx, *sub_operator)))
                        {
                            TRANS_LOG("fail to set child:ret[%d]",ret);
                        }

                    }
                }
            }
            //set like_bind_op as top opertator
            if (ret == OB_SUCCESS)
                table_op = like_bind_op;

        }
        else
        //add 20151015:e:
        */
    //delete e:

    //add tianz [SubQuery_for_Instmt] [JHOBv0.1] 20140416:b
    /*Exp:add new operator to physical plan,put ObTableRpcScan as main query,
    bind to ObMultiBind's children[0], bind other sub_query to ObMultiBind's later children*/
    ObMultiBind *multi_bind_op = NULL;
    if(ret == OB_SUCCESS && (sub_query_num>0))
    {
      physical_plan->need_extend_time();
      int32_t main_query_idx= 0;
      if (CREATE_PHY_OPERRATOR(multi_bind_op, ObMultiBind, physical_plan, err_stat) == NULL
          || (ret = multi_bind_op->set_child(main_query_idx, *table_op)) != OB_SUCCESS)
      {
        TRANS_LOG("fail to set child:ret[%d]",ret);
      }
      else if (table_scan_op->is_base_table_id_valid())
      {
        ObTableRpcScan *table_rpc_scan_op = dynamic_cast<ObTableRpcScan *>( table_scan_op);
        if(NULL == table_rpc_scan_op )
        {
          ret = OB_ERROR;
          TRANS_LOG("wrong get table_rpc_scan_op, can't dynamic cast");
        }
        else
        {
          //for every sub_query
          //1.get it's physical plan index from main query(ObTableRpcScan)
          //2.get it's top physical operator address from ObPhysicalPlan by it's physical plan index
          //3.bind it's top physical operator address to ObMultiBind
          for(int32_t sub_query_idx = 1;sub_query_idx<=sub_query_num;sub_query_idx++)
          {
            int32_t index = OB_INVALID_INDEX;
            ObPhyOperator * sub_operator = NULL;
            if((ret = table_rpc_scan_op->get_sub_query_index(sub_query_idx,index))!=OB_SUCCESS)
            {
              TRANS_LOG("wrong get sub query index");
            }
            else if(NULL == (sub_operator = physical_plan->get_phy_query(index)))
            {
              ret = OB_INVALID_INDEX;
              TRANS_LOG("wrong get sub query operator");
            }
            else if(OB_SUCCESS != (ret = multi_bind_op->set_child(sub_query_idx, *sub_operator)))
            {
              TRANS_LOG("fail to set child:ret[%d]",ret);
            }

          }
        }

      }
      else
      {
        ObTableMemScan *table_mem_scan_op = dynamic_cast<ObTableMemScan *>( table_scan_op);
        if(NULL == table_mem_scan_op )
        {
          ret = OB_ERROR;
          TRANS_LOG("wrong get table_mem_scan_op, can't dynamic cast");
        }
        else
        {
          //for every sub_query
          //1.get it's physical plan index from main query(ObTableRpcScan)
          //2.get it's top physical operator address from ObPhysicalPlan by it's physical plan index
          //3.bind it's top physical operator address to ObMultiBind
          for(int32_t sub_query_idx = 1;sub_query_idx<=sub_query_num;sub_query_idx++)
          {
            int32_t index = OB_INVALID_INDEX;
            ObPhyOperator * sub_operator = NULL;
            if((ret = table_mem_scan_op->get_sub_query_index(sub_query_idx,index))!=OB_SUCCESS)
            {
              TRANS_LOG("wrong get sub query index");
            }
            else if(NULL == (sub_operator = physical_plan->get_phy_query(index)))
            {
              ret = OB_INVALID_INDEX;
              TRANS_LOG("wrong get sub query operator");
            }
            else if(OB_SUCCESS != (ret = multi_bind_op->set_child(sub_query_idx, *sub_operator)))
            {
              TRANS_LOG("fail to set child:ret[%d]",ret);
            }

          }
        }

      }
      //set multi_bind_op as top opertator
      if (ret == OB_SUCCESS)
        table_op = multi_bind_op;
    }
    //add 20140416:e


  }
  else   //add fanqiushi_index
  {
    table_op = tmp_table_op;
    // YYSYS_LOG(ERROR,"test::fanqs,,enter this");
  }
  return ret;
}


int ObTransformer::try_push_down_group_agg(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const ObSelectStmt *select_stmt,
    bool& group_agg_pushed_down,
    ObPhyOperator *& scan_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObTableRpcScan *table_rpc_scan_op = dynamic_cast<ObTableRpcScan*>(scan_op);
  ObAddProject *project_op = NULL;

  if (table_rpc_scan_op == NULL)
  {
    // ignore
  }
  // 1. normal select statement, not UNION/EXCEPT/INTERSECT
  // 2. only one table, whose type is BASE_TABLE or ALIAS_TABLE
  // 3. can not be joined table.
  // 4. has group clause or aggregate function(s)
  // 6. no distinct aggregate function(s)
  else if (select_stmt->get_from_item_size() == 1
           && select_stmt->get_from_item(0).is_joined_ == false
           && select_stmt->get_table_size() == 1
           && (select_stmt->get_table_item(0).type_ == TableItem::BASE_TABLE
               || select_stmt->get_table_item(0).type_ == TableItem::ALIAS_TABLE)
           && (select_stmt->get_group_expr_size() > 0
               || select_stmt->get_agg_fun_size() > 0)
           //add duyr [MultiUPS] [READ_ATOMIC] [read_part] 20160115:b
           //TODO:we will support push down someday!
           && select_stmt->get_query_hint().read_atomic_level_ == NO_READ_ATOMIC_LEVEL
           //add duyr 20160115:e
           )
  {
    ObSqlRawExpr *expr = NULL;
    ObAggFunRawExpr *agg_expr = NULL;
    int32_t agg_num = select_stmt->get_agg_fun_size();
    for (int32_t i = 0; ret == OB_SUCCESS && i < agg_num; i++)
    {
      if ((expr = logical_plan->get_expr(select_stmt->get_agg_expr_id(i))) == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Wrong expression id of aggregate function");
        break;
      }
      else if ((agg_expr = dynamic_cast<ObAggFunRawExpr*>(expr->get_expr())) == NULL)
      {
        // agg(*), skip
        continue;
      }
      else if (agg_expr->is_param_distinct())
      {
        break;
      }
      else if (i == agg_num - 1)
      {
        group_agg_pushed_down = true;
      }
    }
  }

  // push down aggregate function(s)
  if (ret == OB_SUCCESS && group_agg_pushed_down)
  {
    // push down group column(s)
    ObSqlRawExpr *group_expr = NULL;
    int32_t num = select_stmt->get_group_expr_size();
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      if ((group_expr = logical_plan->get_expr(select_stmt->get_group_expr_id(i))) == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Wrong expression id  of group column");
      }
      else if (group_expr->get_expr()->get_expr_type() == T_REF_COLUMN)
      {
        ObBinaryRefRawExpr *col_expr = dynamic_cast<ObBinaryRefRawExpr*>(group_expr->get_expr());
        if ((ret = table_rpc_scan_op->add_group_column(
               col_expr->get_first_ref_id(),
               col_expr->get_second_ref_id())) != OB_SUCCESS)
        {
          TRANS_LOG("Add group column faild, table_id=%lu, column_id=%lu",
                    col_expr->get_first_ref_id(), col_expr->get_second_ref_id());
        }
      }
      else if (group_expr->get_expr()->is_const())
      {
        // do nothing, const column is of no usage for sorting
        continue;
      }
      else
      {
        ObSqlExpression col_expr;
        if ((ret = group_expr->fill_sql_expression(
               col_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS
            || (ret = table_rpc_scan_op->add_output_column(col_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add complex group column to project plan faild");
        }
        else if ((ret = table_rpc_scan_op->add_group_column(
                    group_expr->get_table_id(),
                    group_expr->get_column_id())) != OB_SUCCESS)
        {
          TRANS_LOG("Add group column to group plan faild");
        }
      }
    }

    // push down function(s)
    num = select_stmt->get_agg_fun_size();
    ObSqlRawExpr *agg_expr = NULL;
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      if ((agg_expr = logical_plan->get_expr(select_stmt->get_agg_expr_id(i))) == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Wrong expression id  of aggregate function");
        break;
      }
      else if (agg_expr->get_expr()->get_expr_type() ==  T_FUN_AVG)
      {
        // avg() ==> sum() / count()
        ObAggFunRawExpr *avg_expr = NULL;
        if ((avg_expr = dynamic_cast<ObAggFunRawExpr*>(agg_expr->get_expr())) == NULL)
        {
          ret = OB_ERR_RESOLVE_SQL;
          TRANS_LOG("Wrong aggregate function, exp_id = %lu", agg_expr->get_expr_id());
          break;
        }

        // add sum(), count() to TableRpcScan
        uint64_t table_id = agg_expr->get_table_id();
        uint64_t sum_cid = logical_plan->generate_range_column_id();
        uint64_t count_cid = logical_plan->generate_range_column_id();
        ObAggFunRawExpr sum_node;
        ObAggFunRawExpr count_node;
        sum_node.set_expr_type(T_FUN_SUM);
        sum_node.set_param_expr(avg_expr->get_param_expr());
        count_node.set_expr_type(T_FUN_COUNT);
        count_node.set_param_expr(avg_expr->get_param_expr());
        ObSqlRawExpr raw_sum_expr(OB_INVALID_ID, table_id, sum_cid, &sum_node);
        ObSqlRawExpr raw_count_expr(OB_INVALID_ID, table_id, count_cid, &count_node);
        ObSqlExpression sum_expr;
        ObSqlExpression count_expr;
        if ((ret = raw_sum_expr.fill_sql_expression(
               sum_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS
            || (ret = table_rpc_scan_op->add_aggr_column(sum_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add sum aggregate function failed, ret = %d", ret);
          break;
        }
        else if ((ret = raw_count_expr.fill_sql_expression(
                    count_expr,
                    this,
                    logical_plan,
                    physical_plan)) != OB_SUCCESS
                 || (ret = table_rpc_scan_op->add_aggr_column(count_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add count aggregate function failed, ret = %d", ret);
          break;
        }

        // add a '/' expression
        ObBinaryRefRawExpr sum_col_node(table_id, sum_cid, T_REF_COLUMN);
        ObBinaryRefRawExpr count_col_node(table_id, count_cid, T_REF_COLUMN);
        ObBinaryOpRawExpr div_node(&sum_col_node, &count_col_node, T_OP_DIV);
        ObSqlRawExpr div_raw_expr(OB_INVALID_ID, table_id, agg_expr->get_column_id(), &div_node);
        ObSqlExpression div_expr;
        if (project_op == NULL)
        {
          if (CREATE_PHY_OPERRATOR(project_op, ObAddProject, physical_plan, err_stat) == NULL
              || (ret = project_op->set_child(0, *table_rpc_scan_op)) != OB_SUCCESS)
          {
            TRANS_LOG("Add ObAddProject on ObTableRpcScan failed, ret = %d", ret);
            break;
          }
          else
          {
            scan_op = project_op;
          }
        }
        if ((ret = div_raw_expr.fill_sql_expression(div_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Generate div expr for avg() function failed, ret = %d", ret);
        }
        else if ((ret = project_op->add_output_column(div_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add column to ObAddProject operator failed, ret = %d", ret);
        }
      }
      else if (agg_expr->get_expr()->is_aggr_fun())
      {
        ObSqlExpression new_agg_expr;
        if ((ret = agg_expr->fill_sql_expression(
               new_agg_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS
            || (ret = table_rpc_scan_op->add_aggr_column(new_agg_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add aggregate function to group plan faild");
          break;
        }
      }
      else
      {
        ret = OB_ERR_RESOLVE_SQL;
        TRANS_LOG("Wrong aggregate function, exp_id = %lu", agg_expr->get_expr_id());
        break;
      }
      agg_expr->set_columnlized(true);
    }
  }
  return ret;
}
//add liumz, [optimize group_order by index]20170419:b
int ObTransformer::try_push_down_group_agg_for_storing(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const ObSelectStmt *select_stmt,
    bool& group_agg_pushed_down,
    ObPhyOperator *& scan_op,
    const uint64_t index_tid,
    bool is_ailias_table)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObTableRpcScan *table_rpc_scan_op = dynamic_cast<ObTableRpcScan*>(scan_op);
  ObAddProject *project_op = NULL;

  if (table_rpc_scan_op == NULL)
  {
    // ignore
  }
  // 1. normal select statement, not UNION/EXCEPT/INTERSECT
  // 2. only one table, whose type is BASE_TABLE or ALIAS_TABLE
  // 3. can not be joined table.
  // 4. has group clause or aggregate function(s)
  // 6. no distinct aggregate function(s)
  else if (select_stmt->get_from_item_size() == 1
           && select_stmt->get_from_item(0).is_joined_ == false
           && select_stmt->get_table_size() == 1
           && (select_stmt->get_table_item(0).type_ == TableItem::BASE_TABLE
               || select_stmt->get_table_item(0).type_ == TableItem::ALIAS_TABLE)
           && (select_stmt->get_group_expr_size() > 0
               || select_stmt->get_agg_fun_size() > 0))
  {
    ObSqlRawExpr *expr = NULL;
    ObAggFunRawExpr *agg_expr = NULL;
    int32_t agg_num = select_stmt->get_agg_fun_size();
    for (int32_t i = 0; ret == OB_SUCCESS && i < agg_num; i++)
    {
      if ((expr = logical_plan->get_expr(select_stmt->get_agg_expr_id(i))) == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Wrong expression id of aggregate function");
        break;
      }
      else if ((agg_expr = dynamic_cast<ObAggFunRawExpr*>(expr->get_expr())) == NULL)
      {
        // agg(*), skip
        continue;
      }
      else if (agg_expr->is_param_distinct())
      {
        break;
      }
      else if (i == agg_num - 1)
      {
        group_agg_pushed_down = true;
      }
    }
  }

  // push down aggregate function(s)
  if (ret == OB_SUCCESS && group_agg_pushed_down)
  {
    // push down group column(s)
    ObSqlRawExpr *group_expr = NULL;
    int32_t num = select_stmt->get_group_expr_size();
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      if ((group_expr = logical_plan->get_expr(select_stmt->get_group_expr_id(i))) == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Wrong expression id  of group column");
      }
      else if (group_expr->get_expr()->get_expr_type() == T_REF_COLUMN)
      {
        ObBinaryRefRawExpr *col_expr = dynamic_cast<ObBinaryRefRawExpr*>(group_expr->get_expr());
        if ((ret = table_rpc_scan_op->add_group_column(
               is_ailias_table?col_expr->get_first_ref_id():index_tid,
               col_expr->get_second_ref_id(),
               !is_ailias_table)) != OB_SUCCESS)
        {
          TRANS_LOG("Add group column faild, table_id=%lu, column_id=%lu",
                    index_tid, col_expr->get_second_ref_id());
        }
      }
      else if (group_expr->get_expr()->is_const())
      {
        // do nothing, const column is of no usage for sorting
        continue;
      }
      else
      {
        ObSqlExpression col_expr;
        if ((ret = group_expr->fill_sql_expression(
               col_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS)
        {
          TRANS_LOG("fill sql expression failed!");
        }
        else if (!is_ailias_table)
        {
          //change tid to index_tid
          ObArray<uint64_t> index_column_array;
          if(OB_SUCCESS==(ret=col_expr.get_all_cloumn(index_column_array)))
          {
            for(int32_t i=0;i<index_column_array.count();i++)
            {
              ObPostfixExpression& ops=col_expr.get_decoded_expression_v2();
              ObObj& obj=ops.get_expr_by_index(index_column_array.at(i));
              if(obj.get_type()==ObIntType)
                obj.set_int(index_tid);
            }
          }
        }

        if (OB_SUCCESS == ret)
        {
          if((ret = table_rpc_scan_op->add_output_column(col_expr)) != OB_SUCCESS)
          {
            TRANS_LOG("Add complex group column to project plan faild");
          }
          else if ((ret = table_rpc_scan_op->add_group_column(
                      group_expr->get_table_id(),
                      group_expr->get_column_id())) != OB_SUCCESS)
          {
            TRANS_LOG("Add group column to group plan faild");
          }
        }
      }
    }

    // push down function(s)
    num = select_stmt->get_agg_fun_size();
    ObSqlRawExpr *agg_expr = NULL;
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      if ((agg_expr = logical_plan->get_expr(select_stmt->get_agg_expr_id(i))) == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Wrong expression id  of aggregate function");
        break;
      }
      else if (agg_expr->get_expr()->get_expr_type() ==  T_FUN_AVG)
      {
        // avg() ==> sum() / count()
        ObAggFunRawExpr *avg_expr = NULL;
        if ((avg_expr = dynamic_cast<ObAggFunRawExpr*>(agg_expr->get_expr())) == NULL)
        {
          ret = OB_ERR_RESOLVE_SQL;
          TRANS_LOG("Wrong aggregate function, exp_id = %lu", agg_expr->get_expr_id());
          break;
        }

        // add sum(), count() to TableRpcScan
        uint64_t table_id = agg_expr->get_table_id();
        uint64_t sum_cid = logical_plan->generate_range_column_id();
        uint64_t count_cid = logical_plan->generate_range_column_id();
        ObAggFunRawExpr sum_node;
        ObAggFunRawExpr count_node;
        sum_node.set_expr_type(T_FUN_SUM);
        sum_node.set_param_expr(avg_expr->get_param_expr());
        count_node.set_expr_type(T_FUN_COUNT);
        count_node.set_param_expr(avg_expr->get_param_expr());
        ObSqlRawExpr raw_sum_expr(OB_INVALID_ID, table_id, sum_cid, &sum_node);
        ObSqlRawExpr raw_count_expr(OB_INVALID_ID, table_id, count_cid, &count_node);
        ObSqlExpression sum_expr;
        ObSqlExpression count_expr;
        if ((ret = raw_sum_expr.fill_sql_expression(
               sum_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS)
        {
          TRANS_LOG("fill sql expression failed, ret = %d", ret);
          break;
        }
        else if (!is_ailias_table)
        {
          //change tid to index_tid
          ObArray<uint64_t> index_column_array;
          if(OB_SUCCESS==(ret=sum_expr.get_all_cloumn(index_column_array)))
          {
            for(int32_t i=0;i<index_column_array.count();i++)
            {
              ObPostfixExpression& ops=sum_expr.get_decoded_expression_v2();
              ObObj& obj=ops.get_expr_by_index(index_column_array.at(i));
              if(obj.get_type()==ObIntType)
                obj.set_int(index_tid);
            }
          }
        }
        if (OB_SUCCESS == ret)
        {
          if ((ret = table_rpc_scan_op->add_aggr_column(sum_expr)) != OB_SUCCESS)
          {
            TRANS_LOG("Add sum aggregate function failed, ret = %d", ret);
            break;
          }
        }

        if (OB_SUCCESS == ret)
        {
          if ((ret = raw_count_expr.fill_sql_expression(
                 count_expr,
                 this,
                 logical_plan,
                 physical_plan)) != OB_SUCCESS)
          {
            TRANS_LOG("fill sql expression failed, ret = %d", ret);
            break;
          }
          else if (!is_ailias_table)
          {
            //change tid to index_tid
            ObArray<uint64_t> index_column_array;
            if(OB_SUCCESS==(ret=count_expr.get_all_cloumn(index_column_array)))
            {
              for(int32_t i=0;i<index_column_array.count();i++)
              {
                ObPostfixExpression& ops=count_expr.get_decoded_expression_v2();
                ObObj& obj=ops.get_expr_by_index(index_column_array.at(i));
                if(obj.get_type()==ObIntType)
                  obj.set_int(index_tid);
              }
            }
          }
        }
        if (OB_SUCCESS == ret)
        {
          if ((ret = table_rpc_scan_op->add_aggr_column(count_expr)) != OB_SUCCESS)
          {
            TRANS_LOG("Add count aggregate function failed, ret = %d", ret);
            break;
          }
        }

        // add a '/' expression
        ObBinaryRefRawExpr sum_col_node(table_id, sum_cid, T_REF_COLUMN);
        ObBinaryRefRawExpr count_col_node(table_id, count_cid, T_REF_COLUMN);
        ObBinaryOpRawExpr div_node(&sum_col_node, &count_col_node, T_OP_DIV);
        ObSqlRawExpr div_raw_expr(OB_INVALID_ID, table_id, agg_expr->get_column_id(), &div_node);
        ObSqlExpression div_expr;
        if (project_op == NULL)
        {
          if (CREATE_PHY_OPERRATOR(project_op, ObAddProject, physical_plan, err_stat) == NULL
              || (ret = project_op->set_child(0, *table_rpc_scan_op)) != OB_SUCCESS)
          {
            TRANS_LOG("Add ObAddProject on ObTableRpcScan failed, ret = %d", ret);
            break;
          }
          else
          {
            scan_op = project_op;
          }
        }
        if ((ret = div_raw_expr.fill_sql_expression(div_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Generate div expr for avg() function failed, ret = %d", ret);
        }
        else if ((ret = project_op->add_output_column(div_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add column to ObAddProject operator failed, ret = %d", ret);
        }
      }
      else if (agg_expr->get_expr()->is_aggr_fun())
      {
        ObSqlExpression new_agg_expr;
        if ((ret = agg_expr->fill_sql_expression(
               new_agg_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS)
        {
          TRANS_LOG("fill sql expression faild");
          break;
        }
        else if (!is_ailias_table)
        {
          //change tid to index_tid
          ObArray<uint64_t> index_column_array;
          if(OB_SUCCESS==(ret=new_agg_expr.get_all_cloumn(index_column_array)))
          {
            for(int32_t i=0;i<index_column_array.count();i++)
            {
              ObPostfixExpression& ops=new_agg_expr.get_decoded_expression_v2();
              ObObj& obj=ops.get_expr_by_index(index_column_array.at(i));
              if(obj.get_type()==ObIntType)
                obj.set_int(index_tid);
            }
          }
        }
        if (OB_SUCCESS == ret)
        {
          if ((ret = table_rpc_scan_op->add_aggr_column(new_agg_expr)) != OB_SUCCESS)
          {
            TRANS_LOG("Add aggregate function to group plan faild");
            break;
          }
        }
      }
      else
      {
        ret = OB_ERR_RESOLVE_SQL;
        TRANS_LOG("Wrong aggregate function, exp_id = %lu", agg_expr->get_expr_id());
        break;
      }
      agg_expr->set_columnlized(true);
    }
  }
  return ret;
}
//add:e
int ObTransformer::try_push_down_limit(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const ObSelectStmt *select_stmt,
    bool& limit_pushed_down,
    ObPhyOperator *scan_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObTableRpcScan *table_rpc_scan_op = dynamic_cast<ObTableRpcScan*>(scan_op);

  if (table_rpc_scan_op == NULL)
  {
    // ignore
  }
  // 1. normal select statement, not UNION/EXCEPT/INTERSECT
  // 2. only one table, whose type is BASE_TABLE or ALIAS_TABLE
  // 3. can not be joined table.
  // 4. does not have group clause or aggregate function(s)
  // 5. does not have order by caluse
  // 6. limit is initialed
  // 7. does not have distinct flag
  else if (select_stmt->get_from_item_size() == 1
           && select_stmt->get_from_item(0).is_joined_ == false
           && select_stmt->get_table_size() == 1
           && (select_stmt->get_table_item(0).type_ == TableItem::BASE_TABLE
               || select_stmt->get_table_item(0).type_ == TableItem::ALIAS_TABLE)
           && select_stmt->get_group_expr_size() == 0
           && select_stmt->get_agg_fun_size() == 0
           && select_stmt->get_order_item_size() == 0
           && (select_stmt->get_order_item_size() == 0 || select_stmt->get_unindexed_order_item_size() == 0)//add liumz, [optimize group_order by index]20170419
           && !select_stmt->is_distinct())//add liumz, [bugfix: do not push down limit when select_stmt->is_distinct]20150901
  {
    limit_pushed_down = true;
    ObSqlExpression limit_count;
    ObSqlExpression limit_offset;
    ObSqlExpression *ptr = &limit_count;
    uint64_t id = select_stmt->get_limit_expr_id();
    int64_t i = 0;
    for (; ret == OB_SUCCESS && i < 2;
         i++, id = select_stmt->get_offset_expr_id(), ptr = &limit_offset)
    {
      ObSqlRawExpr *raw_expr = NULL;
      if (id == OB_INVALID_ID)
      {
        continue;
      }
      else if ((raw_expr = logical_plan->get_expr(id)) == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Wrong internal expression id = %lu, ret=%d", id, ret);
        break;
      }
      else if ((ret = raw_expr->fill_sql_expression(
                  *ptr,
                  this,
                  logical_plan,
                  physical_plan)) != OB_SUCCESS)
      {
        TRANS_LOG("Add limit/offset faild");
        break;
      }
    }
    if (ret == OB_SUCCESS && (ret = table_rpc_scan_op->set_limit(limit_count, limit_offset)) != OB_SUCCESS)
    {
      TRANS_LOG("Set limit/offset failed, ret=%d", ret);
    }
  }
  return ret;
}
//add wenghaixing [secondary index replace bug_fix]20150517
int ObTransformer::row_desc_intersect(ObRowDesc &row_desc,
                                      ObRowDescExt &row_desc_ext,
                                      ObRowDesc row_desc_idx,
                                      ObRowDescExt row_desc_ext_idx)
{
  int ret = OB_SUCCESS;
  ObRowDesc tmp_desc = row_desc;
  //ObRowDescExt tmp_ext_desc = row_desc_ext;
  uint64_t tid = OB_INVALID_ID;
  uint64_t cid = OB_INVALID_ID;
  //int64_t idx = 0;
  for (int64_t i = 0; i < row_desc_idx.get_column_num(); i++)
  {
    //idx = 0;
    if(OB_SUCCESS != (ret = row_desc_idx.get_tid_cid(i, tid, cid)))
    {
      YYSYS_LOG(WARN, "get table id and column id failed,ret = %d, idx = %ld", ret, i);
      break;
    }
    else if(OB_INVALID_INDEX == tmp_desc.get_idx(tid, cid))
    {
      ObObj data_type;
      uint64_t tmp_tid = OB_INVALID_ID;
      uint64_t tmp_cid = OB_INVALID_ID;
      if(OB_SUCCESS != (ret = row_desc_ext_idx.get_by_idx(i, tmp_tid, tmp_cid, data_type)))
      {
        YYSYS_LOG(WARN, "get data_type from row_desc_ext failed!ret = %d, idx = %ld", ret, i);
        break;
      }
      else
      {
        if(OB_SUCCESS != (ret = row_desc.add_column_desc(tid, cid)))
        {
          YYSYS_LOG(WARN, "add column desc failed ,tid[%ld], cid[%ld],ret[%d]",tid, cid,ret);
          break;
        }
        else if(OB_SUCCESS != (ret = row_desc_ext.add_column_desc(tid, cid, data_type)))
        {
          YYSYS_LOG(WARN, "add column desc failed ,tid[%ld], cid[%ld],ret[%d]",tid, cid,ret);
          break;
        }
      }
    }
  }

  return ret;
}

int ObTransformer::gen_phy_values_idx(ObLogicalPlan *logical_plan,
                                      ObPhysicalPlan *physical_plan,
                                      ErrStat &err_stat,
                                      const ObInsertStmt *insert_stmt,
                                      ObRowDesc &row_desc,
                                      ObRowDescExt &row_desc_ext,
                                      const ObRowDesc &row_desc_idx,
                                      const ObRowDescExt &row_desc_ext_idx,
                                      const ObSEArray<int64_t, 64> *row_desc_map,
                                      ObExprValues &value_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  OB_ASSERT(logical_plan);
  OB_ASSERT(insert_stmt);
  ret = row_desc_intersect(row_desc, row_desc_ext, row_desc_idx, row_desc_ext_idx);
  value_op.set_row_desc(row_desc, row_desc_ext);
  int64_t num = insert_stmt->get_value_row_size();
  for (int64_t i = 0; ret == OB_SUCCESS && i < num; i++) // for each row
  {
    const ObArray<uint64_t>& value_row = insert_stmt->get_value_row(i);
    if (OB_UNLIKELY(0 == i))
    {
      value_op.reserve_values(num * value_row.count());
      FILL_TRACE_LOG("expr_values_count=%ld", num * value_row.count());
    }
    for (int64_t j = 0; ret == OB_SUCCESS && j < value_row.count(); j++)
    {
      ObSqlExpression val_expr;
      int64_t expr_idx = OB_INVALID_INDEX;
      if (NULL != row_desc_map)
      {
        OB_ASSERT(value_row.count() == row_desc_map->count());
        expr_idx = value_row.at(row_desc_map->at(j));
      }
      else
      {
        expr_idx = value_row.at(j);
      }
      ObSqlRawExpr *value_expr = logical_plan->get_expr(expr_idx);
      OB_ASSERT(NULL != value_expr);
      if (OB_SUCCESS != (ret = value_expr->fill_sql_expression(val_expr, this, logical_plan, physical_plan)))
      {
        TRANS_LOG("Failed to fill expr, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = value_op.add_value(val_expr)))
      {
        TRANS_LOG("Failed to add value into expr_values, err=%d", ret);
      }
    } // end for
    for(int64_t j = value_row.count(); j < row_desc.get_column_num(); j++)
    {
      uint64_t table_id = OB_INVALID_ID;
      uint64_t column_id = OB_INVALID_ID;
      if(OB_SUCCESS != (ret = row_desc.get_tid_cid(j, table_id, column_id)))
      {
        YYSYS_LOG(WARN, "get tid cid falied!ret = %d, idx = %ld", ret, j);
        break;
      }
      else
      {
        ObBinaryRefRawExpr col_expr(table_id, column_id, T_REF_COLUMN);
        ObSqlRawExpr col_raw_expr(
              common::OB_INVALID_ID,
              table_id,
              column_id,
              &col_expr);
        ObSqlExpression output_expr;
        if ((ret = col_raw_expr.fill_sql_expression(
               output_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS)
        {
          TRANS_LOG("Add table output columns failed");
          break;
        }
        else if (OB_SUCCESS != (ret = value_op.add_value(output_expr)))
        {
          TRANS_LOG("Failed to add cell into get param, err=%d", ret);
          break;
        }
      }
    }
  } // end for
  return ret;
}
//add e
int ObTransformer::gen_phy_values(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const ObInsertStmt *insert_stmt,
    const ObRowDesc& row_desc,
    const ObRowDescExt& row_desc_ext,
    const ObSEArray<int64_t, 64> *row_desc_map,
    ObExprValues& value_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  OB_ASSERT(logical_plan);
  OB_ASSERT(insert_stmt);
  value_op.set_row_desc(row_desc, row_desc_ext);
  int64_t num = insert_stmt->get_value_row_size();
  for (int64_t i = 0; ret == OB_SUCCESS && i < num; i++) // for each row
  {
    const ObArray<uint64_t>& value_row = insert_stmt->get_value_row(i);
    if (OB_UNLIKELY(0 == i))
    {
      value_op.reserve_values(num * value_row.count());
      FILL_TRACE_LOG("expr_values_count=%ld", num * value_row.count());
    }
    for (int64_t j = 0; ret == OB_SUCCESS && j < value_row.count(); j++)
    {
      ObSqlExpression val_expr;
      int64_t expr_idx = OB_INVALID_INDEX;
      if (NULL != row_desc_map)
      {
        OB_ASSERT(value_row.count() == row_desc_map->count());
        expr_idx = value_row.at(row_desc_map->at(j));
      }
      else
      {
        expr_idx = value_row.at(j);
      }
      ObSqlRawExpr *value_expr = logical_plan->get_expr(expr_idx);
      OB_ASSERT(NULL != value_expr);
      if (OB_SUCCESS != (ret = value_expr->fill_sql_expression(val_expr, this, logical_plan, physical_plan)))
      {
        TRANS_LOG("Failed to fill expr, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = value_op.add_value(val_expr)))
      {
        TRANS_LOG("Failed to add value into expr_values, err=%d", ret);
      }
    } // end for
  } // end for
  return ret;
}

// merge tables' versions from inner physical plan to outer plan
int ObTransformer::merge_tables_version(ObPhysicalPlan & outer_plan,ObPhysicalPlan & inner_plan)
{
  int ret = OB_SUCCESS;
  if (&outer_plan != &inner_plan)
  {
    for (int64_t i = 0; i < inner_plan.get_base_table_version_count(); i++)
    {
      if ((ret = outer_plan.add_base_table_version(inner_plan.get_base_table_version(i))) != OB_SUCCESS)
      {
        YYSYS_LOG(WARN, "Failed to add %ldth base tables version, err=%d", i, ret);
        break;
      }
    }
  }
  return ret;
}
/*
int ObTransformer::gen_physical_replace(
        ObLogicalPlan *logical_plan,
        ObPhysicalPlan *physical_plan,
        ErrStat& err_stat,
        const uint64_t& query_id,
        int32_t* index)
{
    int &ret = err_stat.err_code_ = OB_SUCCESS;
    ObInsertStmt *insert_stmt = NULL;
    ObPhysicalPlan* inner_plan = NULL;
    ObUpsModify *ups_modify = NULL;
    ObSEArray<int64_t, 64> row_desc_map;
    ObRowDesc row_desc;
    ObRowDescExt row_desc_ext;
    const ObRowkeyInfo *rowkey_info = NULL;

    if (OB_SUCCESS != (ret = wrap_ups_executor(physical_plan, query_id, inner_plan, index, err_stat)))
    {
        YYSYS_LOG(WARN, "err=%d", ret);
    }
    else if (OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, insert_stmt)))
    {
        TRANS_LOG("Fail to get statement");
    }
    else if (NULL == CREATE_PHY_OPERRATOR(ups_modify, ObUpsModify, inner_plan, err_stat))
    {
        ret = OB_ALLOCATE_MEMORY_FAILED;
    }
    else if (OB_SUCCESS != (ret = inner_plan->add_phy_query(
                                ups_modify,
                                physical_plan == inner_plan ? index : NULL,
                                physical_plan != inner_plan)))
    {
        TRANS_LOG("Failed to add phy query, err=%d", ret);
    }
    else if (OB_SUCCESS != (ret = cons_row_desc(insert_stmt->get_table_id(), insert_stmt, row_desc_ext, row_desc, rowkey_info, row_desc_map, err_stat)))
    {
        TRANS_LOG("Failed to cons row desc, err=%d", ret);
    }
    else
    {
        uint64_t tid = insert_stmt->get_table_id();
        // check primary key columns
        uint64_t cid = OB_INVALID_ID;
        for (int64_t i = 0; OB_SUCCESS == ret && i < rowkey_info->get_size(); ++i)
        {
            if (OB_SUCCESS != (ret = rowkey_info->get_column_id(i, cid)))
            {
                YYSYS_LOG(USER_ERROR, "primary key can not be empty");
                ret = OB_ERR_INSERT_NULL_ROWKEY;
                break;
            }
            else if (OB_INVALID_INDEX == row_desc.get_idx(tid, cid))
            {
                YYSYS_LOG(USER_ERROR, "primary key can not be empty");
                ret = OB_ERR_INSERT_NULL_ROWKEY;
                break;
            }
        } // end for

        // add peiouya [NotNULL_check] [JHOBv0.1] 20131222:b
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
            ret = column_null_check(logical_plan, insert_stmt, err_stat, OP_REPLACE);
        }
        // add 20131222:e

        if (OB_LIKELY(OB_SUCCESS == ret))
        {
            // check column data type
            ObObj data_type;
            for (int i = 0; i < row_desc_ext.get_column_num(); ++i)
            {
                if (OB_SUCCESS != (ret = row_desc_ext.get_by_idx(i, tid, cid, data_type)))
                {
                    YYSYS_LOG(ERROR, "failed to get type, err=%d", ret);
                    ret = OB_ERR_UNEXPECTED;
                    break;
                }
                else if (data_type.get_type() == ObCreateTimeType
                         || data_type.get_type() == ObModifyTimeType)
                {
                    ret = OB_ERR_CREAT_MODIFY_TIME_COLUMN;
                    TRANS_LOG("Column of type ObCreateTimeType/ObModifyTimeType can not be inserted");
                    break;
                }
            } // end for
        }
    }
    FILL_TRACE_LOG("cons_row_desc");
    ObExprValues *value_op = NULL;
    if (ret == OB_SUCCESS)
    {
        if (OB_LIKELY(insert_stmt->get_insert_query_id() == OB_INVALID_ID))
        {
            CREATE_PHY_OPERRATOR(value_op, ObExprValues, inner_plan, err_stat);
            if (OB_SUCCESS != ret)
            {
            }
            else if ((ret = value_op->set_row_desc(row_desc, row_desc_ext)) != OB_SUCCESS)
            {
                TRANS_LOG("Set descriptor of value operator failed");
            }
            else if (OB_SUCCESS != (ret = gen_phy_values(logical_plan, inner_plan, err_stat, insert_stmt,
                                                         row_desc, row_desc_ext, &row_desc_map, *value_op)))
            {
                TRANS_LOG("Failed to gen expr values, err=%d", ret);
            }
            else
            {
               //add shili [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20150721:b
             //����table_id  stmt_type �������ƻ�ִ�е�ʱ��ʹ��
             inner_plan->set_table_id(insert_stmt->get_table_id());
             inner_plan->set_stmt_type(ObBasicStmt::T_REPLACE);
            //add 20150721:e
           //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20151124:b
          inner_plan->set_expr_values_op_id(value_op->get_id());
          inner_plan->add_phy_query(value_op);
          //add 20151124:e
        value_op->set_do_eval_when_serialize(true);
            }
            FILL_TRACE_LOG("gen_phy_values");
        }
        else
        {
            // replace ... select
            TRANS_LOG("REPLACE INTO ... SELECT is not supported yet");
            ret = OB_NOT_SUPPORTED;
        }
    }
    if (OB_SUCCESS == ret)
    {
        ObWhenFilter *when_filter_op = NULL;
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
            if (insert_stmt->get_when_expr_size() > 0)
            {
                if ((ret = gen_phy_when(logical_plan,
                                        inner_plan,
                                        err_stat,
                                        query_id,
                                        *value_op,
                                        when_filter_op
                                        )) != OB_SUCCESS)
                {
                }
                else if ((ret = ups_modify->set_child(0, *when_filter_op)) != OB_SUCCESS)
                {
                    TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
                }
            }
            else if ((ret = ups_modify->set_child(0, *value_op)) != OB_SUCCESS)
            {
                TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
            }
        }
    }
    if (OB_SUCCESS == ret)
    {
        // record table's schema version
        uint64_t tid = insert_stmt->get_table_id();
        const ObTableSchema *table_schema = NULL;
        if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(tid)))
        {
            ret = OB_ERR_ILLEGAL_ID;
            TRANS_LOG("fail to get table schema for table[%ld]", tid);
        }
        else if ((ret = physical_plan->add_base_table_version(
                      tid,
                      table_schema->get_schema_version()
                      )) != OB_SUCCESS)
        {
            TRANS_LOG("Failed to add table version into physical_plan, err=%d", ret);
        }
    }
    if (ret == OB_SUCCESS)
    {
        if ((ret = merge_tables_version(*physical_plan, *inner_plan)) != OB_SUCCESS)
        {
            TRANS_LOG("Failed to add base tables version, err=%d", ret);
        }
    }

  //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20160418:b
  if (OB_SUCCESS == ret && !IS_SYS_TABLE_ID(insert_stmt->get_table_id()))
  {


    if (OB_SUCCESS != (ret = gen_physical_replace_pre_execution_plan(
                         logical_plan,
                         physical_plan,
                         insert_stmt,
                         insert_stmt->get_table_id(),
                         row_desc,
                         row_desc_ext,
                         row_desc_map,
                         err_stat,
                         query_id)))
    {
      TRANS_LOG("gen physical update new pre execution plan failed, err=%d", ret);
    }
    else if (OB_SUCCESS != (ret = gen_physical_replace_full_row_execution_plan(
                              logical_plan,
                              physical_plan,
                              insert_stmt,
                              insert_stmt->get_table_id(),
                              row_desc,
                              row_desc_ext,
                              row_desc_map,
                              rowkey_info,
                              err_stat,
                              query_id)))
    {
      TRANS_LOG("gen physical update new full row execution plan failed, err=%d", ret);
    }
  }
  //add 20160418:e

    return ret;
}
*/
//add liumz, [optimize replace index]20161110:b
bool ObTransformer::is_need_static_data_for_index(uint64_t main_tid)
{
  int ret = OB_SUCCESS;
  bool need_static_data = false;
  uint64_t index_tid_array[OB_MAX_INDEX_NUMS];
  uint64_t index_num = 0;

  const ObTableSchema *table_schema = NULL;
  const ObTableSchema *index_schema = NULL;
  const ObRowkeyInfo *rowkey_info = NULL;
  const ObRowkeyInfo *index_rowkey_info = NULL;

  if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(main_tid)))
  {
    ret = OB_ERR_ILLEGAL_ID;
    YYSYS_LOG(WARN, "fail to get table schema, tid=%ld", main_tid);
  }
  else if (NULL == (rowkey_info = &table_schema->get_rowkey_info()))
  {
    ret = OB_ERROR;
    YYSYS_LOG(WARN, "fail to get table rowkey info");
  }
  else if (OB_SUCCESS != (ret = sql_context_->schema_manager_->get_all_modifiable_index_tid(main_tid, index_tid_array, index_num)))
  {
    YYSYS_LOG(WARN, "fail to get index array for table[%ld], err=%d", main_tid, ret);
  }
  else if (index_num > 0 && index_num <= static_cast<uint64_t>(OB_MAX_INDEX_NUMS))
  {
    for (uint64_t idx = 0; idx < index_num && OB_SUCCESS == ret; idx++)
    {
      if (NULL == (index_schema = sql_context_->schema_manager_->get_table_schema(index_tid_array[idx])))
      {
        ret = OB_ERR_ILLEGAL_ID;
        YYSYS_LOG(WARN, "fail to get index schema, index tid=%ld", index_tid_array[idx]);
        break;
      }
      else if (NULL == (index_rowkey_info = &index_schema->get_rowkey_info()))
      {
        ret = OB_ERROR;
        YYSYS_LOG(WARN, "fail to get index rowkey info");
        break;
      }
      else
      {
        YYSYS_LOG(DEBUG, "LMZ rowkey_info:%ld         index_rowkey_info:%ld", rowkey_info->get_size(), index_rowkey_info->get_size());
        int64_t rowkey_col_num = index_rowkey_info->get_size();
        if (rowkey_col_num != rowkey_info->get_size())
        {
          need_static_data = true;
          break;
        }
      }
    }//end for
  }
  if (OB_SUCCESS != ret)
  {
    need_static_data = true;
  }
  YYSYS_LOG(DEBUG, "LMZ need_static_data[%d]", need_static_data);
  return need_static_data;
}
//add:e

int ObTransformer::gen_physical_replace_new(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObInsertStmt *insert_stmt = NULL;
  ObPhysicalPlan *inner_plan = NULL;
  ObUpsModifyWithDmlType *ups_modify = NULL;
  ObSEArray<int64_t, 64> row_desc_map;
  ObRowDesc row_desc;
  ObRowDesc row_desc_for_static_data;
  ObRowDescExt row_desc_ext;
  ObRowDescExt row_desc_ext_for_static_data;
  ObRowDesc main_desc;
  const ObRowkeyInfo *rowkey_info = NULL;
  bool is_need_modify_index = false;

  // first, if replace table has index
  if (OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, insert_stmt)))
  {
    TRANS_LOG("fail to get statement");
  }
  else
  {
    uint64_t main_tid = insert_stmt->get_table_id();
    if (sql_context_->schema_manager_->is_have_modifiable_index(main_tid))
    {
      is_need_modify_index = true;
    }
  }

  if (OB_SUCCESS == ret && OB_SUCCESS != (ret = wrap_ups_executor(physical_plan, query_id, inner_plan, index, err_stat)))
  {
    YYSYS_LOG(WARN, "err=%d", ret);
  }
  else if (NULL == CREATE_PHY_OPERRATOR(ups_modify, ObUpsModifyWithDmlType, inner_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else if (OB_SUCCESS != (ret = inner_plan->add_phy_query(
                            ups_modify,
                            physical_plan == inner_plan ? index : NULL,
                            physical_plan != inner_plan)))
  {
    TRANS_LOG("failed to add phy query, err=%d", ret);
  }
  else if (OB_SUCCESS != (ret = cons_row_desc(insert_stmt->get_table_id(), insert_stmt, row_desc_ext, row_desc, rowkey_info, row_desc_map, err_stat)))
  {
    TRANS_LOG("fail to cons row desc, err=%d", ret);
  }
  else
  {
    ups_modify->set_dml_type(OB_DML_REPLACE);
    uint64_t tid = insert_stmt->get_table_id();
    uint64_t cid = OB_INVALID_ID;
    // if replace columns must include rowkey column
    for (int64_t i = 0; OB_SUCCESS == ret && i < rowkey_info->get_size(); ++i)
    {
      if (OB_SUCCESS != (ret = rowkey_info->get_column_id(i, cid)))
      {
        YYSYS_LOG(USER_ERROR, "primary key can not be empty");
        ret = OB_ERR_INSERT_NULL_ROWKEY;
        break;
      }
      else if (OB_INVALID_INDEX == row_desc.get_idx(tid, cid))
      {
        YYSYS_LOG(USER_ERROR, "primary key can not be empty");
        ret = OB_ERR_INSERT_NULL_ROWKEY;
        break;
      }
    }//end for

    // column NULL check
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      ret = column_null_check(logical_plan, insert_stmt, err_stat, OP_REPLACE);
    }

    // column type check, ObCreateTimeType & ObModifyTimeType must not replace
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      if (OB_LIKELY(OB_INVALID_ID == insert_stmt->get_insert_query_id()))
      {
        // check column data type
        ObObj data_type;
        for (int64_t i = 0; i < row_desc_ext.get_column_num(); ++i)
        {
          if (OB_SUCCESS != (ret = row_desc_ext.get_by_idx(i, tid, cid, data_type)))
          {
            YYSYS_LOG(ERROR, "fail to get type, err=%d", ret);
            ret = OB_ERR_UNEXPECTED;
            break;
          }
          else if (ObCreateTimeType == data_type.get_type()
                   || ObModifyTimeType == data_type.get_type())
          {
            ret = OB_ERR_CREAT_MODIFY_TIME_COLUMN;
            TRANS_LOG("column of type ObCreateTimeType/ObModifyTimeType can not be inserted");
            break;
          }
        }//end for
      }
      else
      {
        TRANS_LOG("REPLACE INTO ... SELECT is not supported yet");
        ret = OB_NOT_SUPPORTED;
      }
    }
  }// end else

  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
    // �Ѷ������������������Ĺ���ϳ�һ������
    if(is_need_modify_index)
    {
      ObIndexTriggerRep *index_trigger_rep = NULL;
      if(OB_SUCCESS !=(ret = gen_physical_index_trigger_for_replace(logical_plan,inner_plan,
                                                                    err_stat,index_trigger_rep,
                                                                    row_desc,row_desc_ext,insert_stmt,
                                                                    row_desc_map,
                                                                    row_desc_for_static_data,
                                                                    row_desc_ext_for_static_data,
                                                                    main_desc,rowkey_info)))
      {
        YYSYS_LOG(WARN,"failed to gen phy for index replace,ret = %d",ret );
      }


      //add by maosy  20170415 e
      ObWhenFilter *when_filter_op = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        if (insert_stmt->get_when_expr_size() > 0)
        {
          if (OB_SUCCESS != (ret = gen_phy_when(logical_plan,
                                                inner_plan,
                                                err_stat,
                                                query_id,
                                                *index_trigger_rep,
                                                when_filter_op)))
          {
          }
          else if (OB_SUCCESS != (ret = ups_modify->set_child(0, *when_filter_op)))
          {
            TRANS_LOG("fail to set child of ups_modify operator, err=%d", ret);
          }
        }
        else
        {
          if (OB_SUCCESS != (ret = ups_modify->set_child(0, *index_trigger_rep)))
          {
            TRANS_LOG("fail to set child of ups_modify operator, err=%d", ret);
          }
        }
      }
    }
    else// no index, only replace into main table
    {
      ObExprValues *value_op = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        CREATE_PHY_OPERRATOR(value_op, ObExprValues, inner_plan, err_stat);
        if (OB_UNLIKELY(OB_SUCCESS != ret))
        {
        }
        else if (OB_SUCCESS != (ret = value_op->set_row_desc(row_desc, row_desc_ext)))
        {
          TRANS_LOG("fail to set descriptor of values operator, err=%d", ret);
        }
        else if (OB_SUCCESS != (ret = gen_phy_values(logical_plan, inner_plan, err_stat, insert_stmt,
                                                     row_desc, row_desc_ext, &row_desc_map, *value_op)))
        {
          TRANS_LOG("fail to generate values, err=%d", ret);
        }
        else
        {
          //add shili [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20150721:b
          //����table_id  stmt_type �������ƻ�ִ�е�ʱ��ʹ��
          inner_plan->set_table_id(insert_stmt->get_table_id());
          inner_plan->set_stmt_type(ObBasicStmt::T_REPLACE);
          //add 20150721:e
          //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20151124:b
          inner_plan->set_expr_values_op_id(value_op->get_id());
          inner_plan->add_phy_query(value_op);
          //add 20151124:e
          value_op->set_do_eval_when_serialize(true);
        }
        FILL_TRACE_LOG("gen_phy_values");
      }
      ObWhenFilter *when_filter_op = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        if (insert_stmt->get_when_expr_size() > 0)
        {
          if (OB_SUCCESS != (ret = gen_phy_when(logical_plan,
                                                inner_plan,
                                                err_stat,
                                                query_id,
                                                *value_op,
                                                when_filter_op)))
          {
          }
          else if (OB_SUCCESS != (ret = ups_modify->set_child(0, *when_filter_op)))
          {
            TRANS_LOG("fail to set child of ups_modify operator, err=%d", ret);
          }
        }
        else if (OB_SUCCESS != (ret = ups_modify->set_child(0, *value_op)))
        {
          TRANS_LOG("fail to set child of ups_modify operator, err=%d", ret);
        }
      }
    }
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      // reocrd table's schema version
      uint64_t tid = insert_stmt->get_table_id();
      const ObTableSchema *table_schema = NULL;
      if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(tid)))
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("fail to get table schema for table, table id=%lu", tid);
      }
      else if (OB_SUCCESS != (ret = physical_plan->add_base_table_version(
                                tid,
                                table_schema->get_schema_version()
                                )))
      {
        TRANS_LOG("fail to add table version into physical_plan, err=%d", ret);
      }
    }
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      if (OB_SUCCESS != (ret = merge_tables_version(*physical_plan, *inner_plan)))
      {
        TRANS_LOG("fail to add base tables version, err=%d", ret);
      }
    }
  }
  //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20160418:b
  //if (OB_SUCCESS == ret && !IS_SYS_TABLE_ID(insert_stmt->get_table_id()) && !is_need_modify_index)
  if (false)
  {
    /**
       * FOR REPLACE STMT,there are three plans in MultiUps:
       *   1.the raw physical plan as befor, for full row replace table.
       *   2.the pre_execution physical plan which will execute in ups without static data,
       *     for hot table and rule changed table meanwhile the row is not complete.
       *   3.the full row execution physical plan which will be executed when the pre_execution
       *     is failed, for hot table and rule changed table meanwhile tha row is not complete.
       */

    if (OB_SUCCESS != (ret = gen_physical_replace_pre_execution_plan(
                         logical_plan,
                         physical_plan,
                         insert_stmt,
                         insert_stmt->get_table_id(),
                         row_desc,
                         row_desc_ext,
                         row_desc_map,
                         err_stat,
                         query_id
                         //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
                         ,is_need_modify_index)))
    {
      TRANS_LOG("gen physical update new pre execution plan failed, err=%d", ret);
    }
    else if (OB_SUCCESS != (ret = gen_physical_replace_full_row_execution_plan(
                              logical_plan,
                              physical_plan,
                              insert_stmt,
                              insert_stmt->get_table_id(),
                              row_desc,
                              row_desc_ext,
                              row_desc_map,
                              rowkey_info,
                              err_stat,
                              query_id
                              //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
                              ,is_need_modify_index)))
    {
      TRANS_LOG("gen physical update new full row execution plan failed, err=%d", ret);
    }
  }
  //add 20160418:e

  return ret;
}
// add:e

int ObTransformer::gen_physical_delete(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObDeleteStmt *delete_stmt = NULL;
  ObDelete     *delete_op = NULL;

  /* get statement */
  if (OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, delete_stmt)))
  {
    TRANS_LOG("Fail to get statement");
  }

  /* generate operator */
  if (ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(delete_op, ObDelete, physical_plan, err_stat);
    if (ret == OB_SUCCESS)
    {
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, delete_stmt, delete_op, index);
    }
  }

  ObRowDescExt row_desc_ext;
  const ObTableSchema *table_schema = NULL;
  if (OB_SUCCESS == ret)
  {
    if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(delete_stmt->get_delete_table_id())))
    {
      ret = OB_ERROR;
      TRANS_LOG("Fail to get table schema for table[%ld]", delete_stmt->get_delete_table_id());
    }
  }
  if (ret == OB_SUCCESS)
  {
    delete_op->set_table_id(delete_stmt->get_delete_table_id());
    delete_op->set_rpc_stub(sql_context_->merger_rpc_proxy_);
    delete_op->set_rowkey_info(table_schema->get_rowkey_info());
    int32_t num = delete_stmt->get_column_size();
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      const ColumnItem* column_item = delete_stmt->get_column_item(i);
      if (column_item == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Get column item failed");
        break;
      }
      const ObColumnSchemaV2* column_schema = sql_context_->schema_manager_->get_column_schema(
                                                column_item->table_id_, column_item->column_id_);
      if (NULL == column_schema)
      {
        ret = OB_ERR_COLUMN_NOT_FOUND;
        TRANS_LOG("Get column item failed");
        break;
      }
      ObObj data_type;
      data_type.set_type(column_schema->get_type());
      ret = row_desc_ext.add_column_desc(column_item->table_id_, column_item->column_id_, data_type);
      if (ret != OB_SUCCESS)
      {
        TRANS_LOG("Add column '%.*s' to descriptor failed",
                  column_item->column_name_.length(), column_item->column_name_.ptr());
        break;
      }
    }
    if (ret == OB_SUCCESS && (ret = delete_op->set_columns_desc(row_desc_ext)) != OB_SUCCESS)
    {
      TRANS_LOG("Set descriptor of delete operator failed");
    }
  }

  if (ret == OB_SUCCESS)
  {
    if (OB_UNLIKELY(delete_stmt->get_delete_table_id() == OB_INVALID_ID))
    {
      ret = OB_NOT_INIT;
      TRANS_LOG("table is not given in delete statment. check syntax");
    }
    else
    {
      ObPhyOperator *table_op = NULL;
      if ((ret = gen_phy_table(
             logical_plan,
             physical_plan,
             err_stat,
             delete_stmt,
             delete_stmt->get_delete_table_id(),
             table_op)) == OB_SUCCESS
          && NULL != table_op
          && (ret = delete_op->set_child(0, *table_op)) == OB_SUCCESS)
      {
        // success
      }
      else
      {
        TRANS_LOG("Set child of delete operator failed");
      }
    }
  }

  return ret;
}

int ObTransformer::gen_physical_update(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObUpdateStmt *update_stmt = NULL;
  ObUpdate     *update_op = NULL;
  uint64_t table_id = OB_INVALID_ID;
  int64_t column_idx = 0;
  uint64_t column_id = OB_INVALID_ID;
  uint64_t expr_id = OB_INVALID_ID;
  ObSqlExpression expr;
  ObSqlRawExpr *raw_expr = NULL;
  const ObTableSchema *table_schema = NULL;
  const ObColumnSchemaV2* column_schema = NULL;
  ObObj data_type;
  ObRowDescExt row_desc_ext;

  /* get statement */
  if (ret == OB_SUCCESS)
  {
    get_stmt(logical_plan, err_stat, query_id, update_stmt);
  }
  /* generate operator */
  if (ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(update_op, ObUpdate, physical_plan, err_stat);
    if (ret == OB_SUCCESS)
    {
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, update_stmt, update_op, index);
    }
  }

  /* init update op param */
  /* set table id and other stuff, only support update single table now */
  if (ret == OB_SUCCESS)
  {
    if (OB_INVALID_ID == (table_id = update_stmt->get_update_table_id()))
    {
      ret = OB_ERR_ILLEGAL_ID;
      TRANS_LOG("Get update statement table ID error");
    }
    else if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_id)))
    {
      ret = OB_ERR_ILLEGAL_ID;
      TRANS_LOG("Fail to get table schema for table[%ld]", table_id);
    }
  }

  if (ret == OB_SUCCESS)
  {
    update_op->set_table_id(table_id);
    update_op->set_rpc_stub(sql_context_->merger_rpc_proxy_);
    update_op->set_rowkey_info(table_schema->get_rowkey_info());
  }
  if (ret == OB_SUCCESS)
  {
    // construct row desc ext
    int32_t num = update_stmt->get_column_size();
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      const ColumnItem* column_item = update_stmt->get_column_item(i);
      if (column_item == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Get column item failed");
        break;
      }
      const ObColumnSchemaV2* column_schema = sql_context_->schema_manager_->get_column_schema(
                                                column_item->table_id_, column_item->column_id_);
      if (NULL == column_schema)
      {
        ret = OB_ERR_COLUMN_NOT_FOUND;
        TRANS_LOG("Get column item failed");
        break;
      }
      else if (column_schema->get_type() == ObCreateTimeType || column_schema->get_type() == ObModifyTimeType)
      {
        ret = OB_ERR_CREAT_MODIFY_TIME_COLUMN;
        TRANS_LOG("Column '%s' of type ObCreateTimeType/ObModifyTimeType can not be updated",
                  column_schema->get_name());
        break;
      }
      data_type.set_type(column_schema->get_type());
      ret = row_desc_ext.add_column_desc(column_item->table_id_, column_item->column_id_, data_type);
      if (ret != OB_SUCCESS)
      {
        TRANS_LOG("Add column '%.*s' to descriptor faild",
                  column_item->column_name_.length(), column_item->column_name_.ptr());
        break;
      }
    }
    if (ret == OB_SUCCESS && (ret = update_op->set_columns_desc(row_desc_ext)) != OB_SUCCESS)
    {
      TRANS_LOG("Set ext descriptor of update operator failed");
    }
  }
  /* fill column=expr pairs to update operator */
  if (OB_SUCCESS == ret)
  {
    for (column_idx = 0; column_idx < update_stmt->get_update_column_count(); column_idx++)
    {
      expr.reset();
      // valid check
      // 1. rowkey can't be updated
      // 2. joined column can't be updated
      if (OB_SUCCESS != (ret = update_stmt->get_update_column_id(column_idx, column_id)))
      {
        YYSYS_LOG(WARN, "fail to get update column id for table %lu column_idx=%lu", table_id, column_idx);
        break;
      }
      else if (NULL == (column_schema = sql_context_->schema_manager_->get_column_schema(table_id, column_id)))
      {
        ret = OB_ERR_COLUMN_NOT_FOUND;
        TRANS_LOG("Get column item failed");
        break;
      }
      else if (true == column_schema->is_join_column())
      {
        ret = OB_ERR_UPDATE_JOIN_COLUMN;
        TRANS_LOG("join column '%s' can not be updated", column_schema->get_name());
        break;
      }
      else if (table_schema->get_rowkey_info().is_rowkey_column(column_id))
      {
        ret = OB_ERR_UPDATE_ROWKEY_COLUMN;
        TRANS_LOG("rowkey column '%s' can not be updated", column_schema->get_name());
        break;
      }

      // get expression
      if ((OB_SUCCESS == ret) && (OB_SUCCESS != (ret = update_stmt->get_update_expr_id(column_idx, expr_id))))
      {
        YYSYS_LOG(WARN, "fail to get update expr for table %lu column %lu. column_idx=%ld", table_id, column_id, column_idx);
        break;
      }
      else if (NULL == (raw_expr = logical_plan->get_expr(expr_id)))
      {
        YYSYS_LOG(WARN, "fail to get expr from logical plan for table %lu column %lu. column_idx=%ld", table_id, column_id, column_idx);
        ret = OB_ERR_UNEXPECTED;
        break;
      }
      else if (OB_SUCCESS != (ret = raw_expr->fill_sql_expression(expr, this, logical_plan, physical_plan)))
      {
        YYSYS_LOG(WARN, "fail to fill sql expression. ret=%d", ret);
        break;
      }
      // add <column_id, expression> to update operator
      else if (OB_SUCCESS != (ret = update_op->add_update_expr(column_id, expr)))
      {
        YYSYS_LOG(WARN, "fail to add update expr to update operator");
        break;
      }
    }
  }
  if (OB_SUCCESS == ret)
  {
    ObPhyOperator *table_op = NULL;
    if ((ret = gen_phy_table(
           logical_plan,
           physical_plan,
           err_stat,
           update_stmt,
           table_id,
           table_op)) == OB_SUCCESS
        && NULL != table_op
        && (ret = update_op->set_child(0, *table_op)) == OB_SUCCESS)
    {
      // success
    }
    else
    {
      TRANS_LOG("Set child of update operator failed");
    }
  }

  return ret;
}

int ObTransformer::gen_physical_explain(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObExplainStmt *explain_stmt = NULL;
  ObExplain     *explain_op = NULL;
  if (ret == OB_SUCCESS)
  {
    get_stmt(logical_plan, err_stat, query_id, explain_stmt);
  }
  if (ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(explain_op, ObExplain, physical_plan, err_stat);
    if (ret == OB_SUCCESS)
    {
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, explain_stmt, explain_op, index);
    }
  }

  databuff_printf(explain_op->json_buf, OB_MAX_LOG_BUFFER_SIZE, explain_op->pos, "\n{\n    \"LogicalPlan\":{\n");
  databuff_printf(explain_op->json_buf, OB_MAX_LOG_BUFFER_SIZE, explain_op->pos, "        \"StmtList\":[\n");
  for (int32_t i = 1; i < logical_plan->get_stmts_count(); i++)
  {
    ObBasicStmt *stmt = logical_plan->get_stmt(i);
    stmt->print_json(explain_op->json_buf, OB_MAX_LOG_BUFFER_SIZE, explain_op->pos, 3);
    if (i < logical_plan->get_stmts_count() - 1)
      databuff_printf(explain_op->json_buf, OB_MAX_LOG_BUFFER_SIZE, explain_op->pos, ",");
    databuff_printf(explain_op->json_buf, OB_MAX_LOG_BUFFER_SIZE, explain_op->pos, "\n");
  }
  databuff_printf(explain_op->json_buf, OB_MAX_LOG_BUFFER_SIZE, explain_op->pos, "        ],\n");

  //Exprs
  databuff_printf(explain_op->json_buf, OB_MAX_LOG_BUFFER_SIZE, explain_op->pos, "        \"ExprList\":[\n");
  for (int32_t i = 0; i < logical_plan->get_expr_list_num(); i++)
  {
    ObSqlRawExpr *sql_expr = logical_plan->get_expr_for_something(i);
    sql_expr->print_json(explain_op->json_buf, OB_MAX_LOG_BUFFER_SIZE, explain_op->pos, 3);
    if (i < logical_plan->get_expr_list_num() - 1)
      databuff_printf(explain_op->json_buf, OB_MAX_LOG_BUFFER_SIZE, explain_op->pos, ",");
    databuff_printf(explain_op->json_buf, OB_MAX_LOG_BUFFER_SIZE, explain_op->pos, "\n");
  }
  databuff_printf(explain_op->json_buf, OB_MAX_LOG_BUFFER_SIZE, explain_op->pos, "        ]\n");

  databuff_printf(explain_op->json_buf, OB_MAX_LOG_BUFFER_SIZE, explain_op->pos, "    }\n");
  databuff_printf(explain_op->json_buf, OB_MAX_LOG_BUFFER_SIZE, explain_op->pos, "}\n");

  int32_t idx = OB_INVALID_INDEX;
  if (ret == OB_SUCCESS)
  {
    ret = generate_physical_plan(
            logical_plan,
            physical_plan,
            err_stat,
            explain_stmt->get_explain_query_id(),
            &idx);
  }
  if (ret == OB_SUCCESS)
  {

    //add by wanglei [show semi join physical plan]:b
    //YYSYS_LOG(ERROR,"wanglei:test explain_stmt->is_semi_join () = [%d]",explain_stmt->is_semi_join ());
    /*if(explain_stmt->is_semi_join ())
            explain_op->set_semi_join (true);*/
    //add :e
    ObPhyOperator* op = physical_plan->get_phy_query(idx);
    if ((ret = explain_op->set_child(0, *op)) != OB_SUCCESS)
      TRANS_LOG("Set child of Explain Operator failed");
  }

  return ret;
}

bool ObTransformer::check_join_column(const int32_t column_index,
                                      const char* column_name, const char* join_column_name,
                                      TableSchema& schema, const ObTableSchema& join_table_schema)
{
  bool parse_ok = true;
  uint64_t join_column_id = 0;

  const ColumnSchema* cs = schema.get_column_schema(column_name);
  const ObColumnSchemaV2* jcs = sql_context_->schema_manager_->get_column_schema(join_table_schema.get_table_name(), join_column_name);

  if (NULL == cs || NULL == jcs)
  {
    YYSYS_LOG(ERROR, "column(%s,%s) not a valid column.", column_name, join_column_name);
    parse_ok = false;
  }
  else if (cs->data_type_ != jcs->get_type())
  {
    //the join should be happen between too columns have the same type
    YYSYS_LOG(ERROR, "join column have different types (%s,%d), (%s,%d) ",
              column_name, cs->data_type_, join_column_name, jcs->get_type());
    parse_ok = false;
  }
  else if (OB_SUCCESS != join_table_schema.get_rowkey_info().get_column_id(column_index, join_column_id))
  {
    YYSYS_LOG(ERROR, "join table (%s) has not rowkey column on index(%d)",
              join_table_schema.get_table_name(), column_index);
    parse_ok = false;
  }
  else if (join_column_id != jcs->get_id())
  {
    YYSYS_LOG(ERROR, "join column(%s,%ld) not match join table rowkey column(%ld)",
              join_table_schema.get_table_name(), jcs->get_id(), join_column_id);
    parse_ok = false;
  }

  if (parse_ok)
  {
    int64_t rowkey_idx = -1;
    if (OB_SUCCESS == schema.get_column_rowkey_index(cs->column_id_, rowkey_idx))
    {
      if (-1 == rowkey_idx)
      {
        YYSYS_LOG(ERROR, "left column (%s,%lu) not a rowkey column of left table(%s)",
                  column_name, cs->column_id_, schema.table_name_);
        parse_ok = false;
      }
    }
    else
    {
      YYSYS_LOG(WARN, "fail to get column rowkey index");
      parse_ok = false;
    }
  }
  return parse_ok;
}

bool ObTransformer::parse_join_info(const ObString &join_info_str, TableSchema &table_schema)
{
  bool parse_ok = true;
  char *str = NULL;
  std::vector<char*> node_list;
  const ObTableSchema *table_joined = NULL;
  uint64_t table_id_joined = OB_INVALID_ID;

  char *s = NULL;
  int len = 0;
  char *p = NULL;
  (void)len;
  str = strndup(join_info_str.ptr(), join_info_str.length());
  s = str;
  len = static_cast<int32_t>(strlen(s));

  // str like [r1$jr1,r2$jr2]%joined_table_name:f1$jf1,f2$jf2,...
  if (*s != '[')
  {
    YYSYS_LOG(ERROR, "join info (%s) incorrect, first character must be [", str);
    parse_ok = false;
  }
  else
  {
    ++s;
  }

  if (parse_ok)
  {
    // find another bracket
    p = strchr(s, ']');
    if (NULL == p)
    {
      YYSYS_LOG(ERROR, "join info (%s) incorrect, cannot found ]", str);
      parse_ok = false;
    }
    else
    {
      // s now be the join rowkey columns array.
      *p = '\0';
    }
  }

  if (parse_ok)
  {
    node_list.clear();
    s = str_trim(s);
    yysys::CStringUtil::split(s, ",", node_list);
    if (node_list.empty())
    {
      YYSYS_LOG(ERROR, "join info (%s) incorrect, left join columns not exist.", str);
      parse_ok = false;
    }
    else
    {
      // skip join rowkey columns string, now s -> %joined_table_name:f1$jf1...
      s = p + 1;
    }
  }

  if (parse_ok && *s != '%')
  {
    YYSYS_LOG(ERROR, "%s format error, should be rowkey", str);
    parse_ok = false;
  }

  if (parse_ok)
  {
    // skip '%', find join table name.
    s++;
    p = strchr(s, ':');
    if (NULL == p)
    {
      YYSYS_LOG(ERROR, "%s format error, could not find ':'", str);
      parse_ok = false;
    }
    else
    {
      // now s is the joined table name.
      *p = '\0';
    }
  }

  if (parse_ok)
  {
    table_joined = sql_context_->schema_manager_->get_table_schema(s);
    if (NULL != table_joined)
    {
      table_id_joined = table_joined->get_table_id();
    }

    if (NULL == table_joined || table_id_joined == OB_INVALID_ID)
    {
      YYSYS_LOG(ERROR, "%s table not exist ", s);
      parse_ok = false;
    }
  }

  // parse join rowkey columns.
  if (parse_ok)
  {
    char* cp = NULL;
    for(uint32_t i = 0; parse_ok && i < node_list.size(); ++i)
    {
      cp = strchr(node_list[i], '$');
      if (NULL == cp)
      {
        YYSYS_LOG(ERROR, "error can not find '$' (%s) ", node_list[i]);
        parse_ok = false;
        break;
      }
      else
      {
        *cp = '\0';
        ++cp;
        // now node_list[i] is left column, cp is join table rowkey column;
        parse_ok = check_join_column(i, node_list[i], cp, table_schema, *table_joined);
        if (parse_ok)
        {
          JoinInfo join_info;

          strncpy(join_info.left_table_name_, table_schema.table_name_, OB_MAX_TABLE_NAME_LENGTH);
          join_info.left_table_name_[OB_MAX_TABLE_NAME_LENGTH - 1] = '\0';
          join_info.left_table_id_ = table_schema.table_id_;

          strncpy(join_info.left_column_name_, node_list[i], OB_MAX_COLUMN_NAME_LENGTH);
          join_info.left_column_name_[OB_MAX_COLUMN_NAME_LENGTH - 1] = '\0';
          join_info.left_column_id_ = table_schema.get_column_schema(node_list[i])->column_id_;

          strncpy(join_info.right_table_name_, table_joined->get_table_name(), OB_MAX_TABLE_NAME_LENGTH);
          join_info.right_table_name_[OB_MAX_TABLE_NAME_LENGTH - 1] = '\0';
          join_info.right_table_id_ = table_joined->get_table_id();

          strncpy(join_info.right_column_name_, cp, OB_MAX_COLUMN_NAME_LENGTH);
          join_info.right_column_name_[OB_MAX_COLUMN_NAME_LENGTH - 1] = '\0';
          join_info.right_column_id_ = sql_context_->schema_manager_->get_column_schema(table_joined->get_table_name(), cp)->get_id();
          if (OB_SUCCESS != table_schema.join_info_.push_back(join_info))
          {
            parse_ok = false;
            YYSYS_LOG(WARN, "fail to push join info");
          }
          else
          {
            YYSYS_LOG(DEBUG, "add join info [%s]", to_cstring(join_info));
          }
        }
      }
    }
  }

  // parse join columns
  if (parse_ok)
  {
    s = p + 1;
    s = str_trim(s);
    node_list.clear();
    yysys::CStringUtil::split(s, ",", node_list);
    if (node_list.empty())
    {
      YYSYS_LOG(ERROR, "%s can not find correct info", str);
      parse_ok = false;
    }
  }

  uint64_t ltable_id = OB_INVALID_ID;
  (void)ltable_id;

  if (parse_ok)
  {
    ltable_id = table_schema.table_id_;
    char *fp = NULL;
    for(uint32_t i = 0; parse_ok && i < node_list.size(); ++i)
    {
      fp = strchr(node_list[i], '$');
      if (NULL == fp)
      {
        YYSYS_LOG(ERROR, "error can not find '$' %s ", node_list[i]);
        parse_ok = false;
        break;
      }
      *fp = '\0';
      fp++;

      const ObColumnSchemaV2 * right_column_schema = NULL;
      ColumnSchema *column_schema = table_schema.get_column_schema(node_list[i]);
      if (NULL == column_schema)
      {
        YYSYS_LOG(WARN, "column %s is not valid", node_list[i]);
        parse_ok = false;
      }
      else if (NULL == (right_column_schema = sql_context_->schema_manager_->get_column_schema(table_joined->get_table_name(), fp)))
      {
        YYSYS_LOG(WARN, "column %s is not valid", fp);
        parse_ok = false;
      }
      else
      {
        column_schema->join_table_id_ = table_id_joined;
        column_schema->join_column_id_ = right_column_schema->get_id();
        YYSYS_LOG(DEBUG, "column schema join_table_id[%lu], join_column_id[%lu]", column_schema->join_table_id_, column_schema->join_column_id_);
      }
    }
  }
  free(str);
  str = NULL;
  return parse_ok;
}
//add gaojt [Delete_Update_Function] [JHOBv0.1] 20150817:b
/*
 * This function is used to instead of original function:gen_phy_table_for_update
 * Now only used to delete and update statement,but not select...for update
 * The diff with original is:
 * 1.modify where condition to select type's where condition
 * 2.add another table_rpc_scan operator to get static date according to where condition
 * 3.make these rows fill into ObExprValues
 */
int ObTransformer::gen_phy_table_for_update_new(ObLogicalPlan *logical_plan,
                                                ObPhysicalPlan*& inner_plan,
                                                ObPhysicalPlan *&physical_plan,
                                                ErrStat& err_stat,
                                                ObStmt *stmt,
                                                uint64_t table_id,
                                                const ObRowkeyInfo &rowkey_info,
                                                const ObRowDesc &row_desc,
                                                const ObRowDescExt &row_desc_ext,
                                                ObPhyOperator*& table_op, bool is_delete_update
                                                //add lijianqiang [sequence] 20150909:b
                                                , ObPhyOperator* sequence_op
                                                //add 20150909:e
                                                , bool is_column_hint_index
                                                )
{
  UNUSED(is_delete_update);
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  TableItem* table_item = NULL;
  ObTableRpcScan *table_rpc_scan_for_obvalues = NULL;
  ObIncScan *inc_scan_op = NULL;
  ObMultipleGetMerge *fuse_op = NULL;
  ObMemSSTableScan *static_data = NULL;
  ObValues *tmp_table = NULL;
  ObExprValues* get_param_values = NULL;
  ObFillValues* fill_values = NULL;
  const ObTableSchema *table_schema = NULL;
  ObRpcScanHint hint_values;
  //add duyr [Delete_Update_Function_isolation] [JHOBv0.1] 20160531:b
  ObDataMarkParam data_mark_param;
  //add duyr 20160531:e
  if (table_id == OB_INVALID_ID
      || (table_item = stmt->get_table_item_by_id(table_id)) == NULL
      || TableItem::BASE_TABLE != table_item->type_)
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("Wrong table id, tid=%lu", table_id);
  }
  else
  {
    hint_values.read_method_ = ObSqlReadStrategy::USE_GET;
    hint_values.read_consistency_ = STRONG;
    hint_values.is_get_skip_empty_row_ = false;
    //add duyr [Delete_Update_Function_isolation] [JHOBv0.1] 20160531:b//
    //if (stmt->get_query_hint().is_parallal_)
    if (stmt->get_query_hint().is_parallal_&&!is_multi_batch_)
    {
      uint64_t max_used_cid = 0;
      if (OB_SUCCESS != (ret = get_table_max_used_cid(sql_context_,
                                                      table_item->table_id_,
                                                      max_used_cid)))
      {
        YYSYS_LOG(WARN,"fail to get max used cid[%ld],tid[%ld],ret=%d",
                  max_used_cid,table_item->table_id_,ret);
      }
      else
      {
        hint_values.read_consistency_         = STRONG;
        data_mark_param.need_modify_time_     = true;
        data_mark_param.need_major_version_   = false;
        data_mark_param.need_minor_version_   = false;
        data_mark_param.need_data_store_type_ = false;
        data_mark_param.modify_time_cid_      = ++max_used_cid;
        data_mark_param.major_version_cid_    = ++max_used_cid;
        data_mark_param.minor_ver_start_cid_  = ++max_used_cid;
        data_mark_param.minor_ver_end_cid_    = ++max_used_cid;
        data_mark_param.data_store_type_cid_  = ++max_used_cid;
        data_mark_param.table_id_             = table_item->table_id_;
        if (!data_mark_param.is_valid())
        {
          ret = OB_ERR_UNEXPECTED;
          YYSYS_LOG(ERROR,"invalid data mark param[%s]!ret=%d",
                    to_cstring(data_mark_param),ret);
        }
      }
    }
    //add duyr 20160531:e

  }
  if(OB_SUCCESS != ret)
  {}
  else if (NULL == CREATE_PHY_OPERRATOR(table_rpc_scan_for_obvalues, ObTableRpcScan, inner_plan, err_stat))
  {
    TRANS_LOG("table_rpc_scan_for_obvalues is NULL");
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else if ((ret = table_rpc_scan_for_obvalues->set_table(table_item->table_id_, table_item->ref_id_)) != OB_SUCCESS)
  {
    TRANS_LOG("table_rpc_scan_for_obvalues set table failed");
  }
  else if (OB_SUCCESS != (ret = table_rpc_scan_for_obvalues->init(sql_context_, &hint_values)))
  {
    TRANS_LOG("table_rpc_scan_for_obvalues init failed");
  }
  else if (NULL == CREATE_PHY_OPERRATOR(tmp_table, ObValues, inner_plan, err_stat))
  {
    TRANS_LOG("ObValues is NULL");
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else if (OB_SUCCESS != (ret = tmp_table->set_child(0, *table_rpc_scan_for_obvalues)))
  {
    YYSYS_LOG(WARN, "failed to set child op for ObValues, err=%d", ret);
  }

  else if (NULL == CREATE_PHY_OPERRATOR(inc_scan_op, ObIncScan, inner_plan, err_stat))
  {
    TRANS_LOG("ObIncScan is NULL");
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else if (NULL == CREATE_PHY_OPERRATOR(fuse_op, ObMultipleGetMerge, inner_plan, err_stat))
  {
    TRANS_LOG("ObMultipleGetMerge is NULL");
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else if (NULL == CREATE_PHY_OPERRATOR(static_data, ObMemSSTableScan, inner_plan, err_stat))
  {
    TRANS_LOG("ObMemSSTableScan is NULL");
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  //add duyr [Delete_Update_Function_isolation] [JHOBv0.1] 20160531:b
  else if (data_mark_param.is_valid()
           && OB_SUCCESS != (ret = inc_scan_op->set_data_mark_param(data_mark_param)))
  {
    YYSYS_LOG(WARN,"fail to set data mark param into inc scan!ret=%d",ret);
  }
  //add duyr 20160531:e
  else if (OB_SUCCESS != (ret = fuse_op->set_child(0, *static_data)))
  {
    YYSYS_LOG(WARN, "failed to set child op for ObMultipleGetMerge, err=%d", ret);
  }
  else if (OB_SUCCESS != (ret = fuse_op->set_child(1, *inc_scan_op)))
  {
    YYSYS_LOG(WARN, "failed to set child op for ObIncScan, err=%d", ret);
  }
  //add duyr [Delete_Update_Function_isolation] [JHOBv0.1] 20160531:b
  else if (data_mark_param.is_valid()
           && OB_SUCCESS != (ret = fuse_op->set_data_mark_param(data_mark_param)))
  {
    YYSYS_LOG(WARN,"fail to set data mark param into ObMultipleGetMerge!ret=%d",ret);
  }
  //add duyr 20160531:e
  else if (NULL == CREATE_PHY_OPERRATOR(get_param_values, ObExprValues, inner_plan, err_stat))
  {
    TRANS_LOG("ObExprValues is NULL");
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else if (NULL == CREATE_PHY_OPERRATOR(fill_values, ObFillValues, inner_plan, err_stat))
  {
    TRANS_LOG("fill_values is NULL");
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_id)))
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("Fail to get table schema for table[%ld]", table_id);
  }
  else if ((ret = inner_plan->add_base_table_version(
              table_id,
              table_schema->get_schema_version()
              )) != OB_SUCCESS)
  {
    TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d", table_id, ret);
  }
  else
  {
    //add shili [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20150721:b
    //����table_id  stmt_type �������ƻ�ִ�е�ʱ��ʹ��
    inner_plan->set_table_id(table_id);
    inner_plan->set_stmt_type(ObBasicStmt::T_UPDATE);
    //add 20150721:e
    //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20151124:b
    inner_plan->set_expr_values_op_id(get_param_values->get_id());
    inner_plan->set_values_op_id(tmp_table->get_id());
    //          physical_plan->set_table_rpc_scan_op_id(table_rpc_scan_op->get_id());
    //add 20151124:e
    //add lijianqiang [sequence] 20150909:b
    YYSYS_LOG(DEBUG, "handle sequence info for update new");
    ObSequence * base_sequence_op = NULL;
    (void)base_sequence_op;
    base_sequence_op = dynamic_cast<ObSequence *> (sequence_op);
    //add 20150909:e
    fuse_op->set_is_ups_row(false);

    //add by maosy [MultiUps 1.0] [batch_iud_snapshot] 20170622 b:
    inner_plan->set_multiple_merge_op_id(fuse_op->get_id());
    // add by e
    inc_scan_op->set_scan_type(ObIncScan::ST_MGET);
    inc_scan_op->set_write_lock_flag();
    inc_scan_op->set_hotspot(stmt->get_query_hint().hotspot_);
    inc_scan_op->set_values(get_param_values->get_id(), false);

    static_data->set_tmp_table(tmp_table->get_id());

    table_rpc_scan_for_obvalues->set_rowkey_cell_count(row_desc.get_rowkey_cell_count());
    table_rpc_scan_for_obvalues->set_need_cache_frozen_data(true);

    get_param_values->set_row_desc(row_desc, row_desc_ext);

    //add output column for table_rpc_scan
    if (is_column_hint_index)
    {
      //add rowkey columns
      for(int64_t key_col_num=0;OB_SUCCESS == ret && key_col_num<rowkey_info.get_size();key_col_num++)
      {
        uint64_t key_cid=OB_INVALID_ID;
        if(OB_SUCCESS!=(ret = rowkey_info.get_column_id(key_col_num,key_cid)))
        {
          YYSYS_LOG(WARN, "Failed to get tid cid, err=%d", ret);
        }
        else
        {
          if(rowkey_info.is_rowkey_column(key_cid))
          {
            ObBinaryRefRawExpr col_expr(table_id, key_cid, T_REF_COLUMN);
            ObSqlRawExpr col_raw_expr(
                  common::OB_INVALID_ID,
                  table_id,
                  key_cid,
                  &col_expr);
            ObSqlExpression output_expr;
            if ((ret = col_raw_expr.fill_sql_expression(
                   output_expr,
                   this,
                   logical_plan,
                   inner_plan)) != OB_SUCCESS
                || (ret = table_rpc_scan_for_obvalues->add_output_column(output_expr)) != OB_SUCCESS)
            {
              TRANS_LOG("Add table output columns faild");
              break;
            }
            if (OB_SUCCESS == ret)
            {
              uint64_t cid = OB_INVALID_ID;
              ret = rowkey_info.get_column_id(key_col_num,cid);
              if (OB_SUCCESS != ret || OB_INVALID_ID == cid)
              {
                ret = (ret != OB_SUCCESS ? ret : OB_ERROR);
                YYSYS_LOG(WARN,"get cid failed!key_col_num=%ld,cid=%ld,ret=%d",
                          key_col_num,cid,ret);
              }
              else
              {
                //add wenghaixing[decimal] for fix delete bug 2014/10/10
                ObObjType cond_val_type;
                uint32_t cond_val_precision;
                uint32_t cond_val_scale;
                ObObj static_obj;
                if(OB_SUCCESS!=sql_context_->schema_manager_->get_cond_val_info(table_id,cid,cond_val_type,cond_val_precision,cond_val_scale))
                {

                }
                else
                {
                  tmp_table->add_rowkey_array(table_id,cid,cond_val_type,cond_val_precision,cond_val_scale);
                  if(ObDecimalType==cond_val_type)
                  {
                    static_obj.set_precision(cond_val_precision);
                    static_obj.set_scale(cond_val_scale);
                    static_obj.set_type(cond_val_type);
                  }
                }
                //add e
              }
            }
          }
        }
      }
      for (int32_t i = 0; ret == OB_SUCCESS && i < row_desc.get_column_num(); i++)
      {
        //const ColumnItem *col_item = stmt->get_column_item(i);
        uint64_t key_cid=OB_INVALID_ID;
        uint64_t tid = OB_INVALID_ID;
        if(OB_SUCCESS != (ret = row_desc.get_tid_cid(i, tid, key_cid)))
        {
          YYSYS_LOG(WARN, "Failed to get tid cid, err=%d", ret);
        }
        else if(!rowkey_info.is_rowkey_column(key_cid))
        {
          //YYSYS_LOG(ERROR, "test::whx out put column[%ld]",i);
          if (table_id == table_item->table_id_)
          {
            ObBinaryRefRawExpr col_expr(table_id, key_cid, T_REF_COLUMN);
            ObSqlRawExpr col_raw_expr(
                  common::OB_INVALID_ID,
                  table_id,
                  key_cid,
                  &col_expr);
            ObSqlExpression output_expr;
            if ((ret = col_raw_expr.fill_sql_expression(
                   output_expr,
                   this,
                   logical_plan,
                   inner_plan)) != OB_SUCCESS
                || (ret = table_rpc_scan_for_obvalues->add_output_column(output_expr)) != OB_SUCCESS)
            {
              TRANS_LOG("Add table output columns faild");
              break;
            }
          }
        }
      }

    }
    else
    {

      int32_t num = stmt->get_column_size();
      for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
      {
        const ColumnItem *col_item = stmt->get_column_item(i);
        OB_ASSERT(col_item);
        if (col_item->table_id_ == table_item->table_id_)
        {
          ObBinaryRefRawExpr col_expr(col_item->table_id_, col_item->column_id_, T_REF_COLUMN);
          ObSqlRawExpr col_raw_expr(
                common::OB_INVALID_ID,
                col_item->table_id_,
                col_item->column_id_,
                &col_expr);
          ObSqlExpression output_expr;
          if ((ret = col_raw_expr.fill_sql_expression(
                 output_expr,
                 this,
                 logical_plan,
                 inner_plan)) != OB_SUCCESS
              || (ret = table_rpc_scan_for_obvalues->add_output_column(output_expr)) != OB_SUCCESS)
          {
            TRANS_LOG("Add columns faild");
            break;
          }
        }
      }

      if (OB_SUCCESS == ret)
      {
        for(int64_t key_col_num=0;OB_SUCCESS == ret && key_col_num<rowkey_info.get_size();key_col_num++)
        {
          uint64_t cid = OB_INVALID_ID;
          ret = rowkey_info.get_column_id(key_col_num,cid);
          if (OB_SUCCESS != ret || OB_INVALID_ID == cid)
          {
            ret = (ret != OB_SUCCESS ? ret : OB_ERROR);
            YYSYS_LOG(WARN,"get cid failed!key_col_num=%ld,cid=%ld,ret=%d",
                      key_col_num,cid,ret);
          }
          else
          {
            //add wenghaixing[decimal] for fix delete bug 2014/10/10
            ObObjType cond_val_type;
            uint32_t cond_val_precision;
            uint32_t cond_val_scale;
            ObObj static_obj;
            if(OB_SUCCESS!=sql_context_->schema_manager_->get_cond_val_info(table_id,cid,cond_val_type,cond_val_precision,cond_val_scale))
            {

            }
            else
            {
              tmp_table->add_rowkey_array(table_id,cid,cond_val_type,cond_val_precision,cond_val_scale);
              if(ObDecimalType==cond_val_type)
              {
                static_obj.set_precision(cond_val_precision);
                static_obj.set_scale(cond_val_scale);
                static_obj.set_type(cond_val_type);
              }
            }
            //add e
          }
        }
      }
    }
    ObPhyOperator * sub_query_operator = NULL;
    if(OB_SUCCESS == ret /*&& ObBasicStmt::T_EXPLAIN != logical_plan->get_main_stmt()->get_stmt_type()*/)
    {
      bool is_non_where_conditon = false;
      ParseNode* ud_where_parse_tree = stmt->get_ud_where_parse_tree();
      std::string column_names;
      std::string table_name;
      //get column_names and table_name from udpate stmt
      if ( OB_SUCCESS != (ret=get_column_name_table_name(column_names,table_name,table_item,row_desc
                                                         )))
      {
        YYSYS_LOG(WARN,"fail to get column_name[%s] and table_name[%s]",column_names.data(),table_name.data());
      }
      else
      {
        if (0 >= stmt->get_condition_size())
        {
          is_non_where_conditon = true;
        }
        int32_t select_operator_id = OB_INVALID_INDEX;
        //����select���
        if (OB_SUCCESS != (ret = constuct_top_operator_of_select(is_non_where_conditon,
                                                                 ud_where_parse_tree,
                                                                 physical_plan,
                                                                 column_names,
                                                                 table_name,
                                                                 select_operator_id,
                                                                 err_stat)))
        {
          YYSYS_LOG(WARN,"fail to construct top operator of select");
        }
        else
        {
          if(NULL == (sub_query_operator = physical_plan->get_phy_query(select_operator_id)))
          {
            ret = OB_INVALID_INDEX;
            TRANS_LOG("wrong get sub query operator");
          }
          // add by maosy [MultiUps 1.0] [batch_udi] 20170420 b
          //                    ObTableRpcScan * table_rpc_scan = NULL;
          //                    if(OB_SUCCESS !=(ret = get_table_rpc_scan(sub_query_operator,table_rpc_scan,table_id) ))
          //                    {
          //                        YYSYS_LOG(WARN,"failed to get table rpc scan ,ret = %d",ret );
          //                    }
          //                    else if(OB_SUCCESS !=(ret = table_rpc_scan->set_data_mark_param(data_mark_param)))
          //                    {
          //                        YYSYS_LOG(WARN,"failed to set data mark ,ret = %d",ret );
          //                    }
          //                    else
          //                    {
          //                        ObBinaryRefRawExpr col_expr(table_id, data_mark_param.modify_time_cid_, T_REF_COLUMN);
          //                        ObSqlRawExpr col_raw_expr(
          //                                    common::OB_INVALID_ID,
          //                                    table_id,
          //                                    data_mark_param.modify_time_cid_,
          //                                    &col_expr);
          //                        ObSqlExpression output_expr;
          //                        if ((ret = col_raw_expr.fill_sql_expression(
          //                                 output_expr,
          //                                 this,
          //                                 logical_plan,
          //                                 inner_plan)) != OB_SUCCESS
          //                                || (ret = dynamic_cast<ObProject*>(sub_query_operator)->add_output_column(output_expr)) != OB_SUCCESS)
          //                        {
          //                            TRANS_LOG("Add columns faild");
          //                        }
          //                       // dynamic_cast<ObProject *>(sub_query_operator)->add_output_column()
          //                    }
        }
      }
    }
    if (OB_SUCCESS == ret)
    {
      int64_t  rowkey_num = rowkey_info.get_size();
      uint64_t column_id  = OB_INVALID_ID;
      //            if (data_mark_param.is_inited())
      //            {
      //                if (OB_SUCCESS != (ret = const_cast<ObRowDesc*>(&row_desc)->add_column_desc(data_mark_param.table_id_,
      //                                                                                            data_mark_param.modify_time_cid_)))
      //                {
      //                    TRANS_LOG("failed to add row desc, err=%d", ret);
      //                }
      //            }
      if (OB_SUCCESS == ret)
      {
        tmp_table->set_table_id(table_id);
        tmp_table->set_rowkey_num(rowkey_num);
        tmp_table->set_row_desc(row_desc);
        YYSYS_LOG(DEBUG,"row_desc[%s]",to_cstring(row_desc));
        for (int64_t index=0;OB_SUCCESS == ret && index<rowkey_num;index++)
        {
          if (OB_SUCCESS != (ret = rowkey_info.get_column_id(index,column_id)))
          {
            YYSYS_LOG(WARN,"fail to get column id,ret[%d]",ret);
          }
          else if (OB_SUCCESS != (ret = tmp_table->set_column_ids(column_id)))
          {
            YYSYS_LOG(WARN,"fail to set column id,ret[%d]",ret);
          }
          // add by maosy 20170420 e
        }
      }
    }
    if(OB_SUCCESS !=ret )
    {}
    else if ( OB_SUCCESS != (ret = fill_values->set_child(0, *tmp_table)))
    {
      YYSYS_LOG(WARN, "failed to set table_rpc_scan_for_obexpr op, err=%d", ret);
    }
    else if ( OB_SUCCESS != (ret = fill_values->set_child(1, *get_param_values)))
    {
      YYSYS_LOG(WARN, "failed to set get_param_values op, err=%d", ret);
    }
    else if(OB_SUCCESS !=(ret = fill_values->set_child(2,*sub_query_operator)))
    {
      YYSYS_LOG(INFO,"TEST");
    }
    else if ( OB_SUCCESS != (ret = inner_plan->add_phy_query(fill_values)))
    {
      YYSYS_LOG(WARN, "failed to add fill_values to sub query, err=%d", ret);
    }
    else
    {
      table_op = fuse_op;
      if (OB_SUCCESS == ret)
      {
        fill_values->set_rowkey_info(rowkey_info);
        fill_values->set_row_desc(row_desc);
        fill_values->set_is_column_hint_index(is_column_hint_index);
        fill_values->set_sql_context(*sql_context_);
        get_param_values->set_from_ud(true);
        if(stmt->get_query_hint ().change_value_size_)
        {
          int64_t max_row_size = static_cast<int64_t>(0.8*1024L*1024L);
          fill_values->set_max_row_value_size (max_row_size);
        }
        //                fill_values->add_modify_cid(data_mark_param.modify_time_cid_);
        //add lijianqiang [update_sequence] 20151218:b
        fill_values->set_sequence_update(sequence_op);
        //add 20151218:e
        //add wenghaixing[decimal] for fix delete bug 2014/10/10
        tmp_table->set_fix_obvalues();
        get_param_values->set_del_upd();
        //add e
      }
    }// end else
  }
  return ret;
}
// add by maosy [MultiUps 1.0] [batch_udi] 20170420 b
int ObTransformer::get_table_rpc_scan(ObPhyOperator *phy_operator, ObTableRpcScan *&table_rpc_scan, uint64_t table_id)
{
  int ret = OB_ERROR ;
  if(table_rpc_scan ==NULL)
  {
    ObTableRpcScan *tmp_rpc_scan = NULL;
    /*����������ʱ����ܻ������⣬�Ҳ���������tid*/
    if(NULL != (tmp_rpc_scan = dynamic_cast<ObTableRpcScan*>(phy_operator))
       && tmp_rpc_scan->get_rpc_scan().get_main_table_id() == table_id)
    {
      table_rpc_scan =   dynamic_cast<ObTableRpcScan*>(phy_operator) ;
      ret = OB_SUCCESS ;
    }
    else
    {
      for(int i =0 ; i < phy_operator->get_child_num();i++)
      {
        ret = get_table_rpc_scan(phy_operator->get_child(i),table_rpc_scan,table_id);
        if(table_rpc_scan !=NULL && OB_SUCCESS ==ret )
        {
          break;
        }
      }
    }// end else
  }
  return ret;
}
// add by maosy 20170420 e

/***************************************************************
Function:    constuct_top_operator_of_select
Description: construct the top operator of select stmt and store this operator into ObFillValues.
             Constructed operator is opened in function open of ObFillValues, and used to fetch ud
             data from CS.
Calls:
Input:       logical_plan and physical_plan are used in fill_sql_expression function,and rowkey_info supplys the rowkey information
Output:      ud_result_set,
Returns:     ret
Others:
***************************************************************/

int ObTransformer::constuct_top_operator_of_select(bool is_non_where_condition,
                                                   ParseNode* ud_where_parse_tree,
                                                   ObPhysicalPlan *&physical_plan,
                                                   std::string column_names,
                                                   std::string table_name,
                                                   int32_t &select_opeartor_id,
                                                   ErrStat& err_stat)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ParseResult select_parse_result;
  common::ObString prepare_select_string;
  ParseNode* select_syntax_tree = NULL;
  //modify hongchen [BATCH_SKEW] 20170710:b
  //std::string select_part = "select /*+READ_ATOMIC_WEAK , +READ_CONSISTENCY(STRONG)*/ ";
  std::string select_part = "select /*+READ_CONSISTENCY(STRONG)*/ ";
  //modify hongchen [BATCH_SKEW] 20170710:e
  std::string from_part = " from ";
  std::string temp_result = "";
  temp_result = select_part + column_names + from_part + table_name;
  prepare_select_string = ObString::make_string(temp_result.data());
  if(OB_SUCCESS != (ret = (get_parse_result(prepare_select_string,select_parse_result))))
  {
    YYSYS_LOG(WARN,"fail to get parse result");
  }
  else
  {
    select_syntax_tree = select_parse_result.result_tree_;
    if(select_syntax_tree && select_syntax_tree->children_[0] )
    {
    }
    else
    {
      YYSYS_LOG(WARN,"fail to get the top node of select-parse-tree");
      ret = OB_ERROR;
    }
  }
  //generate the parse tree of select stmt
  if(OB_SUCCESS ==ret && !is_non_where_condition)
  {
    //glue the where-parse-tree of ud to select-parse-tree generated
    if(select_syntax_tree->children_[0] )
    {
      select_syntax_tree->children_[0]->children_[3] = ud_where_parse_tree;
    }
    else
    {
      YYSYS_LOG(WARN,"fail to get the first node of select-parse-tree,select_syntax_tree->children_[1]=%p\
                select_syntax_tree->children_[1]->children_[0]=%p", select_syntax_tree->children_[0]\
                                                               ,select_syntax_tree->children_[0]->children_[1]);
      ret = OB_ERROR;
    }
  }
  //call ObSql::direct_execute to generate top operator of select stmt
  if (OB_SUCCESS == ret)
  {
    // add by maosy
    ResultPlan result_plan;
    result_plan.is_prepare_ = sql_context_->is_prepare_protocol_ ? 1 : 0;
    common::ObStringBuf &parser_mem_pool = sql_context_->session_info_->get_parser_mem_pool();
    result_plan.name_pool_ = &parser_mem_pool;
    ObSchemaChecker *schema_checker =  (ObSchemaChecker*)parse_malloc(sizeof(ObSchemaChecker), result_plan.name_pool_);
    if (NULL == schema_checker)
    {
      YYSYS_LOG(WARN, "out of memory");
      ret = OB_ERR_PARSER_MALLOC_FAILED;
    }
    else
    {
      schema_checker->set_schema(*sql_context_->schema_manager_);
      result_plan.schema_checker_ = schema_checker;
      result_plan.plan_tree_ = NULL;
      if (NULL == sql_context_->session_info_)
      {
        ret = OB_ERR_SESSION_UNSET;
        YYSYS_LOG(WARN,"failed to get context `s session info,sql context = %p ",sql_context_);
      }
      //20150430:e
      else
      {
        uint64_t select_query_id = OB_INVALID_ID;
        result_plan.session_info_ = sql_context_->session_info_;
        if(OB_SUCCESS !=(ret = resolve_select_stmt(&result_plan,select_syntax_tree->children_[0],select_query_id)))
        {
          YYSYS_LOG(WARN,"failed to logical plan ,ret = %d",ret);
        }
        else
        {
          ObLogicalPlan *logic_plan = NULL;
          logic_plan = static_cast<ObLogicalPlan*>(result_plan.plan_tree_);
          select_opeartor_id = OB_INVALID_INDEX;
          physical_plan->set_insert_select_flag(true);
          if(OB_SUCCESS != (ret = gen_physical_select(logic_plan, physical_plan, err_stat, select_query_id, &select_opeartor_id)))
          {
            TRANS_LOG("generating physical plan for sub-query error, err=%d", ret);
          }
          else if(OB_INVALID_INDEX == select_opeartor_id)
          {
            YYSYS_LOG(ERROR, "generating physical plan for sub-query error");
            ret = OB_ERROR;
          }
        }
      }
    }
    ObMultiLogicPlan *multi_logic_plan = static_cast<ObMultiLogicPlan *>(result_plan.plan_tree_);
    multi_logic_plan->~ObMultiLogicPlan();
  }
  return ret;
}

int ObTransformer::get_column_name_table_name(std::string &column_names,
                                              std::string &table_name,
                                              TableItem* table_item, const ObRowDesc &row_desc
                                              )
{
  int ret = OB_SUCCESS;
  std::string comm = ",";
  std::string mark_l = "\"";// for fix some column is daxie
  int64_t num = row_desc.get_column_num ();

  for (int64_t i = 0; i < num; i++)
  {
    uint64_t tid = OB_INVALID_ID;
    uint64_t cid = OB_INVALID_ID;
    const ObColumnSchemaV2* column_schema = NULL;
    if(OB_SUCCESS != (ret = row_desc.get_tid_cid (i,tid,cid)))
    {
      YYSYS_LOG(WARN,"failed to get tid and cid from row desc =%s,ret = %d",to_cstring(row_desc),ret);
    }
    else if (NULL == (column_schema = sql_context_->schema_manager_->get_column_schema(tid, cid)))
    {
      YYSYS_LOG(WARN,"failed to get table = %lu, column = %lu schema",tid,cid);
    }
    else
    {
      const char* column_name = column_schema->get_name ();
      if(0 == i)
      {
        column_names = mark_l + column_name + mark_l;
      }
      else
      {
        column_names = column_names + comm + mark_l + column_name + mark_l ;
      }
    }
    YYSYS_LOG(DEBUG,"COLUMN-NAMES=%s",column_names.data());//add by gaojt-test
  }

  char tmp_table_name[table_item->table_name_.length()+1];
  char alias_table_name[table_item->alias_name_.length()+1];

  memset(tmp_table_name, 0, sizeof(tmp_table_name));
  sprintf(tmp_table_name,"%.*s",table_item->table_name_.length(),table_item->table_name_.ptr());

  table_name = tmp_table_name;
  int pos = -1;
  if(-1 != (pos = static_cast<int>(table_name.find('.'))))
  {
    // add by maosy  [Delete_Update_Function]
    char database_name [pos+1];
    //        char need_erase[5]="TANG";
    memset(database_name,0,sizeof(database_name));
    strncpy(database_name,tmp_table_name,pos);
    database_name[pos] = '\0';
    table_name = table_name.erase(0,pos+1);
    // table_name = table_name.erase(0,pos+1);
    table_name = mark_l +database_name +mark_l + "." +mark_l+table_name+mark_l ;
    // add e
    if (table_item->alias_name_.length() > 0)
    {
      memset(alias_table_name, 0, sizeof(alias_table_name));
      sprintf(alias_table_name,"%.*s",table_item->alias_name_.length(),table_item->alias_name_.ptr());
      table_name = table_name + " as " + mark_l + alias_table_name + mark_l;
    }
  }
  return ret;
}


int ObTransformer::get_parse_result(const ObString &select_stmt, ParseResult &select_parse_result)
{
  int ret = OB_SUCCESS;
  //generate select syntax_tree
  if (OB_SUCCESS != (ret = (gene_parse_result(select_stmt,select_parse_result))))
  {
    YYSYS_LOG(WARN,"fail to get select parse result");
  }
  return ret;
}

int ObTransformer::gene_parse_result(const ObString &query_string, ParseResult &syntax_tree)
{
  int ret = OB_SUCCESS;

  common::ObStringBuf &parser_mem_pool = sql_context_->session_info_->get_parser_mem_pool();

  syntax_tree.malloc_pool_ = &parser_mem_pool;
  if (OB_SUCCESS != (ret = parse_init(&syntax_tree)))
  {
    ret = OB_ERR_PARSER_INIT;
  }
  else
  {
    if (parse_sql(&syntax_tree, query_string.ptr(), static_cast<size_t>(query_string.length())) != OB_SUCCESS
        || NULL == syntax_tree.result_tree_)
    {
      ret = OB_ERR_PARSER_SYNTAX;
    }
  }
  return ret;
}

/****************************************************************
 Function:    is_multi_delete_update
 Description: used to determine the inputting SQL whether fits the conditions of original delete SQL
 Calls:
 Input:       logical_plan and physical_plan are used in fill_sql_expression function,and rowkey_info
              supplys the rowkey information
 Output:      is_multi_delete
 Returns:     ret
 Others:
 ***************************************************************/
int ObTransformer::is_multi_delete_update(ObLogicalPlan *logical_plan,
                                          ObPhysicalPlan*& physical_plan,
                                          const ObRowkeyInfo &rowkey_info,
                                          ObStmt *stmt,
                                          ErrStat& err_stat,
                                          bool& is_multi_delete_update)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  int32_t num = stmt->get_condition_size();
  uint64_t cid = OB_INVALID_ID;
  int64_t cond_op = T_INVALID;
  //int cnd_expr_type = 0;//add by maosy [Delete_Update_Function][prepare question mark ] 20170519
  ObObj cond_val;
  ObPostfixExpression::ObPostExprNodeType val_type = ObPostfixExpression::BEGIN_TYPE;
  ObRowDesc rowkey_col_map;
  for (int32_t i = 0; i < num; i++)
  {
    ObSqlRawExpr *cnd_expr = logical_plan->get_expr(stmt->get_condition_id(i));
    OB_ASSERT(cnd_expr);
    //add by maosy [Delete_Update_Function][prepare question mark ] 20170519
    //cnd_expr_type = static_cast<int>(cnd_expr->get_expr()->get_expr_type());
    //if(cnd_expr->get_expr()->is_equal_filter())
    if(cnd_expr->get_expr()->is_equal_filter_expend())
    {
      cnd_expr->set_applied(true);
      // add by maosy e
      YYSYS_LOG(DEBUG,"The %dth condition' is not sub-query's type is %d",i,cnd_expr->get_expr()->get_expr_type());
      ObSqlExpression *filter = ObSqlExpression::alloc();
      if (NULL == filter)
      {
        TRANS_LOG("no memory");
        ret = OB_ALLOCATE_MEMORY_FAILED;
        break;
      }
      else if (OB_SUCCESS != (ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan)))
      {
        ObSqlExpression::free(filter);
        TRANS_LOG("Failed to fill expression, err=%d", ret);
        break;
      }
      else if (filter->is_simple_condition(false, cid, cond_op, cond_val, &val_type)
               && (T_OP_EQ == cond_op || T_OP_IS == cond_op)
               && rowkey_info.is_rowkey_column(cid))
      {
        if (OB_SUCCESS != (ret = rowkey_col_map.add_column_desc(OB_INVALID_ID, cid)))
        {
          TRANS_LOG("Failed to add column desc, err=%d", ret);
          break;
        }
      }
      if(NULL != filter)
      {
        ObSqlExpression::free(filter);
      }
    }
  }
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    int64_t rowkey_col_num = rowkey_info.get_size();
    uint64_t cid = OB_INVALID_ID;
    for (int64_t i = 0; i < rowkey_col_num; ++i)
    {
      if (OB_SUCCESS != (ret = rowkey_info.get_column_id(i, cid)))
      {
        TRANS_LOG("Failed to get column id, err=%d", ret);
        break;
      }
      else if (OB_INVALID_INDEX == rowkey_col_map.get_idx(OB_INVALID_ID, cid))
      {
        is_multi_delete_update = true;
        YYSYS_LOG(DEBUG,"is_multi_delete_update=%d",is_multi_delete_update);
        break;
      }
    } // end for
  }
  return ret;
}

int ObTransformer::get_fillvalues_operator(ObPhyOperator *main_query,ObPhyOperator *&fill_values)
{
  int ret = OB_SUCCESS;
  ObIudLoopControl *insert_loop = NULL;
  ObPhysicalPlan* inner_plan = NULL;
  ObUpsExecutor* ups_executor = NULL;
  if ((insert_loop = dynamic_cast<ObIudLoopControl*>(main_query)) == NULL
      || (ups_executor = dynamic_cast<ObUpsExecutor*>(insert_loop->get_child(0))) == NULL
      || (inner_plan = ups_executor->get_inner_plan()) == NULL)
  {
    ret = OB_NOT_INIT;
    YYSYS_LOG(ERROR, "This is the wrong Update or delete physical tree, insert_loop=%p inner_plan=%p"\
              "ups_executor=%p",insert_loop, inner_plan, ups_executor);
  }
  else
  {
    for (int32_t index = 0; OB_SUCCESS == ret && index < inner_plan->get_query_size(); ++index)
    {
      ObPhyOperator* aux_query = inner_plan->get_phy_query(index);
      if ( (fill_values = dynamic_cast<ObFillValues*>(aux_query))!=NULL)
      {
        break;
      }
    }
  }
  return ret;
}

//add gaojt 20150817:e
//add dolphin [database manager]@20150617:b
int ObTransformer::check_dbname_for_table(ErrStat& err_stat,const ObString& dbname)
{
  int ret = OB_SUCCESS;
  const ObPrivilege ** privilege = NULL;
  sql_context_->privilege_mgr_->get_newest_privilege(privilege);
  if (privilege == NULL)
  {
    ret = OB_ERROR;
    YYSYS_LOG(ERROR,"get privilege failed.");
  }
  if(OB_SUCCESS == ret )
  {
    const ObPrivilege::NameDbMap *ndm = (*privilege)->get_database_name_map();
    const ObPrivilege::ObDatabase *odb = ndm->get(dbname);

    if (odb == NULL)
    {
      ret = OB_ERR_DATABASE_NOT_EXSIT;
      TRANS_LOG("database %.*s not exist, may have not been sychronize to schema manager,try it again.", dbname.length(), dbname.ptr());
    }
  }
  if (privilege != NULL)
  {
    int tmp_err = sql_context_->privilege_mgr_->release_privilege(privilege);
    if (OB_SUCCESS != tmp_err)
    {
      YYSYS_LOG(WARN, "release privilege failed, ret=%d", tmp_err);
    }
  }
  return ret;
}
//add:e
//add by wenghaixing [secondary index]20141024
int ObTransformer::gen_physical_create_index(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObCreateIndexStmt *crt_idx_stmt = NULL;
  ObCreateTable *crt_tab_op = NULL;
  //add wenghaixing 20141029
  // uint64_t magic_cid=OB_APP_MIN_COLUMN_ID;
  IndexHelper ih;
  //add e
  //add wenghaixing [secondary index] 20141111
  uint64_t max_col_id = 0;
  //add e
  bool rowkey_will_add_in = true;
  int64_t column_num = 0;
  int64_t this_index_col_num = 0;
  ObStrings expire_col;//for expire infomation
  ObString val;//for expire infomation
  /*get create index statement*/
  if(OB_SUCCESS == ret)
  {
    get_stmt(logical_plan,err_stat,query_id,crt_idx_stmt);
  }
  /*generate operator to create index table*/
  if(OB_SUCCESS == ret)
  {
    CREATE_PHY_OPERRATOR(crt_tab_op,ObCreateTable,physical_plan,err_stat);
    if(OB_SUCCESS == ret)
    {
      crt_tab_op->set_sql_context(*sql_context_);
      ret = add_phy_query(logical_plan,physical_plan,err_stat,query_id,crt_idx_stmt,crt_tab_op,index);
    }
  }
  /*if(ret==OB_SUCCESS)
    {
        if(crt_idx_stmt->get_index_colums_count()>OB_MAX_INDEX_COLUMNS)
        {
            TRANS_LOG("Too many columns in index!(max allowed is %ld).",
                     OB_MAX_USER_DEFINED_COLUMNS_COUNT);
            ret = OB_ERR_INVALID_COLUMN_NUM;
        }
    }
    */
  /*set table schema for phy_oprator*/
  if(OB_SUCCESS == ret)
  {
    int buf_len = 0;
    int len = 0;
    TableSchema& table_schema = crt_tab_op->get_table_schema();
    const ObTableSchema* idxed_tab_schema=NULL;
    const ObString& index_name = crt_idx_stmt->get_index_label();
    // buf_len = sizeof(table_schema.table_name_);
    if (index_name.length() < OB_MAX_TABLE_NAME_LENGTH)
    {
      len = index_name.length();
    }
    else
    {
      len = OB_MAX_TABLE_NAME_LENGTH - 1;
      TRANS_LOG("Table name is truncated to '%.*s'", len, index_name.ptr());
    }
    memcpy(table_schema.table_name_, index_name.ptr(), len);
    table_schema.table_name_[len] = '\0';
    /*Now We Must take source table's schema to fix index schema*/
    const ObString& idxed_tab_name=crt_idx_stmt->get_idxed_name();
    //add liumz [database manager]@20150721:b
    ObString db_name, table_name;
    char db_name_buf[OB_MAX_DATBASE_NAME_LENGTH] = {0};
    char table_name_buf[OB_MAX_TABLE_NAME_LENGTH] = {0};
    db_name.assign_buffer(db_name_buf, OB_MAX_DATBASE_NAME_LENGTH);
    table_name.assign_buffer(table_name_buf, OB_MAX_TABLE_NAME_LENGTH);
    bool split_ret = idxed_tab_name.split_two(db_name, table_name);
    if(!split_ret)
    {
      TRANS_LOG("Wrong table name [%.*s]!", idxed_tab_name.length(), idxed_tab_name.ptr());
      ret = OB_ERROR;
    }
    else
    {
      if (db_name.length() < OB_MAX_DATBASE_NAME_LENGTH)
      {
        len = db_name.length();
      }
      else
      {
        len = OB_MAX_DATBASE_NAME_LENGTH - 1;
        TRANS_LOG("Database name is truncated to '%.*s'", len, db_name.ptr());
      }
      memcpy(table_schema.dbname_, db_name.ptr(), len);
      table_schema.dbname_[len] = '\0';
    }
    //add:e
    //modify liuxiao [secondary index bug fixed] 20150722
    //char str_tname[common::OB_MAX_COLUMN_NAME_LENGTH],str_cname[common::OB_MAX_COLUMN_NAME_LENGTH];
    //memset(str_tname,0,common::OB_MAX_COLUMN_NAME_LENGTH);
    //memcpy(str_tname,idxed_tab_name.ptr(),idxed_tab_name.length());

    char str_tname[common::OB_MAX_TABLE_NAME_LENGTH],str_cname[common::OB_MAX_COLUMN_NAME_LENGTH];
    memset(str_tname,0,common::OB_MAX_COLUMN_NAME_LENGTH);
    memcpy(str_tname,idxed_tab_name.ptr(),idxed_tab_name.length());
    str_tname[common::OB_MAX_TABLE_NAME_LENGTH-1]='\0';
    //modify e
    if (NULL == (idxed_tab_schema = sql_context_->schema_manager_->get_table_schema(str_tname)))
    {
      ret = OB_ERR_ILLEGAL_ID;
      TRANS_LOG("Fail to get table schema for table[%s]", str_tname);
    }
    if(OB_SUCCESS == ret)
    {
      /* refresh expior condition of index schema*/
      ObString expire_info;
      expire_info.assign_ptr((char*)idxed_tab_schema->get_expire_condition(),static_cast<int32_t>(strlen(idxed_tab_schema->get_expire_condition())));
      if (expire_info.length() < OB_MAX_EXPIRE_CONDITION_LENGTH)
      {
        len = expire_info.length();
      }
      else
      {
        len = OB_MAX_EXPIRE_CONDITION_LENGTH - 1;
        TRANS_LOG("Expire_info is truncated to '%.*s'", len, expire_info.ptr());
      }
      memcpy(table_schema.expire_condition_, expire_info.ptr(), len);
      table_schema.expire_condition_[len] = '\0';
      if(idxed_tab_schema->get_expire_condition()[0]!='\0')
      {
        /*�����ʱ��Ϣ���е���û���������е��У���ô��Ҫ�������������ӳ�ʱ��Ϣ�漰������*/ //repaired from messy code by zhuxh 20151014
        const ObColumnSchemaV2* oc_expire=NULL;
        if(OB_SUCCESS != (ret = generate_expire_col_list(expire_info,expire_col)))
        {
          YYSYS_LOG(WARN,"generate expire col list error");
        }
        else
        {
          for(int64_t i=0;i<expire_col.count();i++)
          {
            val.reset();
            if(OB_SUCCESS != (ret = expire_col.get_string(i,val)))
            {
              YYSYS_LOG(WARN,"get expire error");
              break;
            }
            else if(NULL == (oc_expire = sql_context_->schema_manager_->get_column_schema(idxed_tab_name,val)))
            {
              YYSYS_LOG(WARN,"get expire column schema error,col [%.*s]",val.length(),val.ptr());
            }
            else if(!crt_idx_stmt->is_col_expire_in_storing(val)&&!idxed_tab_schema->get_rowkey_info().is_rowkey_column(oc_expire->get_id()))
            {
              crt_idx_stmt->set_storing_columns_simple(val);
              //YYSYS_LOG(ERROR,"test::whx set_storing_columns_simple,[%.*s]",val.length(),val.ptr());
            }
          }
        }
      }
      /* refresh comment_str condition of index schema*/
      ObString comment_str;
      comment_str.assign_ptr((char*)idxed_tab_schema->get_comment_str(),static_cast<int32_t>(strlen(idxed_tab_schema->get_comment_str())));
      //buf_len = sizeof(table_schema.comment_str_);
      if (comment_str.length() < OB_MAX_TABLE_COMMENT_LENGTH)
      {
        len = comment_str.length();
      }
      else
      {
        len = OB_MAX_TABLE_COMMENT_LENGTH - 1;
        TRANS_LOG("Comment_str is truncated to '%.*s'", len, comment_str.ptr());
      }
      memcpy(table_schema.comment_str_, comment_str.ptr(), len);
      table_schema.comment_str_[len] = '\0';
      /*refresh other infomation*/
      crt_tab_op->set_if_not_exists(false);
      //if (crt_tab_stmt->get_tablet_max_size() > 0)
      //we set some paramer with default value
      table_schema.tablet_max_size_ =idxed_tab_schema->get_max_sstable_size();
      table_schema.tablet_block_size_ = idxed_tab_schema->get_block_size();
      table_schema.replica_num_ = (int32_t)idxed_tab_schema->get_replica_count();
      table_schema.is_use_bloomfilter_ = idxed_tab_schema->is_use_bloomfilter();
      table_schema.consistency_level_ = idxed_tab_schema->get_consistency_level();
      table_schema.rowkey_column_num_ = (int32_t)idxed_tab_schema->get_rowkey_info().get_size()+(int32_t)crt_idx_stmt->get_index_colums_count();
      //add wenghaixing 20141029
      table_schema.table_id_=OB_INVALID_ID;
      table_schema.max_used_column_id_=OB_ALL_MAX_COLUMN_ID;
      //add e
      ObString compress_method;
      compress_method.assign_ptr((char*)idxed_tab_schema->get_compress_func_name(),
                                 static_cast<int32_t>(strlen(idxed_tab_schema->get_compress_func_name())));
      //buf_len = sizeof(table_schema.compress_func_name_);
      const char *func_name = compress_method.ptr();
      len = compress_method.length();
      if (len <= 0)
      {
        func_name = OB_DEFAULT_COMPRESS_FUNC_NAME;
        len = static_cast<int>(strlen(OB_DEFAULT_COMPRESS_FUNC_NAME));
      }
      if (len >= OB_MAX_TABLE_NAME_LENGTH)
      {
        len = OB_MAX_TABLE_NAME_LENGTH - 1;
        TRANS_LOG("Compress method name is truncated to '%.*s'", len, func_name);
      }
      memcpy(table_schema.compress_func_name_, func_name, len);
      table_schema.compress_func_name_[len] = '\0';
      /* Now We Refresh Columns Info of index*/
      //ObString idxed_tname=crt_idx_stmt->get_idxed_name();
      uint64_t tid = idxed_tab_schema->get_table_id();
      ObRowkeyInfo ori = idxed_tab_schema->get_rowkey_info();
      //modify wenghaixing [secondary index static_index_build]20150317
      //ih.idx_tid=OB_FLAG_TID;
      //add liuxiao [muti database] 20150702
      /*const ObString index_table_name_with_dbname = ObString::make_string(idxed_tab_schema->get_table_name());
       ObString db_name;
       ObString org_table_name;
       char ptr_db_name[OB_MAX_DATBASE_NAME_LENGTH + 1];
       db_name.assign_buffer(ptr_db_name, OB_MAX_DATBASE_NAME_LENGTH + 1);

       char ptr_table_name[OB_MAX_TABLE_NAME_LENGTH + 1];
       org_table_name.assign_buffer(ptr_table_name, OB_MAX_TABLE_NAME_LENGTH + 1);

       bool split_ret = index_table_name_with_dbname.split_two(db_name, org_table_name);
       if(!split_ret)
       {
         TRANS_LOG("Name is too long!");
         ret = OB_ERROR;
       }
       else
       {
         strncpy(table_schema.dbname_, db_name.ptr(), db_name.length());
         // add zhangcd [multi_database.seconary_index] 20150721:b
         table_schema.dbname_[db_name.length()] = 0;
         // add:e
       }*/
      //add e
      ih.tbl_tid = tid;
      ih.status = INDEX_INIT;
      //modify e
      int64_t rowkey_id=0;
      for(int64_t i = 0;OB_SUCCESS == ret&&i<crt_idx_stmt->get_index_colums_count()+ori.get_size();i++)
      {
        ColumnSchema col;
        ObString col_name;
        uint64_t cid;
        /*����ط����ܻ�����⣬Ҫע��review�´���*/
        const ObColumnSchemaV2* ocs2=NULL;
        if(i<crt_idx_stmt->get_index_colums_count())
        {
          col_name.reset();
          col_name = crt_idx_stmt->get_index_columns(i);
          memset(str_cname,0,common::OB_MAX_COLUMN_NAME_LENGTH);
          memcpy(str_cname,col_name.ptr(),col_name.length());
          ocs2 = sql_context_->schema_manager_->get_column_schema(str_tname,str_cname);
          if(NULL == ocs2)
          {
            ret=OB_ERR_INVALID_SCHEMA;
            YYSYS_LOG(ERROR,"get source table column schema error,t_name=%s,col_name=%s",
                      str_tname,str_cname);
          }
          else
          {
            cid = ocs2->get_id();
            if(idxed_tab_schema->get_rowkey_info().is_rowkey_column(cid))
            {
              if(OB_SUCCESS != (ret = crt_idx_stmt->push_hit_rowkey(cid)))
              {
                ret = OB_ERROR;
                YYSYS_LOG(WARN,"push rowkey in hit array failed");
              }
              else
              {
                table_schema.rowkey_column_num_--;
              }
            }
            rowkey_will_add_in = true;
            rowkey_id++;
            //column_num++;
          }
        }
        else
        {
          col_name.reset();
          int64_t rowkey_seq = i-crt_idx_stmt->get_index_colums_count();
          ori.get_column_id(rowkey_seq,cid);
          ocs2 = sql_context_->schema_manager_->get_column_schema(tid,cid);
          if(NULL == ocs2)
          {
            ret = OB_ERR_INVALID_SCHEMA;
            YYSYS_LOG(ERROR,"get source table column schema error,t_name=%s,col_name=%s",
                      str_tname,str_cname);
          }
          else
          {
            col_name.assign_ptr((char*)ocs2->get_name(),static_cast<int32_t>(strlen(ocs2->get_name())));
            if(crt_idx_stmt->is_rowkey_hit(cid))
            {
              rowkey_will_add_in = false;
            }
            else
            {
              rowkey_will_add_in = true;
              rowkey_id++;
              //column_num++;
            }
          }
        }
        if(OB_SUCCESS == ret&&rowkey_will_add_in)
        {
          col.column_id_ = ocs2->get_id();
          //add wenghaixing [secondary index] 20141111
          if(col.column_id_ > max_col_id)
          {
            max_col_id = col.column_id_;
          }
          //add e
          buf_len = sizeof(col.column_name_);
          if (col_name.length() < buf_len)
          {
            len = col_name.length();
          }
          else
          {
            len = buf_len - 1;
            TRANS_LOG("Column name is truncated to '%s'",str_cname);
          }
          memcpy(col.column_name_, col_name.ptr(), len);
          col.column_name_[len] = '\0';
          col.data_type_ = ocs2->get_type();
          //modify liuxiao [secondary index bug fix] 20150715
          //col.data_length_ = ocs2->get_default_value().get_val_len();
          col.data_length_ = ocs2->get_size();
          //modify e
          if (col.data_type_ == ObVarcharType && 0 > col.data_length_)
          {
            col.data_length_ = OB_MAX_VARCHAR_LENGTH;
          }
          col.length_in_rowkey_ = ocs2->get_default_value().get_val_len();
          col.data_precision_ = ocs2->get_precision();
          col.data_scale_ = ocs2->get_scale();
          col.nullable_ = ocs2->is_nullable();
          col.rowkey_id_ = rowkey_id;
          col.column_group_id_ = ocs2->get_column_group_id();
          col.join_table_id_ = OB_INVALID_ID;
          col.join_column_id_ = OB_INVALID_ID;
          // col.column_id_=cid;
          this_index_col_num ++;
          if (OB_SUCCESS != (ret = table_schema.add_column(col)))
          {
            TRANS_LOG("Add column definition of '%s' failed", table_schema.table_name_);
            break;
          }

          if (OB_SUCCESS == ret)
          {
            /*if (OB_SUCCESS != (ret = allocate_column_id(table_schema)))
              {
                YYSYS_LOG(WARN, "fail to allocate column id:ret[%d]", ret);
              }
              */
            //column_num++;
          }
        }
      }
      if(OB_SUCCESS == ret)
      {
        if(crt_idx_stmt->get_storing_columns_count()>0)
        {
          crt_idx_stmt->set_has_storing(true);
        }
        for(int64_t i = 0;OB_SUCCESS == ret&&i<crt_idx_stmt->get_storing_columns_count();i++)
        {
          const ObColumnSchemaV2* ocs2=NULL;
          ColumnSchema col;
          ObString col_name = crt_idx_stmt->get_storing_columns(i);
          //ObString storing_col=crt_idx_stmt->get_storing_columns(i);
          memset(str_cname,0,common::OB_MAX_COLUMN_NAME_LENGTH);
          memcpy(str_cname,col_name.ptr(),col_name.length());
          ocs2 = sql_context_->schema_manager_->get_column_schema(str_tname,str_cname);
          if(NULL == ocs2)
          {
            ret = OB_ERR_INVALID_SCHEMA;
            YYSYS_LOG(ERROR,"get source table column schema error,t_name=%s,col_name=%s,i=[%ld]",
                      str_tname,str_cname,i);
          }
          else
          {
            col.column_id_ = ocs2->get_id();
            //add wenghaixing [secondary index] 20141111
            if(col.column_id_>max_col_id)
            {
              max_col_id=col.column_id_;
            }
            //add e
            buf_len = sizeof(col.column_name_);
            if (col_name.length() < buf_len)
            {
              len = col_name.length();
            }
            else
            {
              len = buf_len - 1;
              TRANS_LOG("Column name is truncated to '%s'", str_cname);
            }
            memcpy(col.column_name_, col_name.ptr(), len);
            col.column_name_[len] = '\0';
            col.data_type_ = ocs2->get_type();
            //col.data_length_ = ocs2->get_default_value().get_val_len();
            col.data_length_ = ocs2->get_size();
            if (col.data_type_ == ObVarcharType && 0 > col.data_length_)
            {
              col.data_length_ = OB_MAX_VARCHAR_LENGTH;
            }
            col.length_in_rowkey_ = ocs2->get_default_value().get_val_len();
            col.data_precision_ = ocs2->get_precision();
            col.data_scale_ = ocs2->get_scale();
            col.nullable_ = ocs2->is_nullable();
            col.rowkey_id_ = 0;
            col.column_group_id_ = ocs2->get_column_group_id();
            col.join_table_id_ = OB_INVALID_ID;
            col.join_column_id_ = OB_INVALID_ID;
            this_index_col_num ++;
            // @todo default_value_;
            if (OB_SUCCESS != (ret = table_schema.add_column(col)))
            {
              TRANS_LOG("Add column definition of '%s' failed", table_schema.table_name_);
            }
            if (OB_SUCCESS == ret)
            {
              /*
                if (OB_SUCCESS != (ret = allocate_column_id(table_schema)))
                {
                  YYSYS_LOG(WARN, "fail to allocate column id:ret[%d]", ret);
                }
                */
              //column_num++;
            }
          }
        }
      }
      //add wenghaixing [secondary index create fix]20141225
      if(OB_SUCCESS == ret&&!crt_idx_stmt->get_has_storing())
      {
        ColumnSchema col;
        col.rowkey_id_ = 0;
        //modify wenghaixing[secondary index alter_table_debug]20150611
        //col.column_id_ = idxed_tab_schema->get_max_column_id()+1;
        col.column_id_ = OB_INDEX_VIRTUAL_COLUMN_ID;
        //modify e
        col.data_type_ = ObIntType;
        memcpy(col.column_name_,OB_INDEX_VIRTUAL_COL_NAME,strlen(OB_INDEX_VIRTUAL_COL_NAME));
        col.column_name_[strlen(OB_INDEX_VIRTUAL_COL_NAME)]='\0';
        col.column_group_id_ = OB_DEFAULT_COLUMN_GROUP_ID;
        //max_col_id = col.column_id_;
        if (OB_SUCCESS != (ret = table_schema.add_column(col)))
        {
          TRANS_LOG("Add column definition of '%s' failed", table_schema.table_name_);
        }
      }
      //add e
      //add wenghaixing 20141029
      if(OB_SUCCESS == ret)
      {
        TableSchema& table_schema = crt_tab_op->get_table_schema();
        //table_schema.is_index=true;
        table_schema.add_index_helper(ih);
        //add wenghaixing [secondary index]20141111
        table_schema.max_used_column_id_ = max_col_id;
        //add e
        if(table_schema.rowkey_column_num_ > OB_MAX_ROWKEY_COLUMN_NUMBER)
        {
          TRANS_LOG("index's rowkey column num cannot be greater than 16");
          ret = OB_ERR_COLUMN_SIZE;
        }
        if(OB_SUCCESS == ret)
        {
          if(OB_SUCCESS != (ret = sql_context_->schema_manager_->get_index_column_num(tid,column_num)))
          {
            ret = OB_ERROR;
          }
          else if(column_num + this_index_col_num > OB_MAX_INDEX_COLUMNS)
          {
            TRANS_LOG("index's column num cannot be greater than 100");
            ret = OB_ERR_INVALID_COLUMN_NUM;
          }
        }
      }
      //add e
      if(OB_SUCCESS == ret&&0<expire_info.length())
      {
        TableSchema& table_schema = crt_tab_op->get_table_schema();
        // check expire condition
        void *ptr = ob_malloc(sizeof(ObSchemaManagerV2), ObModIds::OB_SCHEMA);
        if (NULL == ptr)
        {
          TRANS_LOG("no memory");
          ret = OB_ALLOCATE_MEMORY_FAILED;
        }
        else
        {
          ObSchemaManagerV2 *tmp_schema_mgr = new(ptr) ObSchemaManagerV2();
          table_schema.table_id_ = OB_NOT_EXIST_TABLE_TID;
          if (OB_SUCCESS != (ret = tmp_schema_mgr->add_new_table_schema(table_schema)))
          {
            TRANS_LOG("failed to add new table, err=%d", ret);
          }
          else if (OB_SUCCESS != (ret = tmp_schema_mgr->sort_table()))
          {
            TRANS_LOG("failed to sort table for schema manager, err=%d",ret);
          }
          else if (OB_SUCCESS != (ret = tmp_schema_mgr->sort_column()))
          {
            TRANS_LOG("failed to sort column for schema manager, err=%d", ret);
          }
          else if (!tmp_schema_mgr->check_table_expire_condition())
          {
            //ret = OB_ERR_INVALID_SCHEMA;
            ret = OB_INVALID_ARGUMENT;
            TRANS_LOG("invalid expire info `%.*s'", expire_info.length(),
                      expire_info.ptr());
          }
          tmp_schema_mgr->~ObSchemaManagerV2();
          ob_free(tmp_schema_mgr);
          tmp_schema_mgr = NULL;
          table_schema.table_id_ = OB_INVALID_ID;
        }
      }
    }
  }

  return ret;
}
//add e
//add wenghaixing [secondary index upd] 20141204
int ObTransformer::cons_whole_row_desc(uint64_t table_id, ObRowDesc &desc, ObRowDescExt &desc_ext)
{
  int ret = OB_SUCCESS;
  const ObTableSchema *table_schema = sql_context_->schema_manager_->get_table_schema(table_id);
  ObRowkeyInfo ori;
  uint64_t cid = OB_INVALID_ID;
  uint64_t max_col_id = OB_INVALID_ID;
  ObObj obj_type;
  if(NULL == table_schema)
  {
    YYSYS_LOG(ERROR,"Table_Schema pointer is NULL");
    ret = OB_SCHEMA_ERROR;
  }
  else
  {
    ori = table_schema->get_rowkey_info();
    desc.set_rowkey_cell_count(ori.get_size());
    for(int64_t i = 0;i<ori.get_size();i++)
    {
      const ObColumnSchemaV2* ocs = NULL;
      if(OB_SUCCESS != (ret = ori.get_column_id(i,cid)))
      {
        YYSYS_LOG(WARN,"get_column_id for rowkey failed!");
        ret = OB_SCHEMA_ERROR;
        break;
      }
      else
      {
        ocs = sql_context_->schema_manager_->get_column_schema(table_id,cid);
        if(NULL == ocs)
        {
          YYSYS_LOG(WARN,"NULL Pointer of column schmea");
          ret = OB_SCHEMA_ERROR;
          break;
        }
        if(OB_SUCCESS != (ret = desc.add_column_desc(table_id,cid)))
        {
          YYSYS_LOG(WARN,"failed to add column desc!");
          ret = OB_ERROR;
          break;
        }
        else
        {
          obj_type.set_type(ocs->get_type());
          obj_type.set_precision(ocs->get_precision());
          obj_type.set_scale(ocs->get_scale());
        }
        if(OB_SUCCESS == ret&&OB_SUCCESS != (ret = desc_ext.add_column_desc(ocs->get_table_id(),ocs->get_id(),obj_type)))
        {
          YYSYS_LOG(WARN,"failed to add column desc_ext!");
          ret = OB_ERROR;
          break;
        }
      }
    }
    max_col_id = table_schema->get_max_column_id();
    for (int64_t j = OB_APP_MIN_COLUMN_ID; j <= (int64_t)max_col_id;  j++)
    {
      bool column_hit_index = false;
      const ObColumnSchemaV2* ocs=sql_context_->schema_manager_->get_column_schema(table_id,j);
      if(NULL == ocs)
      {
        YYSYS_LOG(WARN,"get column schema error!");
        ret = OB_SCHEMA_ERROR;
      }
      else if(OB_SUCCESS != (ret = sql_context_->schema_manager_->column_hint_index(table_id,(uint64_t)j,column_hit_index)))
      {
        YYSYS_LOG(WARN, "failed to check if column hit index");
        ret = OB_ERROR;
      }
      else if(ori.is_rowkey_column(j) || !column_hit_index)
      {}
      else
      {
        if(OB_SUCCESS != (ret = desc.add_column_desc(table_id,j)))
        {
          YYSYS_LOG(WARN,"failed to add column desc!");
          ret = OB_ERROR;
        }
        else
        {
          obj_type.set_type(ocs->get_type());
          obj_type.set_precision(ocs->get_precision());
          obj_type.set_scale(ocs->get_scale());
        }
        if(OB_SUCCESS == ret&&OB_SUCCESS != (ret = desc_ext.add_column_desc(ocs->get_table_id(),ocs->get_id(),obj_type)))
        {
          YYSYS_LOG(WARN,"failed to add column desc_ext!");
          ret = OB_ERROR;
          break;
        }
      }
    }
  }
  return ret;
}

int ObTransformer::cons_whole_row_desc(ObUpdateStmt *upd_stmt, uint64_t table_id, ObRowDesc &desc, ObRowDescExt &desc_ext)
{
  int ret = OB_SUCCESS;
  const ObTableSchema *table_schema = sql_context_->schema_manager_->get_table_schema(table_id);
  ObRowkeyInfo ori;
  uint64_t cid = OB_INVALID_ID;
  uint64_t max_col_id = OB_INVALID_ID;
  ObObj obj_type;
  if(NULL == table_schema || NULL == upd_stmt)
  {
    YYSYS_LOG(ERROR,"Table_Schema pointer is NULL");
    ret = OB_SCHEMA_ERROR;
  }
  else
  {
    ori = table_schema->get_rowkey_info();
    desc.set_rowkey_cell_count(ori.get_size());
    for(int64_t i = 0;i<ori.get_size();i++)
    {
      const ObColumnSchemaV2* ocs = NULL;
      if(OB_SUCCESS != (ret = ori.get_column_id(i,cid)))
      {
        YYSYS_LOG(WARN,"get_column_id for rowkey failed!");
        ret = OB_SCHEMA_ERROR;
        break;
      }
      else
      {
        ocs = sql_context_->schema_manager_->get_column_schema(table_id,cid);
        if(NULL == ocs)
        {
          YYSYS_LOG(WARN,"NULL Pointer of column schmea");
          ret = OB_SCHEMA_ERROR;
          break;
        }
        if(OB_SUCCESS != (ret = desc.add_column_desc(table_id,cid)))
        {
          YYSYS_LOG(WARN,"failed to add column desc!");
          ret = OB_ERROR;
          break;
        }
        else
        {
          obj_type.set_type(ocs->get_type());
          obj_type.set_precision(ocs->get_precision());
          obj_type.set_scale(ocs->get_scale());
        }
        if(OB_SUCCESS == ret&&OB_SUCCESS != (ret = desc_ext.add_column_desc(ocs->get_table_id(),ocs->get_id(),obj_type)))
        {
          YYSYS_LOG(WARN,"failed to add column desc_ext!");
          ret = OB_ERROR;
          break;
        }
      }
    }
    max_col_id = table_schema->get_max_column_id();
    for (int64_t j = OB_APP_MIN_COLUMN_ID; j <= (int64_t)max_col_id;  j++)
    {
      bool column_hit_index = false;
      const ObColumnSchemaV2* ocs=sql_context_->schema_manager_->get_column_schema(table_id,j);
      if(NULL == ocs)
      {
        YYSYS_LOG(WARN,"get column schema error!");
        ret = OB_SCHEMA_ERROR;
      }
      else if(OB_SUCCESS != (ret = sql_context_->schema_manager_->column_hint_index(table_id,(uint64_t)j,column_hit_index)))
      {
        YYSYS_LOG(WARN, "failed to check if column hit index");
        ret = OB_ERROR;
      }
      else if(ori.is_rowkey_column(j) || !column_hit_index)
      {
        uint64_t cid_set = OB_INVALID_ID;
        for(int64_t index = 0; index < upd_stmt->get_update_column_count(); index ++)
        {
          if (OB_SUCCESS != (ret = upd_stmt->get_update_column_id(index, cid_set)))
          {
            YYSYS_LOG(WARN, "fail to get update column id for table %lu column_idx=%lu", table_id, index);
            break;
          }
          else if((int64_t)cid_set == j)
          {
            ret = desc.add_column_desc(table_id, j);
            obj_type.set_type(ocs->get_type());
            obj_type.set_precision(ocs->get_precision());
            obj_type.set_scale(ocs->get_scale());
            if(OB_SUCCESS == ret)
            {
              desc_ext.add_column_desc(ocs->get_table_id(),ocs->get_id(),obj_type);
            }
          }
        }
      }
      else
      {
        if(OB_SUCCESS != (ret = desc.add_column_desc(table_id, j)))
        {
          YYSYS_LOG(WARN,"failed to add column desc!");
          ret = OB_ERROR;
        }
        else
        {
          obj_type.set_type(ocs->get_type());
          obj_type.set_precision(ocs->get_precision());
          obj_type.set_scale(ocs->get_scale());
        }
        if(OB_SUCCESS == ret&&OB_SUCCESS != (ret = desc_ext.add_column_desc(ocs->get_table_id(),ocs->get_id(),obj_type)))
        {
          YYSYS_LOG(WARN,"failed to add column desc_ext!");
          ret = OB_ERROR;
          break;
        }
      }
    }
  }
  return ret;
}

int ObTransformer::cons_del_upd_row_desc(ObStmt *stmt, uint64_t table_id, ObRowDesc &desc, ObRowDescExt &desc_ext)
{
  int ret = OB_SUCCESS;
  const ObTableSchema *table_schema = sql_context_->schema_manager_->get_table_schema(table_id);
  ObRowkeyInfo ori;
  uint64_t cid = OB_INVALID_ID;
  uint64_t max_col_id = OB_INVALID_ID;
  ObObj obj_type;
  if(NULL == table_schema || NULL == stmt)
  {
    YYSYS_LOG(ERROR,"Table_Schema pointer is NULL");
    ret = OB_SCHEMA_ERROR;
  }
  else
  {
    ori = table_schema->get_rowkey_info();
    desc.set_rowkey_cell_count(ori.get_size());
    for(int64_t i = 0;i<ori.get_size();i++)
    {
      const ObColumnSchemaV2* ocs = NULL;
      if(OB_SUCCESS != (ret = ori.get_column_id(i,cid)))
      {
        YYSYS_LOG(WARN,"get_column_id for rowkey failed!");
        ret = OB_SCHEMA_ERROR;
        break;
      }
      else
      {
        ocs = sql_context_->schema_manager_->get_column_schema(table_id,cid);
        if(NULL == ocs)
        {
          YYSYS_LOG(WARN,"NULL Pointer of column schmea");
          ret = OB_SCHEMA_ERROR;
          break;
        }
        if(OB_SUCCESS != (ret = desc.add_column_desc(table_id,cid)))
        {
          YYSYS_LOG(WARN,"failed to add column desc!");
          ret = OB_ERROR;
          break;
        }
        else
        {
          obj_type.set_type(ocs->get_type());
          obj_type.set_precision(ocs->get_precision());
          obj_type.set_scale(ocs->get_scale());
        }
        if(OB_SUCCESS == ret&&OB_SUCCESS != (ret = desc_ext.add_column_desc(ocs->get_table_id(),ocs->get_id(),obj_type)))
        {
          YYSYS_LOG(WARN,"failed to add column desc_ext!");
          ret = OB_ERROR;
          break;
        }
      }
    }
    max_col_id = table_schema->get_max_column_id();
  }
  if(OB_SUCCESS == ret)
  {
    bool hit_index = false;
    const ColumnItem* item = NULL;
    for(uint64_t i = 0; i <= max_col_id; i++)
    {
      const ObColumnSchemaV2* ocs = NULL;
      if(NULL == (ocs = sql_context_->schema_manager_->get_column_schema(table_id,i)))
      {
        continue;
      }
      if(OB_SUCCESS != (ret = sql_context_->schema_manager_->column_hint_index(table_id, i,hit_index)))
      {
        YYSYS_LOG(WARN,"failed to check hit index,tid[%ld],cid[%ld], ret[%d]!", table_id, i, ret);
        break;
      }
      else
      {
        item = stmt->get_column_item_by_id(table_id, i);
      }
      if((hit_index && OB_INVALID_INDEX == desc.get_idx(table_id, i)) || (NULL != item && OB_INVALID_INDEX == desc.get_idx(table_id, i)))
      {
        if ( i == OB_MODIFY_TIME_COLUMN_ID || i == OB_CREATE_TIME_COLUMN_ID)
        {
          continue;
        }
        if(OB_SUCCESS != (ret = desc.add_column_desc(table_id,i)))
        {
          YYSYS_LOG(WARN,"failed to add column desc!");
          ret = OB_ERROR;
          break;
        }
        else
        {
          obj_type.set_type(ocs->get_type());
          obj_type.set_precision(ocs->get_precision());
          obj_type.set_scale(ocs->get_scale());
        }
        if(OB_SUCCESS == ret&&OB_SUCCESS != (ret = desc_ext.add_column_desc(ocs->get_table_id(),ocs->get_id(),obj_type)))
        {
          YYSYS_LOG(WARN,"failed to add column desc_ext!");
          ret = OB_ERROR;
          break;
        }
      }
    }
  }
  return ret;
}
int ObTransformer::column_in_update_stmt(ObUpdateStmt *upd_stmt, uint64_t table_id, uint64_t cid, bool &in_stmt)
{
  int ret = OB_SUCCESS;
  if(NULL == upd_stmt)
  {
    ret = OB_INVALID_ARGUMENT;
  }
  else if(table_id != upd_stmt->get_update_table_id())
  {
    ret = OB_INVALID_ARGUMENT;
    YYSYS_LOG(WARN, "upd stmt's tid [%ld] is not equal table_id [%ld]",upd_stmt->get_update_table_id(), table_id );
  }
  else if(!in_stmt)
  {
    uint64_t stmt_cid = OB_INVALID_ID;
    for(int64_t i = 0; i < upd_stmt->get_update_column_count();i++)
    {
      if(OB_SUCCESS != (ret = upd_stmt->get_update_column_id(i, stmt_cid)))
      {
        ret = OB_ERROR;
      }
      else if(cid == stmt_cid)
      {
        in_stmt = true;
        break;
      }
    }
  }
  return ret;
}
//add e
int ObTransformer::gen_physical_create_table(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObCreateTableStmt *crt_tab_stmt = NULL;
  ObCreateTable     *crt_tab_op = NULL;

  /* get statement */
  if (ret == OB_SUCCESS)
  {
    get_stmt(logical_plan, err_stat, query_id, crt_tab_stmt);
  }

  if (OB_SUCCESS == ret)
  {
    const ObString& table_name = crt_tab_stmt->get_table_name();
    //modify by wenghaixing [secondary index drop table_with_index]20150126
    //if (TableSchema::is_system_table(table_name) //old code
    if (TableSchema::is_system_table_v2(table_name)
        //modify e
        && sql_context_->session_info_->is_create_sys_table_disabled())
    {
      ret = OB_ERR_NO_PRIVILEGE;
      YYSYS_LOG(USER_ERROR, "invalid table name to create, table_name=%.*s",
                table_name.length(), table_name.ptr());
    }
  }
  //add dolphin [database manager]@20150617:b
  if(OB_SUCCESS == ret)
  {

    ret = check_dbname_for_table(err_stat,crt_tab_stmt->get_db_name());
  }
  //add:e
  /* generate operator */
  if (ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(crt_tab_op, ObCreateTable, physical_plan, err_stat);
    if (ret == OB_SUCCESS)
    {
      crt_tab_op->set_sql_context(*sql_context_);
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, crt_tab_stmt, crt_tab_op, index);
    }
  }

  if (OB_SUCCESS == ret)
  {
    if (crt_tab_stmt->get_column_size() > OB_MAX_USER_DEFINED_COLUMNS_COUNT)
    {
      TRANS_LOG("Too many columns (max allowed is %ld).",
                OB_MAX_USER_DEFINED_COLUMNS_COUNT);
      ret = OB_ERR_INVALID_COLUMN_NUM;
    }
  }

  //add zhaoqiong [roottable tablet management]20150318:b
  if (OB_SUCCESS == ret)
  {
    if ((crt_tab_stmt->get_replica_num() > OB_MAX_COPY_COUNT || crt_tab_stmt->get_replica_num() < 0)
        //add lbzhong [Paxos Cluster.Balance] 20160707:b
        && OB_DEFAULT_COPY_COUNT != crt_tab_stmt->get_replica_num()
        )
    {
      TRANS_LOG("Illegal replica num (max allowed is %d).",
                OB_MAX_COPY_COUNT);
      ret = OB_ERR_ILLEGAL_VALUE;
    }
  }
  //add e
  if (ret == OB_SUCCESS)
  {
    int buf_len = 0;
    int len = 0;
    //add liu jun.[MultiUPS] [sql_api] 20150424:b
    int32_t param_list_len = 0;
    int32_t param_len = 0;
    ObTablePartitionType part_type = crt_tab_stmt->get_partition_type();
    int64_t param_list_count = 0;
    ObPartitionForm part_form = crt_tab_stmt->get_partition_form();//add wuna [MultiUPS][sql_api] 20151208

    //schema is not available yet
    TableSchema& table_schema = crt_tab_op->get_table_schema();
    const ObString& table_name = crt_tab_stmt->get_table_name();
    buf_len = sizeof(table_schema.table_name_);//OB_MAX_TABLE_NAME_LENGTH
    if (table_name.length() < buf_len)//strlen() not including the terminating '\0' character
    {
      len = table_name.length();
    }
    else
    {
      len = buf_len - 1;
      TRANS_LOG("Table name is truncated to '%.*s'", len, table_name.ptr());
    }
    memcpy(table_schema.table_name_, table_name.ptr(), len);
    table_schema.table_name_[len] = '\0';
    //add dolphin [database manager]@20150614:b
    buf_len = sizeof(table_schema.dbname_);
    const ObString& dbname = crt_tab_stmt->get_db_name();
    if (dbname.length() < buf_len)
    {
      len = dbname.length();
    }
    else
    {
      len = buf_len - 1;
      TRANS_LOG("DataBase name is truncated to '%.*s'", len, dbname.ptr());
    }
    memcpy(table_schema.dbname_, dbname.ptr(), len);
    table_schema.dbname_[len] = '\0';
    //add:e
    //add liu jun.[MultiUPS] [sql_api] 20150422:b
    if(OB_SUCCESS == ret)
    {
      //1:set prefix group name.
      const ObString& group_name_prefix = crt_tab_stmt->get_group_name_prefix();
      buf_len = sizeof(table_schema.group_name_prefix_);
      if(group_name_prefix.length() < buf_len)
      {
        len = group_name_prefix.length();
      }
      else
      {
        len = buf_len - 1;
        TRANS_LOG("group name is truncated to '%.*s'", len, group_name_prefix.ptr());
      }
      memcpy(table_schema.group_name_prefix_, group_name_prefix.ptr(), len);
      table_schema.group_name_prefix_[len] = '\0';
    }
    if(OB_DIRECT_PARTITION == part_type)
    {
      //2:set partition function name.
      const ObString& hash_func_name = crt_tab_stmt->get_func_name();
      buf_len = sizeof(table_schema.partition_func_name_);
      if(hash_func_name.length()<buf_len)
      {
        len = hash_func_name.length();
      }
      else
      {
        len = buf_len - 1;
        TRANS_LOG("Hash function name is truncated to '%.*s'", len, hash_func_name.ptr());
      }
      memcpy(table_schema.partition_func_name_, hash_func_name.ptr(), len);
      table_schema.partition_func_name_[len] = '\0';
      table_schema.partition_key_col_num_ = crt_tab_stmt->get_col_list_size();
      const ObArray<ObString>& param_list = crt_tab_stmt->get_col_list();
      param_list_count = crt_tab_stmt->get_col_list_size();
      for(int64_t i = 0;i < param_list_count - 1;i++)
      {
        const ObString& param = param_list.at(i);
        param_len = param.length();
        if(param_list_len + param_len + 1 < OB_MAX_VARCHAR_LENGTH)
        {
          memcpy(table_schema.param_list_+ param_list_len, param.ptr(), param_len);
          table_schema.param_list_[param_list_len + param_len] = ',';
          param_list_len = param_list_len + param_len + 1;
        }
        else
        {
          ret = OB_ERR_PARAMETER_LIST;
          TRANS_LOG("Partition parameter list is too long");
          break;
        }
      }
      if(OB_SUCCESS == ret)
      {
        param_len = param_list.at(param_list_count-1).length();
        if(param_list_len + param_len + 1 < OB_MAX_VARCHAR_LENGTH)
        {
          memcpy(table_schema.param_list_ + param_list_len, param_list.at(param_list_count-1).ptr(), param_len);
          table_schema.param_list_[param_list_len + param_len] = '\0';
        }
        else
        {
          ret = OB_ERR_PARAMETER_LIST;
          TRANS_LOG("Partition parameter list is too long");
        }

      }
    }
    /*add wuna [MultiUps][sql_api] 20151207:b*/
    if(OB_SUCCESS == ret)
    {
      if(part_form == OB_RANGE_PARTITION ||part_form== OB_RANGE_COLUMNS_PARTITION
         ||part_form == OB_LIST_PARTITION ||part_form== OB_LIST_COLUMNS_PARTITION)
      {
        uint64_t sub_query_id=crt_tab_stmt->get_part_func_query_id();
        ObCreatePartFuncStmt *create_part_func_stmt = NULL;

        if(OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, sub_query_id, create_part_func_stmt)))
        {
          TRANS_LOG("failed to get statement");
        }
        else if(OB_SUCCESS != (ret = create_part_func_stmt->check_expression()))
        {
          TRANS_LOG("List funtion definition is not correct.");
        }
        else
        {
          table_schema.partition_func_type_ = static_cast<int64_t>(create_part_func_stmt->get_partition_type());
          const ObString& func_context = create_part_func_stmt->get_func_context();
          if(OB_MAX_VARCHAR_LENGTH <= func_context.length())
          {
            ret = OB_ERR_PARAMETER_LIST;
            TRANS_LOG("Partition func body is too long");
          }
          else
          {
            memcpy(table_schema.partition_func_rule_body_,func_context.ptr(),func_context.length());
            table_schema.partition_func_rule_body_[func_context.length()]='\0';
          }
        }
      }
    }
    if(OB_SUCCESS == ret)
    {
      table_schema.partition_form_ = static_cast<int64_t>(part_form);
      /*add 20151207:e*/
      table_schema.table_partition_type_ = static_cast<int32_t>(part_type);
      //add 20150422:e

      const ObString& expire_info = crt_tab_stmt->get_expire_info();
      buf_len = sizeof(table_schema.expire_condition_);
      if (expire_info.length() < buf_len)
      {
        len = expire_info.length();
      }
      else
      {
        len = buf_len - 1;
        TRANS_LOG("Expire_info is truncated to '%.*s'", len, expire_info.ptr());
      }
      memcpy(table_schema.expire_condition_, expire_info.ptr(), len);
      table_schema.expire_condition_[len] = '\0';
      const ObString& comment_str = crt_tab_stmt->get_comment_str();
      buf_len = sizeof(table_schema.comment_str_);
      if (comment_str.length() < buf_len)
      {
        len = comment_str.length();
      }
      else
      {
        len = buf_len - 1;
        TRANS_LOG("Comment_str is truncated to '%.*s'", len, comment_str.ptr());
      }
      memcpy(table_schema.comment_str_, comment_str.ptr(), len);
      table_schema.comment_str_[len] = '\0';
      crt_tab_op->set_if_not_exists(crt_tab_stmt->get_if_not_exists());
      if (crt_tab_stmt->get_tablet_max_size() > 0)
        table_schema.tablet_max_size_ = crt_tab_stmt->get_tablet_max_size();
      if (crt_tab_stmt->get_tablet_block_size() > 0)
        table_schema.tablet_block_size_ = crt_tab_stmt->get_tablet_block_size();
      if (crt_tab_stmt->get_table_id() != OB_INVALID_ID)
        table_schema.table_id_ = crt_tab_stmt->get_table_id();
      table_schema.replica_num_ = crt_tab_stmt->get_replica_num();
      if(crt_tab_stmt->use_block_cache())
        table_schema.load_type_ = TableSchema::MEMORY;
      table_schema.is_use_bloomfilter_ = crt_tab_stmt->use_bloom_filter();
      table_schema.consistency_level_ = crt_tab_stmt->get_consistency_level();
      table_schema.rowkey_column_num_ = static_cast<int32_t>(crt_tab_stmt->get_primary_key_size());
      const ObString& compress_method = crt_tab_stmt->get_compress_method();
      buf_len = sizeof(table_schema.compress_func_name_);
      const char *func_name = compress_method.ptr();
      len = compress_method.length();
      if (len <= 0)
      {
        func_name = OB_DEFAULT_COMPRESS_FUNC_NAME;
        len = static_cast<int>(strlen(OB_DEFAULT_COMPRESS_FUNC_NAME));
      }
      if (len >= buf_len)
      {
        len = buf_len - 1;
        TRANS_LOG("Compress method name is truncated to '%.*s'", len, func_name);
      }
      memcpy(table_schema.compress_func_name_, func_name, len);
      table_schema.compress_func_name_[len] = '\0';
    }

    for (int64_t i = 0; ret == OB_SUCCESS && i < crt_tab_stmt->get_column_size(); i++)
    {
      const ObColumnDef& col_def = crt_tab_stmt->get_column_def(i);
      ColumnSchema col;
      col.column_id_ = col_def.column_id_;
      if (static_cast<int64_t>(col.column_id_) > table_schema.max_used_column_id_)
      {
        table_schema.max_used_column_id_ = col.column_id_;
      }
      buf_len = sizeof(col.column_name_);
      if (col_def.column_name_.length() < buf_len)
      {
        len = col_def.column_name_.length();
      }
      else
      {
        len = buf_len - 1;
        TRANS_LOG("Column name is truncated to '%.*s'", len, col_def.column_name_.ptr());
      }
      memcpy(col.column_name_, col_def.column_name_.ptr(), len);
      col.column_name_[len] = '\0';
      col.data_type_ = col_def.data_type_;
      col.data_length_ = col_def.type_length_;
      if (col.data_type_ == ObVarcharType && 0 > col_def.type_length_)
      {
        col.data_length_ = OB_MAX_VARCHAR_LENGTH;
      }
      col.length_in_rowkey_ = col_def.type_length_;
      col.data_precision_ = col_def.precision_;
      col.data_scale_ = col_def.scale_;
      col.nullable_ = !col_def.not_null_;
      col.rowkey_id_ = col_def.primary_key_id_;
      col.column_group_id_ = 0;
      col.join_table_id_ = OB_INVALID_ID;
      col.join_column_id_ = OB_INVALID_ID;

      if (!(col_def.default_value_.is_valid_type()))
      {
        TRANS_LOG("default column type '%d' is not valid", col_def.default_value_.get_type());
        break;
      }
      else if (col_def.default_value_.get_type() == common::ObVarcharType)
      {
        buf_len = sizeof(col.default_value_);
        ObString def_value;
        ret = col_def.default_value_.get_varchar(def_value);
        if (ret != OB_SUCCESS)
        {
          TRANS_LOG("fail to get default value");
          break;
        }
        if (def_value.length() < buf_len)
        {
          len = def_value.length();
        }
        else
        {
          len = buf_len - 1;
          TRANS_LOG("Column name is truncated to '%.*s'",len, def_value.ptr());
        }
        memcpy(col.default_value_, def_value.ptr(), len);
        col.default_value_[len] = '\0';
        col.default_value_is_null = false;
      }

      // @todo default_value_;
      if ((ret = table_schema.add_column(col)) != OB_SUCCESS)
      {
        TRANS_LOG("Add column definition of '%s' failed", table_schema.table_name_);
        break;
      }

      if (OB_SUCCESS == ret)
      {
        if (OB_SUCCESS != (ret = allocate_column_id(table_schema)))
        {
          YYSYS_LOG(WARN, "fail to allocate column id:ret[%d]", ret);
        }
      }
    }
  }

  if (OB_SUCCESS == ret && 0 < crt_tab_stmt->get_join_info().length())
  {
    const ObString &join_info_str = crt_tab_stmt->get_join_info();
    YYSYS_LOG(DEBUG, "create table join info[%.*s]", join_info_str.length(), join_info_str.ptr());
    if ( !parse_join_info(join_info_str, crt_tab_op->get_table_schema()) )
    {
      ret = OB_ERR_PARSE_JOIN_INFO;
      TRANS_LOG("Wrong join info, please check join info");
    }
  }

  if (OB_SUCCESS == ret && 0 < crt_tab_stmt->get_expire_info().length())
  {
    TableSchema& table_schema = crt_tab_op->get_table_schema();
    // check expire condition
    void *ptr = ob_malloc(sizeof(ObSchemaManagerV2), ObModIds::OB_SCHEMA);
    if (NULL == ptr)
    {
      TRANS_LOG("no memory");
      ret = OB_ALLOCATE_MEMORY_FAILED;
    }
    else
    {
      ObSchemaManagerV2 *tmp_schema_mgr = new(ptr) ObSchemaManagerV2();
      table_schema.table_id_ = OB_NOT_EXIST_TABLE_TID;
      if (table_schema.replica_num_ == 0)
      {
        table_schema.replica_num_ = OB_DEFAULT_COPY_COUNT;
      }
      if (OB_SUCCESS != (ret = tmp_schema_mgr->add_new_table_schema(table_schema)))
      {
        TRANS_LOG("failed to add new table, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = tmp_schema_mgr->sort_table()))
      {
        TRANS_LOG("failed to sort table for schema manager, err=%d",ret);
      }
      else if (OB_SUCCESS != (ret = tmp_schema_mgr->sort_column()))
      {
        TRANS_LOG("failed to sort column for schema manager, err=%d", ret);
      }
      else if (!tmp_schema_mgr->check_table_expire_condition())
      {
        //ret = OB_ERR_INVALID_SCHEMA;
        ret = OB_INVALID_ARGUMENT;
        TRANS_LOG("invalid expire info `%.*s'", crt_tab_stmt->get_expire_info().length(),
                  crt_tab_stmt->get_expire_info().ptr());
      }
      tmp_schema_mgr->~ObSchemaManagerV2();
      ob_free(tmp_schema_mgr);
      tmp_schema_mgr = NULL;
      table_schema.table_id_ = OB_INVALID_ID;
      table_schema.replica_num_ = crt_tab_stmt->get_replica_num();
    }
  }
  //add liu jun.[MultiUPS] [sql_api] 20150424:b
  if(OB_SUCCESS == ret)
  {
    const ObArray<ObString>& col_list = crt_tab_stmt->get_col_list();
    int64_t params_num = col_list.count();
    const TableSchema& table_schema = crt_tab_op->get_table_schema();
    for(int64_t i = 0;i < params_num;i++)
    {
      const ObString& param_name = col_list.at(i);
      if(!table_schema.is_rowkey_column(param_name))
      {
        ret = OB_ERR_NOT_ROWKEY;
        TRANS_LOG("parameter[%.*s] is not rowkey",param_name.length(),param_name.ptr());
        break;
      }
    }
  }
  //20150424:e
  return ret;
}

//add liu jun.[MultiUPS] [sql_api] 20150326:b
int ObTransformer::gen_physical_part_func_stmt(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObBasicStmt *stmt = NULL;
  ObPartFuncExecutor  *part_func_op = NULL;

  if(OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, stmt)))
  {
    TRANS_LOG("failed to get statement");
  }
  //create operator.
  else if (NULL == CREATE_PHY_OPERRATOR(part_func_op, ObPartFuncExecutor, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator");
  }
  else if (OB_SUCCESS != (ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, stmt, part_func_op, index)))
  {
    TRANS_LOG("Add create user operator failed");
  }
  else
  {
    ObBasicStmt * basic_stmt = NULL;
    // ����ڴ��Ǵ�transform mem pool�з��������
    if (stmt->get_stmt_type() == ObBasicStmt::T_CREATE_PART_FUNC)
    {
      void *ptr = trans_malloc(sizeof(ObCreatePartFuncStmt));
      if (ptr == NULL)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR, "malloc ObCreatePartStmt in transform mem pool failed, ret=%d", ret);
      }
      else
      {
        basic_stmt = new (ptr) ObCreatePartFuncStmt(*(dynamic_cast<ObCreatePartFuncStmt*>(stmt)));
      }
    }
    else if(stmt->get_stmt_type() == ObBasicStmt::T_DROP_PART_FUNC)
    {
      void *ptr = trans_malloc(sizeof(ObDropPartFuncStmt));
      if (ptr == NULL)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR, "malloc ObDropPartStmt in transform mem pool failed, ret=%d", ret);
      }
      else
      {
        basic_stmt = new (ptr) ObDropPartFuncStmt(*(dynamic_cast<ObDropPartFuncStmt*>(stmt)));
      }
    }
    else
    {
      //couldn't be here.
      ret = OB_ERROR;
      YYSYS_LOG(ERROR,"unkown partition function stmt");
    }
    part_func_op->set_context(sql_context_);
    part_func_op->set_stmt(basic_stmt);
  }
  return ret;
}
//add 20150326:e

/// TODO: not allocate column group id
int ObTransformer::allocate_column_id(TableSchema & table_schema)
{
  int ret = OB_SUCCESS;
  bool has_got_create_time_type = false;
  bool has_got_modify_time_type = false;
  ColumnSchema * column = NULL;
  uint64_t column_id = OB_APP_MIN_COLUMN_ID;

  table_schema.max_used_column_id_ = column_id;
  for (int64_t i = 0; i < table_schema.get_column_count(); ++i)
  {
    column = table_schema.get_column_schema(i);
    if (NULL == column)
    {
      ret = OB_INPUT_PARAM_ERROR;
      YYSYS_LOG(WARN, "check column schema failed:table_name[%s], index[%ld]",
                table_schema.table_name_, i);
      break;
    }
    else if (ObCreateTimeType == column->data_type_) // create time
    {
      column->column_id_ = OB_CREATE_TIME_COLUMN_ID;
      if (has_got_create_time_type)
      {
        // duplication case checked by parser, double check
        ret = OB_INPUT_PARAM_ERROR;
        YYSYS_LOG(WARN, "find duplicated create time column:table_name[%s], index[%ld]",
                  table_schema.table_name_, i);
        break;
      }
      else
      {
        has_got_create_time_type = true;
      }
    }
    else if (ObModifyTimeType == column->data_type_) // last_modify time
    {
      column->column_id_ = OB_MODIFY_TIME_COLUMN_ID;
      if (has_got_modify_time_type)
      {
        // duplication case checked by parser, double check
        ret = OB_INPUT_PARAM_ERROR;
        YYSYS_LOG(WARN, "find duplicated modify time column:table_name[%s], index[%ld]",
                  table_schema.table_name_, i);
        break;
      }
      else
      {
        has_got_modify_time_type = true;
      }
    }
    else
    {
      table_schema.max_used_column_id_ = column_id;
      column->column_id_ = column_id++;
    }
  }
  return ret;
}

int ObTransformer::gen_physical_alter_table(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObAlterTableStmt *alt_tab_stmt = NULL;
  ObAlterTable     *alt_tab_op = NULL;

  /* get statement */
  if (ret == OB_SUCCESS)
  {
    get_stmt(logical_plan, err_stat, query_id, alt_tab_stmt);
  }

  if (OB_SUCCESS == ret)
  {
    const ObString& table_name = alt_tab_stmt->get_table_name();
    if (TableSchema::is_system_table(table_name)
        && sql_context_->session_info_->is_create_sys_table_disabled())
    {
      ret = OB_ERR_NO_PRIVILEGE;
      YYSYS_LOG(USER_ERROR, "invalid table name to alter, table_name=%.*s",
                table_name.length(), table_name.ptr());
    }
  }

  /* generate operator */
  if (ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(alt_tab_op, ObAlterTable, physical_plan, err_stat);
    if (ret == OB_SUCCESS)
    {
      alt_tab_op->set_sql_context(*sql_context_);
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, alt_tab_stmt, alt_tab_op, index);
    }
  }

  if (ret == OB_SUCCESS)
  {
    AlterTableSchema& alter_schema = alt_tab_op->get_alter_table_schema();
    alter_schema.clear();//Add By LiuJun.
    const ObString& table_name = alt_tab_stmt->get_table_name();
    memcpy(alter_schema.table_name_, table_name.ptr(), table_name.length());
    alter_schema.table_name_[table_name.length()] = '\0';
    alter_schema.table_id_ = alt_tab_stmt->get_table_id();

    //add dolphin [database manager]@20150618:b
    memcpy(alter_schema.dbname_,alt_tab_stmt->get_db_name().ptr(),alt_tab_stmt->get_db_name().length());
    alter_schema.dbname_[alt_tab_stmt->get_db_name().length()] = 0;
    //add:e
    //add liuj [Alter_Rename] [JHOBv0.1] 20150104
    if(alt_tab_stmt->has_table_rename())
    {
      alter_schema.has_table_rename_ = true;
      const ObString& new_table_name = alt_tab_stmt->get_new_table_name();
      memcpy(alter_schema.new_table_name_,new_table_name.ptr(),new_table_name.length());
      alter_schema.new_table_name_[new_table_name.length()] = '\0';

      if (TableSchema::is_system_table(new_table_name)
          && sql_context_->session_info_->is_create_sys_table_disabled())
      {
        ret = OB_ERR_NO_PRIVILEGE;
        YYSYS_LOG(USER_ERROR, "invalid retable name to alter, table_name=%.*s",
                  new_table_name.length(), new_table_name.ptr());
      }
    }
    //add e
    const ObTableSchema *old_schema = sql_context_->schema_manager_->get_table_schema(alt_tab_stmt->get_table_id());
    if (old_schema == NULL)
    {
      ret = OB_SCHEMA_ERROR;
      YYSYS_LOG(WARN, "Can not get table schema, table_id=%lu, ret=%d", alt_tab_stmt->get_table_id(), ret);
    }
    else
    {
      const char *old_expire_info = old_schema->get_expire_condition();
      int32_t len = static_cast<int32_t>(strlen(old_schema->get_expire_condition()));
      if(NULL == old_expire_info)
      {
        ret = OB_ERR_UNEXPECTED;
        YYSYS_LOG(WARN, "can not get expire_info");
      }
      else
      {
        if (alt_tab_stmt->is_add_expire_info() || alt_tab_stmt->is_expire_info_modify())
        {
          alter_schema.is_alter_expire_info_ = true;
          const ObString &new_expire_info = alt_tab_stmt->get_new_expire_info();
          ObString tmp_expire_cond;
          tmp_expire_cond.assign_ptr(const_cast<char *>(old_expire_info), static_cast<int32_t>(strlen(old_expire_info)) + 1);
          if (alt_tab_stmt->is_add_expire_info() && 0 != len)
          {
            ret = OB_EXPIRE_CONDITION_ERROR;
            TRANS_LOG("Can not add expire info,because there already has one,table_name=%.*s,ret=%d",
                      table_name.length(), table_name.ptr(), ret);
          }
          else if(alt_tab_stmt->is_add_expire_info() && 0 == len)
          {
            ret = sql_context_->schema_manager_->check_new_expire_condition_for_alter(*sql_context_->schema_manager_, *old_schema, new_expire_info, tmp_expire_cond, true);
            if (OB_SUCCESS != ret)
            {
              YYSYS_LOG(WARN, "Expire condition is wrong!wrong column name or type,table=%.*s,ret=%d",
                        table_name.length(), table_name.ptr(), ret);
              TRANS_LOG("Can't add expire_info,wrong column_type or index table isn't satisfied,ret=%d",ret);
            }
            else
            {
              memcpy(alter_schema.new_expire_info_, new_expire_info.ptr(), new_expire_info.length());
              alter_schema.new_expire_info_[new_expire_info.length()] = '\0';
            }
          }
          else if (alt_tab_stmt->is_expire_info_modify() && 0 == len)
          {
            ret = OB_EXPIRE_CONDITION_ERROR;
            TRANS_LOG("Can not alter expire info,because there doesn't have one,ret=%d",ret);
          }
          else if (alt_tab_stmt->is_expire_info_modify() && 0 != len)
          {
            ret = sql_context_->schema_manager_->check_new_expire_condition_for_alter(*sql_context_->schema_manager_, *old_schema, new_expire_info, tmp_expire_cond);
            if (OB_SUCCESS != ret)
            {
              TRANS_LOG("Can't alter expire info,wrong column_name or type,ret=%d",ret);
              YYSYS_LOG(WARN, "Expire condition is wrong!wrong column name or type,table_name=%.*s, ret=%d",
                        table_name.length(), table_name.ptr(), ret);
            }
            else
            {
              memcpy(alter_schema.new_expire_info_, new_expire_info.ptr(), new_expire_info.length());
              alter_schema.new_expire_info_[new_expire_info.length()] = '\0';
            }
          }
        }
        else if (alt_tab_stmt->is_drop_expire_info())
        {
          if (0 == len)
          {
            ret = OB_EXPIRE_CONDITION_ERROR;
            TRANS_LOG("Expire info is NULL,and you can't drop it, ret=%d", ret);
          }
          else
          {
            alter_schema.is_drop_expire_info_ = true;
            memset(alter_schema.new_expire_info_, '\0', OB_MAX_EXPIRE_CONDITION_LENGTH);
          }
        }
      }
    }




    //add wuna [MultiUps] [sql_api] 20160109:b
    if(alt_tab_stmt->is_rule_modify())
    {
      int buf_len = 0;
      int len = 0;
      int32_t param_list_len = 0;
      int32_t param_len = 0;
      ObTablePartitionType part_type = alt_tab_stmt->get_partition_type();
      alter_schema.is_rule_modify_ = true;
      //1:set prefix group name.
      const ObString& group_name_prefix = alt_tab_stmt->get_group_name_prefix();
      buf_len = sizeof(alter_schema.group_name_prefix_);
      if(group_name_prefix.length() < buf_len)
      {
        len = group_name_prefix.length();
      }
      else
      {
        len = buf_len - 1;
        TRANS_LOG("group name is truncated to '%.*s'", len, group_name_prefix.ptr());
      }
      memcpy(alter_schema.group_name_prefix_, group_name_prefix.ptr(), len);
      alter_schema.group_name_prefix_[len] = '\0';
      if(OB_DIRECT_PARTITION == part_type)
      {
        //2:set partition function name.
        const ObString& hash_func_name = alt_tab_stmt->get_func_name();
        buf_len = sizeof(alter_schema.partition_func_name_);
        if(hash_func_name.length()<buf_len)
        {
          len = hash_func_name.length();
        }
        else
        {
          len = buf_len - 1;
          TRANS_LOG("Hash function name is truncated to '%.*s'", len, hash_func_name.ptr());
        }
        memcpy(alter_schema.partition_func_name_, hash_func_name.ptr(), len);
        alter_schema.partition_func_name_[len] = '\0';
        //3:set partiton column list
        alter_schema.partition_key_col_num_ = static_cast<int32_t>(alt_tab_stmt->get_col_list_size());
        const ObArray<ObString>& param_list = alt_tab_stmt->get_col_list();
        int64_t param_list_count = alt_tab_stmt->get_col_list_size();
        for(int64_t i = 0;OB_SUCCESS == ret && i < param_list_count;i++)
        {
          const ObString& param = param_list.at(i);
          param_len = param.length();
          if(param_list_len + param_len + 1 < OB_MAX_VARCHAR_LENGTH)
          {
            memcpy(alter_schema.param_list_+ param_list_len, param.ptr(), param_len);
            if(i!=param_list_count - 1)
            {
              alter_schema.param_list_[param_list_len + param_len] = ',';
            }
            else
            {
              alter_schema.param_list_[param_list_len + param_len] = '\0';
            }
            param_list_len = param_list_len + param_len + 1;
          }
          else
          {
            ret = OB_ERR_PARAMETER_LIST;
            TRANS_LOG("Partition parameter list is too long");
            break;
          }
        }//for end
      }
      if(ret == OB_SUCCESS)
      {
        alter_schema.partition_type_ = static_cast<int32_t>(part_type);
      }
    }
    if (alt_tab_stmt->is_load_type_modify())
    {
      alter_schema.is_load_type_modify_ = true;
      if(alt_tab_stmt->get_is_block_cache_use())
      {
        alter_schema.is_use_block_cache_ = true;
      }
      else
      {
        alter_schema.is_use_block_cache_ = false;
      }
    }
    //add 20160109:e
    hash::ObHashMap<common::ObString, ObColumnDef>::iterator iter;
    for (iter = alt_tab_stmt->column_begin();
         ret == OB_SUCCESS && iter != alt_tab_stmt->column_end();
         iter++)
    {
      AlterTableSchema::AlterColumnSchema alt_col;
      ObColumnDef& col_def = iter->second;
      alt_col.column_.column_id_ = col_def.column_id_;
      memcpy(alt_col.column_.column_name_, col_def.column_name_.ptr(), col_def.column_name_.length());
      alt_col.column_.column_name_[col_def.column_name_.length()] = '\0';
      const char *expire_info = old_schema->get_expire_condition();
      if (NULL != expire_info && '\0' != expire_info[0] && 0 != strcmp(expire_info, "1=0"))
      {
        bool if_exist = sql_context_->schema_manager_->check_alter_column_in_expire_columns(*old_schema, expire_info, alt_col.column_.column_name_);
        if (if_exist)
        {
          ret = OB_EXPIRE_CONDITION_ERROR;
          TRANS_LOG("can not alter expire column, ret=%d",ret);
          break;
        }
      }
      switch (col_def.action_)
      {
        case ADD_ACTION:
          alt_col.type_ = AlterTableSchema::ADD_COLUMN;
          alt_col.column_.data_type_ = col_def.data_type_;
          alt_col.column_.data_length_ = col_def.type_length_;
          alt_col.column_.data_precision_ = col_def.precision_;
          alt_col.column_.data_scale_ = col_def.scale_;
          alt_col.column_.nullable_ = !col_def.not_null_;
          alt_col.column_.rowkey_id_ = col_def.primary_key_id_;
          alt_col.column_.column_group_id_ = 0;
          alt_col.column_.join_table_id_ = OB_INVALID_ID;
          alt_col.column_.join_column_id_ = OB_INVALID_ID;

          if (col_def.default_value_.get_type() == common::ObVarcharType)
          {
            int buf_len = sizeof(alt_col.column_.default_value_);
            ObString def_value;
            ret = col_def.default_value_.get_varchar(def_value);
            if (ret != OB_SUCCESS)
            {
              TRANS_LOG("fail to get default value");
              break;
            }
            int len = 0;
            if (def_value.length() < buf_len)
            {
              len = def_value.length();
            }
            else
            {
              len = buf_len - 1;
              TRANS_LOG("Column name is truncated to '%.*s'",len, def_value.ptr());
            }
            memcpy(alt_col.column_.default_value_, def_value.ptr(), len);
            alt_col.column_.default_value_[len] = '\0';
            alt_col.column_.default_value_is_null = false;
          }
          break;
        case DROP_ACTION:
        {


          alt_col.type_ = AlterTableSchema::DEL_COLUMN;
          //add wenghaixing [secondary index alter table]20141227
          bool alt_col_hit_index = false;
          if(OB_SUCCESS != (ret = sql_context_->schema_manager_->column_hint_index(alter_schema.table_id_,alt_col.column_.column_id_,alt_col_hit_index)))
          {
            YYSYS_LOG(WARN,"failed to get alt_col_hit_index[%d] ",ret);
            //ret=OB_SCHEMA_ERROR;
          }
          else if(alt_col_hit_index)
          {
            TRANS_LOG("column [%ld] cannot be deleted,there is a index use it!",alt_col.column_.column_id_);
            ret = OB_ERROR;
          }
        }
          //add e
          break;
          //mod fyd [NotNULL_check] [JHOBv0.1] 20140108:b
          //case ALTER_ACTION:{
          //alt_col.type_ = AlterTableSchema::MOD_COLUMN;
        case ALTER_ACTION_NULL:
        {
          alt_col.type_ = AlterTableSchema::MOD_COLUMN_NULL;
          //mod 20140108:e
          alt_col.column_.nullable_ = !col_def.not_null_;
          /* default value doesn't exist in ColumnSchema */
          /* FIX ME, get other attributs from schema */
          const ObColumnSchemaV2 *col_schema = NULL;
          if ((col_schema = sql_context_->schema_manager_->get_column_schema(
                 alter_schema.table_id_,
                 col_def.column_id_)) == NULL)
          {
            ret = OB_ERR_TABLE_UNKNOWN;
            TRANS_LOG("Can not find schema of table '%s'", alter_schema.table_name_);
            break;
          }
          else
          {
            alt_col.column_.data_type_ = col_schema->get_type();
            // alt_col.column_.data_length_ = iter->type_length_;
            // alt_col.column_.data_precision_ = iter->precision_;
            // alt_col.column_.data_scale_ = iter->scale_;
            // alt_col.column_.rowkey_id_ = iter->primary_key_id_;
            alt_col.column_.column_group_id_ = col_schema->get_column_group_id();
            //mod fyd [NotNULL_check] [JHOBv0.1] 20140108:b
            //alt_col.column_.join_table_id_ = col_schema->get_join_info()->join_table_;
            //alt_col.column_.join_column_id_ = col_schema->get_join_info()->correlated_column_;
            if(col_schema->get_join_info())
            {
              alt_col.column_.join_table_id_ = col_schema->get_join_info()->join_table_;
              alt_col.column_.join_column_id_ = col_schema->get_join_info()->correlated_column_;
            }
            //mod 20140108:e
          }
          break;
        }
        case ALTER_ACTION_DEFAULT:
        {
          alt_col.type_ = AlterTableSchema::MOD_COLUMN_DEFAULT;
          if (!col_def.default_value_.is_valid_type())
          {
            ret = OB_ERROR;
            TRANS_LOG("type of default value is invalid");
            break;
          }
          else if (col_def.default_value_.get_type() == ObVarcharType)
          {
            int buf_len = sizeof(alt_col.column_.default_value_);
            ObString def_value;
            ret = col_def.default_value_.get_varchar(def_value);
            if (ret != OB_SUCCESS)
            {
              TRANS_LOG("fail to get default value");
              break;
            }
            int len = 0;
            if (def_value.length() < buf_len)
            {
              len = def_value.length();
            }
            else
            {
              len = buf_len - 1;
              TRANS_LOG("Column name is truncated to '%.*s'",len, def_value.ptr());
            }
            memcpy(alt_col.column_.default_value_, def_value.ptr(), len);
            alt_col.column_.default_value_[len] = '\0';
            alt_col.column_.default_value_is_null = false;
          }
          else if (col_def.default_value_.get_type() == ObNullType)
          {
            alt_col.column_.default_value_[0] = '\0';
            alt_col.column_.default_value_is_null = true;
          }

          const ObColumnSchemaV2 *col_schema = NULL;
          if ((col_schema = sql_context_->schema_manager_->get_column_schema(
                 alter_schema.table_id_,
                 col_def.column_id_)) == NULL)
          {
            ret = OB_ERR_TABLE_UNKNOWN;
            TRANS_LOG("Can not find schema of table '%s'", alter_schema.table_name_);
            break;
          }
          else
          {
            alt_col.column_.data_type_ = col_schema->get_type();
            alt_col.column_.column_group_id_ = col_schema->get_column_group_id();
            if (col_schema->get_join_info())
            {
              alt_col.column_.join_table_id_ = col_schema->get_join_info()->join_table_;
              alt_col.column_.join_column_id_ = col_schema->get_join_info()->correlated_column_;
            }
          }
          break;
        }
          //add liuj [Alter_Rename] [JHOBv0.1] 20150104
        case RENAME_ACTION:
          alt_col.type_ = AlterTableSchema::RENAME_COLUMN;
          memcpy(alt_col.column_.new_column_name_,col_def.new_column_name_.ptr(),col_def.new_column_name_.length());
          alt_col.column_.new_column_name_[col_def.new_column_name_.length()] = '\0';
          break;
          //add e
        case ALTER_VARCHAR_LENGTH:
        {
          alt_col.type_ = AlterTableSchema::MOD_VARCHAR_LENGTH;
          alt_col.column_.data_length_ = col_def.type_length_;
          break;
        }
        case ALTER_DECIMAL_PRECISION:
        {
          alt_col.type_ = AlterTableSchema::MOD_DECIMAL_PRECISION;
          alt_col.column_.data_precision_ = col_def.precision_;
          alt_col.column_.data_scale_ = col_def.scale_;
          break;
        }
        default:
          ret = OB_ERR_GEN_PLAN;
          TRANS_LOG("Alter action '%d' is not supported", col_def.action_);
          break;
      }
      //mod fyd [NotNULL_check] [JHOBv0.1] 20140108:b
      if (ret == OB_SUCCESS && (ret = alter_schema.add_column(alt_col.type_, alt_col.column_)) != OB_SUCCESS)
        //if (ret == OB_SUCCESS && (ret = alter_schema.add_column(alt_col.type_, alt_col.column_,alt_col.new_column_name_)) != OB_SUCCESS)
        //mod 20140108:e
      {
        TRANS_LOG("Add alter column '%s' failed", alt_col.column_.column_name_);
        break;
      }
    }
  }
  //add wenghaixing [secondary index alter table]20150126
  const ObTableSchema* schema =NULL;
  if(NULL == (schema = (sql_context_->schema_manager_->get_table_schema(alt_tab_stmt->get_table_id()))))
  {
    YYSYS_LOG(WARN,"failed to get table[%ld] schema",alt_tab_stmt->get_table_id());
    ret = OB_SCHEMA_ERROR;
  }
  //else if(OB_INVALID_ID != schema->get_index_helper().tbl_tid)
  else if(OB_INVALID_ID != schema->get_index_helper().tbl_tid && !alt_tab_stmt->is_load_type_modify())
  {
    TRANS_LOG("can not alter an index table[%ld]",alt_tab_stmt->get_table_id());
    ret = OB_ERROR;
  }
  //add e
  return ret;
}

//add wenghaixing [secondary index drop index]20141223
int ObTransformer::gen_physical_drop_index(ObLogicalPlan *logical_plan, ObPhysicalPlan *physical_plan, ErrStat &err_stat, const uint64_t &query_id, int32_t *index)
{
  int &ret = err_stat.err_code_=OB_SUCCESS;
  ObDropIndexStmt *drp_idx_stmt=NULL;
  ObDropIndex *drp_idx_op =NULL;
  /* get statement */
  if (OB_SUCCESS == ret)
  {
    get_stmt(logical_plan, err_stat, query_id, drp_idx_stmt);
  }
  /* generate operator */
  if(OB_SUCCESS == ret)
  {
    CREATE_PHY_OPERRATOR(drp_idx_op, ObDropIndex, physical_plan, err_stat);
    if (OB_SUCCESS == ret)
    {
      drp_idx_op->set_sql_context(*sql_context_);
      drp_idx_op->set_rpc_stub(sql_context_->rs_rpc_proxy_);
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, drp_idx_stmt, drp_idx_op, index);
    }
  }
  for (int64_t i = 0; OB_SUCCESS == ret && i < drp_idx_stmt->get_table_size(); i++)
  {
    const ObString& table_name = drp_idx_stmt->get_table_name(i);
    // add by zhangcd [multi_database.secondary_index] 20150703:b
    // add:e
    if (OB_SUCCESS != (ret = drp_idx_op->add_index_name(table_name)))
    {
      TRANS_LOG("Add drop index %.*s failed", table_name.length(), table_name.ptr());
      break;
    }
  }
  return ret;
}
//add e
int ObTransformer::gen_physical_drop_table(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObDropTableStmt *drp_tab_stmt = NULL;
  ObDropTable     *drp_tab_op = NULL;

  /* get statement */
  if (ret == OB_SUCCESS)
  {
    get_stmt(logical_plan, err_stat, query_id, drp_tab_stmt);
  }
  bool disallow_drop_sys_table = sql_context_->session_info_->is_create_sys_table_disabled();
  //add dolphin [database manager]@20150617:b
  if(OB_SUCCESS == ret)
  {

    int64_t len = drp_tab_stmt->get_table_size();
    ObString table_name;
    char dn[OB_MAX_DATBASE_NAME_LENGTH];
    char tn[OB_MAX_TABLE_NAME_LENGTH];
    ObString dname;
    ObString tname;
    dname.assign_buffer(dn,OB_MAX_DATBASE_NAME_LENGTH);
    tname.assign_buffer(tn,OB_MAX_TABLE_NAME_LENGTH);
    for (int64_t i = 0;i<len;++i)
    {
      table_name = drp_tab_stmt->get_table_name(i);
      if (!table_name.split_two(dname,tname))
      {
        TRANS_LOG("table name[%.*s] is invalid", table_name.length(), table_name.ptr());
        break;
      }
      else if(OB_SUCCESS != (ret = check_dbname_for_table(err_stat,dname)))
      {
        TRANS_LOG("drop table failed because the database name %.*s not exist", dname.length(), dname.ptr());
        break;
      }
    }

  }
  //add:e
  /* generate operator */
  if (ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(drp_tab_op, ObDropTable, physical_plan, err_stat);
    if (ret == OB_SUCCESS)
    {
      drp_tab_op->set_rpc_stub(sql_context_->rs_rpc_proxy_);
      drp_tab_op->set_sql_context(*sql_context_);//add liumz, [drop table -> clean table priv]20150902
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, drp_tab_stmt, drp_tab_op, index);
    }
  }

  if (ret == OB_SUCCESS)
  {
    drp_tab_op->set_if_exists(drp_tab_stmt->get_if_exists());
    for (int64_t i = 0; ret == OB_SUCCESS && i < drp_tab_stmt->get_table_size(); i++)
    {
      const ObString& table_name = drp_tab_stmt->get_table_name(i);
      uint64_t tid = drp_tab_stmt->get_table_id(i);//add liumz, [drop table -> clean table priv]20150902
      if (TableSchema::is_system_table(table_name)
          && disallow_drop_sys_table)
      {
        ret = OB_ERR_NO_PRIVILEGE;
        YYSYS_LOG(USER_ERROR, "system table can not be dropped, table_name=%.*s",
                  table_name.length(), table_name.ptr());
        break;
      }
      if ((ret = drp_tab_op->add_table_name(table_name)) != OB_SUCCESS)
      {
        TRANS_LOG("Add drop table %.*s failed", table_name.length(), table_name.ptr());
        break;
      }
      //add liumz, [drop table -> clean table priv]20150902:b
      else if ((ret = drp_tab_op->add_table_id(tid)) != OB_SUCCESS)
      {
        TRANS_LOG("Add drop table %.*s failed", table_name.length(), table_name.ptr());
        break;
      }
      //add:e
    }
  }

  return ret;
}

//add zhaoqiong [Truncate Table]:20160318:b
int ObTransformer::gen_physical_truncate_table(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObTruncateTableStmt *trun_tab_stmt = NULL;
  ObTruncateTable     *trun_tab_op = NULL;

  /* get statement */
  if (ret == OB_SUCCESS)
  {
    get_stmt(logical_plan, err_stat, query_id, trun_tab_stmt);
  }
  bool disallow_trun_sys_table = sql_context_->session_info_->is_create_sys_table_disabled();
  //add dolphin [database manager]@20150617:b
  if(OB_SUCCESS == ret)
  {

    int64_t len = trun_tab_stmt->get_table_size();
    ObString table_name;
    char dn[OB_MAX_DATBASE_NAME_LENGTH];
    char tn[OB_MAX_TABLE_NAME_LENGTH];
    ObString dname;
    ObString tname;
    dname.assign_buffer(dn,OB_MAX_DATBASE_NAME_LENGTH);
    tname.assign_buffer(tn,OB_MAX_TABLE_NAME_LENGTH);
    for (int64_t i = 0;i<len;++i)
    {
      table_name = trun_tab_stmt->get_table_name(i);
      if (!table_name.split_two(dname,tname))
      {
        TRANS_LOG("table name[%.*s] is invalid", table_name.length(), table_name.ptr());
        break;
      }
      else if(OB_SUCCESS != (ret = check_dbname_for_table(err_stat,dname)))
      {
        TRANS_LOG("truncate table failed because the database name %.*s not exist", dname.length(), dname.ptr());
        break;
      }
    }

  }
  //add:e
  /* generate operator */
  if (ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(trun_tab_op, ObTruncateTable, physical_plan, err_stat);
    if (ret == OB_SUCCESS)
    {
      trun_tab_op->set_rpc_stub(sql_context_->rs_rpc_proxy_);
      trun_tab_op->set_sql_context(*sql_context_);
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, trun_tab_stmt, trun_tab_op, index);
    }
  }

  if (ret == OB_SUCCESS)
  {
    trun_tab_op->set_if_exists(trun_tab_stmt->get_if_exists());
    for (int64_t i = 0; ret == OB_SUCCESS && i < trun_tab_stmt->get_table_size(); i++)
    {
      const ObString& table_name = trun_tab_stmt->get_table_name(i);
      if (TableSchema::is_system_table(table_name)
          && disallow_trun_sys_table)
      {
        ret = OB_ERR_NO_PRIVILEGE;
        YYSYS_LOG(USER_ERROR, "system table can not be truncated, table_name=%.*s",
                  table_name.length(), table_name.ptr());
        break;
      }
      if ((ret = trun_tab_op->add_table_name(table_name)) != OB_SUCCESS)
      {
        TRANS_LOG("Add trun table %.*s failed", table_name.length(), table_name.ptr());
        break;
      }
    }
  }

  if (ret == OB_SUCCESS && trun_tab_stmt->get_comment().length() != 0)
  {
    trun_tab_op->set_comment(trun_tab_stmt->get_comment());
    YYSYS_LOG(DEBUG, "add stmt comment, comment=%.*s",
              trun_tab_stmt->get_comment().length(), trun_tab_stmt->get_comment().ptr());
  }
  return ret;
}
//add:e

int ObTransformer::gen_physical_alter_group(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat &err_stat,
    const uint64_t &query_id,
    int32_t *index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObAlterGroupStmt *alt_group_stmt = NULL;
  ObAlterGroup *alt_group_op = NULL;

  if ((get_stmt(logical_plan, err_stat, query_id, alt_group_stmt)) != OB_SUCCESS)
  {
  }
  if (ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(alt_group_op, ObAlterGroup, physical_plan, err_stat);
    if (ret == OB_SUCCESS)
    {
      alt_group_op->set_sql_context(*sql_context_);
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, alt_group_stmt, alt_group_op, index);
    }
  }
  if (ret == OB_SUCCESS)
  {
    const common::ObStrings *group = alt_group_stmt->get_group();
    ObString group_name;
    YYSYS_LOG(INFO,"group->count()=%ld",group->count());
    if (group->count() != 1)
    {
      YYSYS_LOG(ERROR, "group name is should only one");
    }
    else if (OB_SUCCESS != (ret = group->get_string(0, group_name)))
    {
      YYSYS_LOG(WARN, "get group name failed,ret=%d",ret);
    }
    else
    {
      alt_group_op->set_group_name(group_name);
      alt_group_op->set_paxos_idx(alt_group_stmt->get_paxos_idx());
    }
  }
  return ret;
}

// add by zhangcd [multi_database.bugfix] 20150805:e
int ObTransformer::get_all_databases(ErrStat& err_stat, ObStrings &databases)
{
  int ret = OB_SUCCESS;
  char select_databases_buff[512];
  int cnt = snprintf(select_databases_buff, 512, "select db_name from __all_database");
  ObString select_databases;
  select_databases.assign_ptr(select_databases_buff, cnt);
  ObResultSet tmp_result;
  if (OB_SUCCESS != (ret = tmp_result.init()))
  {
    YYSYS_LOG(WARN, "init result set failed, ret=%d", ret);
  }
  else if (OB_SUCCESS != (ret = ObSql::direct_execute(select_databases, tmp_result, *sql_context_)))
  {
    TRANS_LOG(tmp_result.get_message());
    YYSYS_LOG(WARN, "direct_execute failed, sql=%.*s ret=%d", select_databases.length(), select_databases.ptr(), ret);
  }
  else if (OB_SUCCESS != (ret = tmp_result.open()))
  {
    YYSYS_LOG(WARN, "open result set failed, sql=%.*s ret=%d", select_databases.length(), select_databases.ptr(), ret);
  }
  else
  {
    OB_ASSERT(tmp_result.is_with_rows() == true);
    const ObRow* row = NULL;
    while (ret == OB_SUCCESS)
    {
      ret = tmp_result.get_next_row(row);
      if (OB_ITER_END == ret)
      {
        ret = OB_SUCCESS;
        break;
      }
      else if (OB_SUCCESS != ret)
      {
        YYSYS_LOG(WARN, "get next row from ObResultSet failed,ret=%d", ret);
      }
      else
      {
        const ObObj *pcell = NULL;
        uint64_t table_id = OB_INVALID_ID;
        uint64_t column_id = OB_INVALID_ID;
        ret = row->raw_get_cell(0, pcell, table_id, column_id);

        if (OB_SUCCESS == ret)
        {
          if (pcell->get_type() == ObVarcharType)
          {
            ObString db_name;
            if (OB_SUCCESS != (ret = pcell->get_varchar(db_name)))
            {
              YYSYS_LOG(WARN, "failed to get varchar from ObObj, ret=%d", ret);
            }
            else
            {
              if (OB_SUCCESS != (ret = databases.add_string(db_name)))
              {
                YYSYS_LOG(WARN, "add db_name[%.*s] to array failed, ret=%d", db_name.length(), db_name.ptr(), ret);
              }
            }
          }
          else
          {
            ret = OB_ERR_UNEXPECTED;
            YYSYS_LOG(WARN, "got type of %d cell from row, expected type=%d", pcell->get_type(), ObVarcharType);
          }
        }
        else
        {
          YYSYS_LOG(WARN, "raw get cell(db_name) failed, ret=%d", ret);
        }
      }
    }// while
    //add liumz, [bugfix: close result set]20150914:b
    int err = tmp_result.close();
    if (OB_SUCCESS != err)
    {
      YYSYS_LOG(WARN, "failed to close result set,err=%d", err);
    }
    tmp_result.reset();

    //add:e
  }
  return ret;
}
// add:e

// add by zhangcd [multi_database.show_databases] 20150617:b
int ObTransformer::gen_phy_show_databases(
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObRowDesc row_desc;
  uint64_t table_id = OB_INVALID_ID;
  uint64_t column_id = OB_INVALID_ID;
  ObValues *values_op = NULL;
  CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat);
  if (OB_SUCCESS == ret)//add qianzm [null operator unjudgement bug1181] 20160520
  {
    if (show_stmt->get_column_size() != 1)
    {
      YYSYS_LOG(WARN, "wrong columns' number of %s, column size %d", OB_DATABASES_SHOW_TABLE_NAME, show_stmt->get_column_size());
      ret = OB_ERR_COLUMN_SIZE;
      TRANS_LOG("wrong columns' number of %s", OB_DATABASES_SHOW_TABLE_NAME);
    }
    else
    {
      const ColumnItem* column_item = show_stmt->get_column_item(0);
      table_id = column_item->table_id_;
      column_id = column_item->column_id_;
      if ((ret = row_desc.add_column_desc(table_id, column_id)) != OB_SUCCESS
          || (ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
      {
        TRANS_LOG("add row desc error, err=%d", ret);
      }
    }

    // mod by zhangcd [multi_database.bugfix] 20150805:e
    // oceanbase::common::ObPrivilege *p_privilege_ = const_cast<oceanbase::common::ObPrivilege *>(*sql_context_->pp_privilege_);
    // const ObPrivilege::NameDbMap* name_db_map = p_privilege_->get_database_name_map();

    ObStrings db_names;
    //add liumz, [bugfix: disable privilege check when show databases]20150914:b
    bool before_switch = sql_context_->disable_privilege_check_;
    sql_context_->disable_privilege_check_ = true;
    //add:e
    if(OB_SUCCESS != (ret = get_all_databases(err_stat, db_names)))
    {
      YYSYS_LOG(WARN, "failed to get databases name from __all_databses! ret=[%d]", ret);
    }
    sql_context_->disable_privilege_check_ = before_switch;//add liumz, [bugfix: disable privilege check when show databases]
    //  ObPrivilege::NameDbMap::const_iterator it = name_db_map->begin();
    for(int i = 0; ret == OB_SUCCESS && i < db_names.count(); ++i)
    {
      ObRow val_row;
      ObString db_name;
      ObObj value;
      if(OB_SUCCESS != (ret = db_names.get_string(i, db_name)))
      {
        YYSYS_LOG(WARN, "get string from db_names failed! ret=[%d]", ret);
        break;
      }
      value.set_varchar(db_name);
      val_row.set_row_desc(row_desc);
      if ((ret = val_row.set_cell(table_id, column_id, value)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value to ObRow failed");
        break;
      }
      else if (ret == OB_SUCCESS && (ret = values_op->add_values(val_row)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value row failed");
        break;
      }

    }
  }
  // mod:e
  if (ret == OB_SUCCESS)
  {
    out_op = values_op;
  }

  return ret;
}
// add by zhangcd [multi_database.show_databases] 20150617:e

// add by zhangcd [multi_database.show_databases] 20150617:b
int ObTransformer::gen_phy_show_current_database(
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObRowDesc row_desc;
  uint64_t table_id = OB_INVALID_ID;
  uint64_t column_id = OB_INVALID_ID;
  ObValues *values_op = NULL;
  CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat);
  if (OB_SUCCESS == ret)//add qianzm [null operator unjudgement bug1181] 20160520
  {
    if (show_stmt->get_column_size() != 1)
    {
      YYSYS_LOG(WARN, "wrong columns' number of %s, column size %d", OB_DATABASES_SHOW_TABLE_NAME, show_stmt->get_column_size());
      ret = OB_ERR_COLUMN_SIZE;
      TRANS_LOG("wrong columns' number of %s", OB_DATABASES_SHOW_TABLE_NAME);
    }
    else
    {
      const ColumnItem* column_item = show_stmt->get_column_item(0);
      table_id = column_item->table_id_;
      column_id = column_item->column_id_;
      if ((ret = row_desc.add_column_desc(table_id, column_id)) != OB_SUCCESS
          || (ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
      {
        TRANS_LOG("add row desc error, err=%d", ret);
      }
    }

    const common::ObString& db_name = sql_context_->session_info_->get_db_name();

    if(db_name.length() != 0)
    {
      ObRow val_row;
      ObObj value;
      value.set_varchar(db_name);
      val_row.set_row_desc(row_desc);
      if ((ret = val_row.set_cell(table_id, column_id, value)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value to ObRow failed");
      }
      else if (ret == OB_SUCCESS && (ret = values_op->add_values(val_row)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value row failed");
      }
    }
  }
  if (ret == OB_SUCCESS)
  {
    out_op = values_op;
  }

  return ret;
}
// add by zhangcd [multi_database.show_databases] 20150617:e

int ObTransformer::gen_phy_show_tables(
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObRowDesc row_desc;
  uint64_t table_id = OB_INVALID_ID;
  uint64_t column_id = OB_INVALID_ID;
  ObValues *values_op = NULL;
  CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat);
  if (OB_SUCCESS == ret)//add qianzm [null operator unjudgement bug1181] 20160520
  {
    if (show_stmt->get_column_size() != 1)
    {
      YYSYS_LOG(WARN, "wrong columns' number of %s", OB_TABLES_SHOW_TABLE_NAME);
      ret = OB_ERR_COLUMN_SIZE;
      TRANS_LOG("wrong columns' number of %s", OB_TABLES_SHOW_TABLE_NAME);
    }
    else
    {
      const ColumnItem* column_item = show_stmt->get_column_item(0);
      table_id = column_item->table_id_;
      column_id = column_item->column_id_;
      if ((ret = row_desc.add_column_desc(table_id, column_id)) != OB_SUCCESS
          || (ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
      {
        TRANS_LOG("add row desc error, err=%d", ret);
      }
    }

    // modify by zhangcd [multi_database.show_tables] 20150615:b
    // user tables show
    const common::ObString& db_name = sql_context_->session_info_->get_db_name();
    const ObTableSchema* it = sql_context_->schema_manager_->table_begin();
    for(; ret == OB_SUCCESS && it != sql_context_->schema_manager_->table_end(); it++)
    {
      ObString table_name_str;
      if(IS_SYS_TABLE_ID(it->get_table_id()))
      {
        /* skip system tables */
        continue;
      }
      else
      {
        ObString complete_table_name = ObString::make_string(it->get_table_name());
        char db_name_array[OB_MAX_DATBASE_NAME_LENGTH];
        void *table_name_ptr = NULL;
        ObString db_name_str(sizeof(db_name_array), 0, db_name_array);

        if (NULL == (table_name_ptr = mem_pool_->alloc(OB_MAX_TABLE_NAME_LENGTH)))
        {
          TRANS_LOG("mem-over flow, generate show table plan failed!");
          ret = OB_ALLOCATE_MEMORY_FAILED;
          break;
        }
        table_name_str.assign_buffer((char*)table_name_ptr, OB_MAX_TABLE_NAME_LENGTH);

        bool split_ret = complete_table_name.split_two(db_name_str, table_name_str, '.');
        // sys tables, not belong to any db
        if(!split_ret)
        {
          TRANS_LOG("table name[%.*s] is invalid!", complete_table_name.length(), complete_table_name.ptr());
          continue;
        }
        else if(db_name_str.length() == 0)
        {
          TRANS_LOG("table name[%.*s] is invalid!", complete_table_name.length(), complete_table_name.ptr());
          continue;
        }
        // user tables belong to current db
        else if(db_name_str == db_name)
        {

        }
        // user tables not belong to current db
        else
        {
          /* skip tables not belong to current db */
          continue;
        }
      }

      ObRow val_row;
      ObString val = table_name_str;
      ObObj value;
      value.set_varchar(val);
      val_row.set_row_desc(row_desc);

      /*if (it->get_table_id() >= OB_TABLES_SHOW_TID
                && it->get_table_id() <= OB_SERVER_STATUS_SHOW_TID)
                */
      if (IS_SHOW_TABLE(it->get_table_id()))
      {
        /* skip local show tables */
        continue;
      }
      /* add liumengzhan_show_tables [20141210]
     * filter index tables
     */
      else if (it->get_index_helper().tbl_tid != OB_INVALID_ID)
      {
        /* skip index tables */
        continue;
      }
      //add:e
      else if ((ret = val_row.set_cell(table_id, column_id, value)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value to ObRow failed");
        break;
      }
      else if (ret == OB_SUCCESS && (ret = values_op->add_values(val_row)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value row failed");
        break;
      }
    }

    //  const ObTableSchema* it = sql_context_->schema_manager_->table_begin();
    //  for(; ret == OB_SUCCESS && it != sql_context_->schema_manager_->table_end(); it++)
    //  {
    //    ObRow val_row;
    //    int32_t len = static_cast<int32_t>(strlen(it->get_table_name()));
    //    ObString val(len, len, it->get_table_name());
    //    ObObj value;
    //    value.set_varchar(val);
    //    val_row.set_row_desc(row_desc);
    //    if (it->get_table_id() >= OB_TABLES_SHOW_TID
    //      && it->get_table_id() <= OB_SERVER_STATUS_SHOW_TID)
    //    {
    //      /* skip local show tables */
    //      continue;
    //    }
    //    else if ((ret = val_row.set_cell(table_id, column_id, value)) != OB_SUCCESS)
    //    {
    //      TRANS_LOG("Add value to ObRow failed");
    //      break;
    //    }
    //    else if (ret == OB_SUCCESS && (ret = values_op->add_values(val_row)) != OB_SUCCESS)
    //    {
    //      TRANS_LOG("Add value row failed");
    //      break;
    //    }
    //  }

    // modify by zhangcd [multi_database.show_tables] 20150615:e
  }
  if (ret == OB_SUCCESS)
  {
    out_op = values_op;
  }

  return ret;
}

// add by zhangcd [multi_database.show_tables] 20150617:b
int ObTransformer::gen_phy_show_system_tables(
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObRowDesc row_desc;
  uint64_t table_id = OB_INVALID_ID;
  uint64_t column_id = OB_INVALID_ID;
  ObValues *values_op = NULL;
  CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat);
  if (OB_SUCCESS == ret)//add qianzm [null operator unjudgement bug1181] 20160520
  {
    if (show_stmt->get_column_size() != 1)
    {
      YYSYS_LOG(WARN, "wrong columns' number of %s", OB_TABLES_SHOW_TABLE_NAME);
      ret = OB_ERR_COLUMN_SIZE;
      TRANS_LOG("wrong columns' number of %s", OB_TABLES_SHOW_TABLE_NAME);
    }
    else
    {
      const ColumnItem* column_item = show_stmt->get_column_item(0);
      table_id = column_item->table_id_;
      column_id = column_item->column_id_;
      if ((ret = row_desc.add_column_desc(table_id, column_id)) != OB_SUCCESS
          || (ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
      {
        TRANS_LOG("add row desc error, err=%d", ret);
      }
    }

    // sys_tables show
    const ObTableSchema* it = sql_context_->schema_manager_->table_begin();
    for(; ret == OB_SUCCESS && it != sql_context_->schema_manager_->table_end(); it++)
    {
      ObRow val_row;
      int32_t len = static_cast<int32_t>(strlen(it->get_table_name()));
      ObString val(len, len, it->get_table_name());
      ObObj value;
      value.set_varchar(val);
      val_row.set_row_desc(row_desc);
      if(!IS_SYS_TABLE_ID(it->get_table_id()))
      {
        /* skip user tables */
        continue;
      }

      /*if (it->get_table_id() >= OB_TABLES_SHOW_TID
                    && it->get_table_id() <= OB_SERVER_STATUS_SHOW_TID)*/
      if (IS_SHOW_TABLE(it->get_table_id()))
      {
        /* skip local show tables */
        continue;
      }
      else if ((ret = val_row.set_cell(table_id, column_id, value)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value to ObRow failed");
        break;
      }
      else if (ret == OB_SUCCESS && (ret = values_op->add_values(val_row)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value row failed");
        break;
      }
    }
  }
  if (ret == OB_SUCCESS)
  {
    out_op = values_op;
  }

  return ret;
}
// add by zhangcd [multi_database.show_tables] 20150617:e
//add liumengzhan_show_index [20141208]
int ObTransformer::gen_phy_show_index(
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObRowDesc row_desc;
  ObValues *values_op = NULL;
  IndexList idx_list;
  uint64_t show_tid = OB_INVALID_ID;
  uint64_t sys_tid = OB_INVALID_ID;
  uint64_t idx_tid = OB_INVALID_ID;
  int64_t idx_num = 0;
  CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat);
  if (OB_SUCCESS == ret)//add qianzm [null operator unjudgement bug1181] 20160520
  {
    if (show_stmt->get_column_size() != 2)
    {
      ret = OB_ERR_COLUMN_SIZE;
      TRANS_LOG("wrong columns' number of %s", OB_INDEX_SHOW_TABLE_NAME);
    }
    else
    {
      for (int32_t i = 0; i< show_stmt->get_column_size(); i++)
      {
        const ColumnItem* column_item = show_stmt->get_column_item(i);
        if ((ret = row_desc.add_column_desc(column_item->table_id_, column_item->column_id_)) != OB_SUCCESS)
        {
          TRANS_LOG("add row desc error, err=%d", ret);
        }
      }
      if ((ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
      {
        TRANS_LOG("add row desc error, err=%d", ret);
      }
    }

    show_tid = show_stmt->get_show_table_id();
    sys_tid = show_stmt->get_sys_table_id();
    if (show_tid == OB_INVALID_ID || (ret=sql_context_->schema_manager_->get_index_list(show_tid, idx_list)) != OB_SUCCESS)
    {
      ret = OB_ERR_ILLEGAL_ID;
      TRANS_LOG("get index table list error, err=%d", ret);
    }
    idx_num = idx_list.get_count();
    for (int64_t i = 0; ret == OB_SUCCESS && i < idx_num; i++)
    {
      ObRow val_row;
      val_row.set_row_desc(row_desc);
      //construct index table name_obj
      idx_list.get_idx_id(i, idx_tid);
      const ObTableSchema *idx_tschema = sql_context_->schema_manager_->get_table_schema(idx_tid);
      //add by zhangcd [multi_database.secondary_index] 20150703:b
      ObString db_name;
      ObString short_table_name;
      char *db_name_ptr = NULL;
      char *short_table_name_ptr = NULL;
      if(NULL == (db_name_ptr = (char *)mem_pool_->alloc(OB_MAX_DATBASE_NAME_LENGTH)))
      {
        ret = OB_ERROR;
        TRANS_LOG("Memory OverFlow!");
      }
      else
      {
        db_name.assign_buffer(db_name_ptr, OB_MAX_DATBASE_NAME_LENGTH);
      }
      if(NULL == (short_table_name_ptr = (char *)mem_pool_->alloc(OB_MAX_DATBASE_NAME_LENGTH)))
      {
        ret = OB_ERROR;
        TRANS_LOG("Memory OverFlow!");
      }
      else
      {
        short_table_name.assign_buffer(short_table_name_ptr, OB_MAX_TABLE_NAME_LENGTH);
      }
      ObString complete_table_name = ObString::make_string(idx_tschema->get_table_name());
      bool split_ret = complete_table_name.split_two(db_name, short_table_name, '.');
      if(!split_ret)
      {
        ret = OB_ERROR;
        TRANS_LOG("Generate physical show index failed!");
        break;
      }
      //add:e

      //modify by zhangcd [multi_database.secondary_index] 20150703:b
      ObString name = short_table_name;
      //int32_t len = static_cast<int32_t>(strlen(idx_tschema->get_table_name()));
      //ObString name(len, len, idx_tschema->get_table_name());
      //modify:e
      ObObj name_obj;
      name_obj.set_varchar(name);
      //construct index table status_obj
      IndexHelper idx_hp = idx_tschema->get_index_helper();
      ObObj status_obj;
      status_obj.set_int(idx_hp.status);

      uint64_t column_id = OB_APP_MIN_COLUMN_ID;
      if ((ret = val_row.set_cell(sys_tid, column_id++, name_obj)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value to ObRow failed");
        break;
      }
      else if ((ret = val_row.set_cell(sys_tid, column_id++, status_obj)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value to ObRow failed");
        break;
      }
      else if (ret == OB_SUCCESS && (ret = values_op->add_values(val_row)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value row failed");
        break;
      }
    }
  }
  if (ret == OB_SUCCESS)
  {
    out_op = values_op;
  }

  return ret;
}
//add:e

int ObTransformer::gen_phy_show_all_index(
    ObPhysicalPlan *physical_plan,
    ErrStat &err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObRowDesc row_desc;
  ObValues *values_op = NULL;
  CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat);
  if (OB_SUCCESS == ret)
  {
    if (show_stmt->get_column_size() != 5)
    {
      ret = OB_ERR_COLUMN_SIZE;
      TRANS_LOG("wrong columns' number of %s",OB_ALL_INDEX_SHOW_TABLE_NAME);
    }
    else
    {
      for (int32_t i=0; i< show_stmt->get_column_size(); i++)
      {
        const ColumnItem *column_item = show_stmt->get_column_item(i);
        if ((ret = row_desc.add_column_desc(column_item->table_id_, column_item->column_id_)) != OB_SUCCESS)
        {
          TRANS_LOG("add row desc error, err=%d",ret);
        }
      }
      if ((ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
      {
        TRANS_LOG("add row desc error, err=%d",ret);
      }
    }
    uint64_t sys_tid = show_stmt->get_sys_table_id();
    int64_t index_status = show_stmt->get_index_status();
    const ObTableSchema *it = sql_context_->schema_manager_->table_begin();
    for (; ret == OB_SUCCESS && it != sql_context_->schema_manager_->table_end(); it++)
    {
      IndexList idx_list;
      uint64_t data_tid = OB_INVALID_ID;
      data_tid = it->get_table_id();
      int64_t idx_num = 0;
      if (IS_SYS_TABLE_ID(data_tid))
      {
        continue;
      }
      if (data_tid == OB_INVALID_ID || (ret = sql_context_->schema_manager_->get_index_list(data_tid, idx_list)) != OB_SUCCESS)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("get index table list error, err=%d",ret);
      }
      ObString db_name;
      ObString data_table_name;
      if (ret==OB_SUCCESS)
      {
        idx_num = idx_list.get_count();
        if (idx_num == 0)
        {
          continue;
        }
        char *db_name_ptr = NULL;
        char *data_table_name_ptr = NULL;
        if (NULL == (db_name_ptr = (char *) mem_pool_->alloc(OB_MAX_DATBASE_NAME_LENGTH)))
        {
          ret = OB_ERROR;
          TRANS_LOG("Memory OverFlow!");
        }
        else
        {
          db_name.assign_buffer(db_name_ptr, OB_MAX_DATBASE_NAME_LENGTH);
        }
        if (NULL == (data_table_name_ptr = (char *) mem_pool_->alloc(OB_MAX_TABLE_NAME_LENGTH)))
        {
          ret = OB_ERROR;
          TRANS_LOG("Memory OverFlow!");
        }
        else
        {
          data_table_name.assign_buffer(data_table_name_ptr, OB_MAX_TABLE_NAME_LENGTH);
        }
        ObString complete_data_table_name = ObString::make_string(it->get_table_name());
        bool split_ret = complete_data_table_name.split_two(db_name, data_table_name, '.');
        if (!split_ret)
        {
          ret = OB_ERROR;
          TRANS_LOG("Generate physical show all index failed!");
          break;
        }
      }
      for (int64_t i = 0; ret == OB_SUCCESS && i < idx_num; i++)
      {
        ObRow val_row;
        val_row.set_row_desc(row_desc);
        uint64_t idx_tid = OB_INVALID_ID;
        idx_list.get_idx_id(i, idx_tid);
        const ObTableSchema *idx_tschema = sql_context_->schema_manager_->get_table_schema(idx_tid);
        IndexHelper idx_hp = idx_tschema->get_index_helper();
        if (index_status != 0 && idx_hp.status != index_status)
        {
          continue;
        }
        ObString index_table_name;
        char *index_table_name_ptr = NULL;
        if (NULL == (index_table_name_ptr = (char *) mem_pool_->alloc(OB_MAX_DATBASE_NAME_LENGTH)))
        {
          ret = OB_ERROR;
          TRANS_LOG("Memory OverFlow");
        }
        else
        {
          index_table_name.assign_buffer(index_table_name_ptr, OB_MAX_TABLE_NAME_LENGTH);
        }
        ObString complete_index_table_name = ObString::make_string(idx_tschema->get_table_name());
        bool split_ret = complete_index_table_name.split_two(db_name, index_table_name, '.');
        if (!split_ret)
        {
          ret = OB_ERROR;
          TRANS_LOG("Generate physical show all index failed!");
          break;
        }
        ObObj db_name_obj;
        ObObj data_table_name_obj;
        ObObj index_tid_obj;
        ObObj index_name_obj;
        ObObj status_obj;
        db_name_obj.set_varchar(db_name);
        data_table_name_obj.set_varchar(data_table_name);
        index_tid_obj.set_int(idx_tid);
        index_name_obj.set_varchar(index_table_name);
        status_obj.set_int(idx_hp.status);
        uint64_t column_id = OB_APP_MIN_COLUMN_ID;
        if ((ret = val_row.set_cell(sys_tid, column_id++, db_name_obj)) != OB_SUCCESS)
        {
          TRANS_LOG("Add value to ObRow failed");
          break;
        }
        if ((ret = val_row.set_cell(sys_tid, column_id++, data_table_name_obj)) != OB_SUCCESS)
        {
          TRANS_LOG("Add value to ObRow failed");
          break;
        }
        if ((ret = val_row.set_cell(sys_tid, column_id++, index_tid_obj)) != OB_SUCCESS)
        {
          TRANS_LOG("Add value to ObRow failed");
          break;
        }
        if ((ret = val_row.set_cell(sys_tid, column_id++, index_name_obj)) != OB_SUCCESS)
        {
          TRANS_LOG("Add value to ObRow failed");
          break;
        }
        else if ((ret = val_row.set_cell(sys_tid, column_id++, status_obj)) != OB_SUCCESS)
        {
          TRANS_LOG("Add value to ObRow failed");
          break;
        }
        else if (ret == OB_SUCCESS && (ret = values_op->add_values(val_row)) != OB_SUCCESS)
        {
          TRANS_LOG("Add value row failed");
          break;
        }
      }
    }
  }
  if (ret == OB_SUCCESS)
  {
    out_op = values_op;
  }
  return ret;
}

int ObTransformer::gen_phy_show_columns(
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObRowDesc row_desc;
  ObValues *values_op = NULL;
  CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat);

  int32_t num = show_stmt->get_column_size();
  if (OB_UNLIKELY(num < 1))
  {
    YYSYS_LOG(WARN, "wrong columns' number of %s", OB_COLUMNS_SHOW_TABLE_NAME);
    ret = OB_ERR_COLUMN_SIZE;
    TRANS_LOG("wrong columns' number of %s", OB_COLUMNS_SHOW_TABLE_NAME);
  }
  else
  {
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      const ColumnItem* column_item = show_stmt->get_column_item(i);
      if ((ret = row_desc.add_column_desc(column_item->table_id_, column_item->column_id_)) != OB_SUCCESS)
      {
        TRANS_LOG("add row desc error, err=%d", ret);
      }
    }
    if (ret == OB_SUCCESS && (ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
    {
      TRANS_LOG("set row desc error, err=%d", ret);
    }
  }

  if (ret == OB_SUCCESS && show_stmt->get_is_show_view())
  {
    int64_t column_size = show_stmt->get_column_count();
    for(int64_t i = 0; i < column_size; i++)
    {
      const ObColumnDef &column = show_stmt->get_column_def(i);
      uint64_t table_id = OB_INVALID_ID;
      uint64_t column_id = OB_INVALID_ID;
      ObRow val_row;
      val_row.set_row_desc(row_desc);
      if ((ret = row_desc.get_tid_cid(0, table_id, column_id)) != OB_SUCCESS)
      {
        TRANS_LOG("Get row desc failed");
        break;
      }
      ObObj name;
      name.set_varchar(column.column_name_);
      if((ret = val_row.set_cell(table_id, column_id, name)) != OB_SUCCESS)
      {
        TRANS_LOG("Add name to ObRow failed");
        break;
      }
      if((ret = row_desc.get_tid_cid(1, table_id, column_id)) != OB_SUCCESS)
      {
        TRANS_LOG("Get row desc failed");
        break;
      }
      char type_str[OB_MAX_SYS_PARAM_NAME_LENGTH];
      int32_t type_len = OB_MAX_SYS_PARAM_NAME_LENGTH;
      switch(column.data_type_)
      {
        case ObNullType:
          type_len = snprintf(type_str, type_len, "null");
          break;
        case ObIntType:
          type_len = snprintf(type_str, type_len, "int");
          break;
        case ObInt32Type:
          type_len = snprintf(type_str, type_len, "int32");
          break;
        case ObFloatType:
          type_len = snprintf(type_str, type_len, "float");
          break;
        case ObDoubleType:
          type_len = snprintf(type_str, type_len, "double");
          break;
        case ObDateTimeType:
          type_len = snprintf(type_str, type_len, "datetime");
          break;
        case ObPreciseDateTimeType:
          type_len = snprintf(type_str, type_len, "timestamp");
          break;
        case ObDateType:
          type_len = snprintf(type_str, type_len, "date");
          break;
        case ObTimeType:
          type_len = snprintf(type_str, type_len, "time");
          break;
        case ObVarcharType:
        {
          int64_t length = OB_MAX_VARCHAR_LENGTH;
          length = (column.type_length_ == 0) ? length : column.type_length_;
          type_len = snprintf(type_str, type_len, "varchar(%ld)", length);
          break;
        }
        case ObSeqType:
          type_len = snprintf(type_str, type_len, "seq");
          break;
        case ObCreateTimeType:
          type_len = snprintf(type_str, type_len, "createtime");
          break;
        case ObModifyTimeType:
          type_len = snprintf(type_str, type_len, "modifytime");
          break;
        case ObExtendType:
          type_len = snprintf(type_str, type_len, "extend");
          break;
        case ObBoolType:
          type_len = snprintf(type_str, type_len, "bool");
          break;
        case ObDecimalType:
        {
          int64_t precision = (column.precision_ == 0) ? 38 : column.precision_;
          type_len = snprintf(type_str, type_len, "decimal(%ld,%ld)", precision, column.scale_);
          break;
        }
        default:
          type_len = snprintf(type_str, type_len, "unknown");
          break;
      }
      ObString type_val(type_len, type_len, type_str);
      ObObj type;
      type.set_varchar(type_val);
      if((ret = val_row.set_cell(table_id, column_id, type)) != OB_SUCCESS)
      {
          TRANS_LOG("Add type to ObRow failed");
          break;
      }
      if((ret = row_desc.get_tid_cid(2, table_id, column_id)) != OB_SUCCESS)
      {
        TRANS_LOG("Get row desc failed");
        break;
      }
      ObObj nullable;
      if(column.not_null_)
      {
        nullable.set_int(0);
      }
      else
      {
        nullable.set_int(1);
      }
      if((ret = val_row.set_cell(table_id, column_id, nullable)) != OB_SUCCESS)
      {
        TRANS_LOG("Add nullable to ObRow failed");
        break;
      }
      if ((ret = row_desc.get_tid_cid(3, table_id, column_id)) != OB_SUCCESS)
      {
        TRANS_LOG("Get row desc failed");
        break;
      }
      ObObj key_id;
      key_id.set_int(0);//view don't have rowkey
      if((ret = val_row.set_cell(table_id, column_id, key_id)) != OB_SUCCESS)
      {
        TRANS_LOG("Add key_id to ObRow failed");
        break;
      }
      if ((ret = row_desc.get_tid_cid(4, table_id, column_id)) != OB_SUCCESS)
      {
        TRANS_LOG("Get row desc failed");
        break;
      }
      const ObObj &def = column.default_value_;
      if((ret = val_row.set_cell(table_id, column_id, def)) != OB_SUCCESS)
      {
        TRANS_LOG("Add default to ObRow failed");
        break;
      }
      if ((ret = row_desc.get_tid_cid(5, table_id, column_id)) != OB_SUCCESS)
      {
        TRANS_LOG("Get row desc failed");
        break;
      }
      ObString extra_val;
      ObObj extra;
      extra.set_varchar(extra_val);
      if((ret = val_row.set_cell(table_id, column_id, extra)) != OB_SUCCESS)
      {
        TRANS_LOG("Add extra to ObRow failed");
        break;
      }
      if(ret == OB_SUCCESS && (ret = values_op->add_values(val_row)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value row failed");
        break;
      }
    }
  }

  else if (ret == OB_SUCCESS)
  {
    const ObColumnSchemaV2* columns = NULL;
    int32_t column_size = 0;
    ObRowkeyColumn rowkey_column;
    const ObRowkeyInfo& rowkey_info = sql_context_->schema_manager_->get_table_schema(show_stmt->get_show_table_id())->get_rowkey_info();
    columns = sql_context_->schema_manager_->get_table_schema(show_stmt->get_show_table_id(), column_size);
    if (NULL != columns && column_size > 0)
    {
      for (int64_t i = 0; ret == OB_SUCCESS && i < column_size; i++)
      {
        uint64_t table_id = OB_INVALID_ID;
        uint64_t column_id = OB_INVALID_ID;
        ObRow val_row;
        val_row.set_row_desc(row_desc);

        // add name
        if ((ret = row_desc.get_tid_cid(0, table_id, column_id)) != OB_SUCCESS)
        {
          TRANS_LOG("Get row desc failed");
          break;
        }
        int32_t name_len = static_cast<int32_t>(strlen(columns[i].get_name()));
        ObString name_val(name_len, name_len, columns[i].get_name());
        ObObj name;
        name.set_varchar(name_val);
        if ((ret = val_row.set_cell(table_id, column_id, name)) != OB_SUCCESS)
        {
          TRANS_LOG("Add name to ObRow failed");
          break;
        }

        // add type
        if ((ret = row_desc.get_tid_cid(1, table_id, column_id)) != OB_SUCCESS)
        {
          TRANS_LOG("Get row desc failed");
          break;
        }
        char type_str[OB_MAX_SYS_PARAM_NAME_LENGTH];
        int32_t type_len = OB_MAX_SYS_PARAM_NAME_LENGTH;
        switch (columns[i].get_type())
        {
          case ObNullType:
            type_len = snprintf(type_str, type_len, "null");
            break;
          case ObIntType:
            type_len = snprintf(type_str, type_len, "int");
            break;
            //add lijianqiang [INT_32] 20151008:b
          case ObInt32Type:
            type_len = snprintf(type_str, type_len, "int32");
            break;
            //add 20151008:e
          case ObFloatType:
            type_len = snprintf(type_str, type_len, "float");
            break;
          case ObDoubleType:
            type_len = snprintf(type_str, type_len, "double");
            break;
          case ObDateTimeType:
            type_len = snprintf(type_str, type_len, "datetime");
            break;
          case ObPreciseDateTimeType:
            type_len = snprintf(type_str, type_len, "timestamp");
            break;
            //add peiouya [DATE_TIME] 20150906:b
          case ObDateType:
            type_len = snprintf(type_str, type_len, "date");
            break;
          case ObTimeType:
            type_len = snprintf(type_str, type_len, "time");
            break;
            //add 20150906:e
          case ObVarcharType:
            type_len = snprintf(type_str, type_len, "varchar(%ld)", columns[i].get_size());
            break;
          case ObSeqType:
            type_len = snprintf(type_str, type_len, "seq");
            break;
          case ObCreateTimeType:
            type_len = snprintf(type_str, type_len, "createtime");
            break;
          case ObModifyTimeType:
            type_len = snprintf(type_str, type_len, "modifytime");
            break;
          case ObExtendType:
            type_len = snprintf(type_str, type_len, "extend");
            break;
          case ObBoolType:
            type_len = snprintf(type_str, type_len, "bool");
            break;
          case ObDecimalType:
            //modify fanqiushi DECIMAL OceanBase_BankCommV0.3 2014_7_9:b
            //type_len = snprintf(type_str, type_len, "decimal");      //old code
            type_len = snprintf(type_str, type_len, "decimal(%d,%d)",columns[i].get_precision(), columns[i].get_scale());
            //modify:e
            break;
          default:
            type_len = snprintf(type_str, type_len, "unknown");
            break;
        }
        ObString type_val(type_len, type_len, type_str);
        ObObj type;
        type.set_varchar(type_val);
        if ((ret = val_row.set_cell(table_id, column_id, type)) != OB_SUCCESS)
        {
          TRANS_LOG("Add type to ObRow failed");
          break;
        }

        // add nullable
        if ((ret = row_desc.get_tid_cid(2, table_id, column_id)) != OB_SUCCESS)
        {
          TRANS_LOG("Get row desc failed");
          break;
        }
        //del peiouya 20131222
        //ObString nullable_val;
        ObObj nullable;
        int64_t null_value = 0;
        //add peiouya [NotNULL_check] [JHOBv0.1] 20131222:b
        if (!columns[i].is_nullable())
        {
          nullable.set_int(null_value);
        }
        else
        {
          nullable.set_int(null_value + 1);
        }
        //add 20131222:e
        if ((ret = val_row.set_cell(table_id, column_id, nullable)) != OB_SUCCESS)
        {
          TRANS_LOG("Add nullable to ObRow failed");
          break;
        }

        // add key_id
        if ((ret = row_desc.get_tid_cid(3, table_id, column_id) != OB_SUCCESS))
        {
          TRANS_LOG("Get row desc failed");
          break;
        }
        int64_t index = -1;
        rowkey_info.get_index(columns[i].get_id(), index, rowkey_column);
        ObObj key_id;
        key_id.set_int(index + 1); /* rowkey id is rowkey index plus 1 */
        if ((ret = val_row.set_cell(table_id, column_id, key_id)) != OB_SUCCESS)
        {
          TRANS_LOG("Add key_id to ObRow failed");
          break;
        }

        // add default
        if ((ret = row_desc.get_tid_cid(4, table_id, column_id) != OB_SUCCESS))
        {
          TRANS_LOG("Get row desc failed");
          break;
        }
        ObObj def;
        if (!columns[i].get_default_value_is_nullable())
        {
          int32_t def_len = static_cast<int32_t>(strlen(columns[i].get_default_val()));
          ObString def_val(def_len, def_len, columns[i].get_default_val());
          def.set_varchar(def_val);
        }
        else
        {
          def.set_null();
        }
        if ((ret = val_row.set_cell(table_id, column_id, def)) != OB_SUCCESS)
        {
          TRANS_LOG("Add default to ObRow failed");
          break;
        }

        // add extra
        if ((ret = row_desc.get_tid_cid(5, table_id, column_id) != OB_SUCCESS))
        {
          TRANS_LOG("Get row desc failed");
          break;
        }
        ObString extra_val;
        ObObj extra;
        extra.set_varchar(extra_val);
        if ((ret = val_row.set_cell(table_id, column_id, extra)) != OB_SUCCESS)
        {
          TRANS_LOG("Add extra to ObRow failed");
          break;
        }

        if (ret == OB_SUCCESS && (ret = values_op->add_values(val_row)) != OB_SUCCESS)
        {
          TRANS_LOG("Add value row failed");
          break;
        }
      }
    }
  }

  if (ret == OB_SUCCESS)
  {
    out_op = values_op;
  }

  return ret;
}

int ObTransformer::gen_phy_show_variables(
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  if (!show_stmt->is_global_scope())
  {
    ObRowDesc row_desc;
    ObValues *values_op = NULL;
    CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat);
    for (int32_t i = 0; ret == OB_SUCCESS && i < show_stmt->get_column_size(); i++)
    {
      const ColumnItem* column_item = show_stmt->get_column_item(i);
      if ((ret = row_desc.add_column_desc(column_item->table_id_,
                                          column_item->column_id_)) != OB_SUCCESS)
      {
        TRANS_LOG("Add row desc error, err=%d", ret);
      }
    }
    if (ret == OB_SUCCESS && (ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
    {
      TRANS_LOG("Set row desc error, err=%d", ret);
    }
    uint64_t table_id = OB_INVALID_ID;
    uint64_t column_id = OB_INVALID_ID;
    ObSQLSessionInfo::SysVarNameValMap::const_iterator it_begin;
    ObSQLSessionInfo::SysVarNameValMap::const_iterator it_end;
    it_begin = sql_context_->session_info_->get_sys_var_val_map().begin();
    it_end = sql_context_->session_info_->get_sys_var_val_map().end();
    for(; ret == OB_SUCCESS && it_begin != it_end; it_begin++)
    {
      ObRow val_row;
      val_row.set_row_desc(row_desc);
      ObObj var_name;
      var_name.set_varchar(it_begin->first);
      // add Variable_name
      if ((ret = row_desc.get_tid_cid(0, table_id, column_id)) != OB_SUCCESS)
      {
        TRANS_LOG("Get row desc failed");
      }
      else if ((ret = val_row.set_cell(table_id, column_id, var_name)) != OB_SUCCESS)
      {
        TRANS_LOG("Add variable name to ObRow failed");
      }
      // add Value
      else if ((ret = row_desc.get_tid_cid(1, table_id, column_id)) != OB_SUCCESS)
      {
        TRANS_LOG("Get row desc failed");
      }
      else if ((ret = val_row.set_cell(table_id, column_id, *((it_begin->second).first))) != OB_SUCCESS)
      {
        TRANS_LOG("Add value to ObRow failed");
      }
      else if ((ret = values_op->add_values(val_row)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value row failed");
      }
    }
    if (ret == OB_SUCCESS)
    {
      out_op = values_op;
    }
  }
  else
  {
    ObProject *project_op = NULL;
    ObTableRpcScan *rpc_scan_op = NULL;
    ObRpcScanHint hint;
    hint.read_method_ = ObSqlReadStrategy::USE_SCAN;
    if (CREATE_PHY_OPERRATOR(project_op, ObProject, physical_plan, err_stat) == NULL)
    {
      ret = OB_ERR_PARSER_MALLOC_FAILED;
      TRANS_LOG("Generate Project operator failed");
    }
    else if (CREATE_PHY_OPERRATOR(rpc_scan_op, ObTableRpcScan, physical_plan, err_stat) == NULL)
    {
      ret = OB_ERR_PARSER_MALLOC_FAILED;
      TRANS_LOG("Generate TableScan operator failed");
    }
    if ((ret = rpc_scan_op->set_table(OB_ALL_SYS_PARAM_TID, OB_ALL_SYS_PARAM_TID)) != OB_SUCCESS)
    {
      TRANS_LOG("ObTableRpcScan set table faild");
    }
    else if ((ret = rpc_scan_op->init(sql_context_, &hint)) != OB_SUCCESS)
    {
      TRANS_LOG("ObTableRpcScan init faild");
    }
    else if ((ret = project_op->set_child(0, *rpc_scan_op)) != OB_SUCCESS)
    {
      TRANS_LOG("Set child of Project operator faild");
    }
    else if ((ret = physical_plan->add_base_table_version(OB_ALL_SYS_PARAM_TID, 0)) != OB_SUCCESS)
    {
      TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d", OB_ALL_SYS_PARAM_TID, ret);
    }
    else
    {
      const ObSchemaManagerV2 *schema = sql_context_->schema_manager_;
      const ObColumnSchemaV2* none_concern_keys[1];
      const ObColumnSchemaV2 *name_column = NULL;
      const ObColumnSchemaV2 *value_column = NULL;
      if ((none_concern_keys[0] = schema->get_column_schema(OB_ALL_SYS_PARAM_TABLE_NAME,
                                                            "cluster_id")) == NULL
          || (name_column = schema->get_column_schema(OB_ALL_SYS_PARAM_TABLE_NAME,
                                                      "name")) == NULL
          || (value_column = schema->get_column_schema(OB_ALL_SYS_PARAM_TABLE_NAME,
                                                       "value")) == NULL)
      {
        ret = OB_ERR_COLUMN_UNKNOWN;
        TRANS_LOG("Get column of %s faild, ret = %d", OB_ALL_SYS_PARAM_TABLE_NAME, ret);
      }
      for (int32_t i = 0; ret == OB_SUCCESS && i < 1; i++)
      {
        ObObj val;
        val.set_int(0);
        ObConstRawExpr value(val, T_INT);
        ObBinaryRefRawExpr col(OB_ALL_SYS_PARAM_TID, none_concern_keys[i]->get_id(), T_REF_COLUMN);
        ObBinaryOpRawExpr equal_op(&col, &value, T_OP_EQ);
        ObSqlRawExpr col_expr(OB_INVALID_ID,
                              OB_ALL_SYS_PARAM_TID,
                              none_concern_keys[i]->get_id(),
                              &col);
        ObSqlRawExpr equal_expr(OB_INVALID_ID,
                                OB_ALL_SYS_PARAM_TID,
                                none_concern_keys[i]->get_id(),
                                &equal_op);
        ObSqlExpression output_col;
        ObSqlExpression *filter = ObSqlExpression::alloc();
        if (NULL == filter)
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
          TRANS_LOG("no memory");
        }
        else if ((ret = col_expr.fill_sql_expression(output_col)) != OB_SUCCESS)
        {
          ObSqlExpression::free(filter);
          TRANS_LOG("Generate output column of TableScan faild, ret = %d", ret);
        }
        else if ((ret = rpc_scan_op->add_output_column(output_col)) != OB_SUCCESS)
        {
          ObSqlExpression::free(filter);
          TRANS_LOG("Add output column to TableScan faild, ret = %d", ret);
        }
        else if ((ret = equal_expr.fill_sql_expression(*filter)) != OB_SUCCESS)
        {
          ObSqlExpression::free(filter);
          TRANS_LOG("Generate filter faild, ret = %d", ret);
        }
        else if ((ret = rpc_scan_op->add_filter(filter)) != OB_SUCCESS)
        {
          TRANS_LOG("Add filter to TableScan faild, ret = %d", ret);
        }
      }
      if (ret == OB_SUCCESS)
      {
        ObBinaryRefRawExpr col(OB_ALL_SYS_PARAM_TID, name_column->get_id(), T_REF_COLUMN);
        ObSqlRawExpr expr(OB_INVALID_ID, OB_ALL_SYS_PARAM_TID, name_column->get_id(), &col);
        ObSqlExpression output_expr;
        const ColumnItem* column_item = NULL;
        if ((ret = expr.fill_sql_expression(output_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Generate output column faild, ret = %d", ret);
        }
        else if ((ret = rpc_scan_op->add_output_column(output_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add output column to TableScan faild, ret = %d", ret);
        }
        else if ((column_item = show_stmt->get_column_item(0)) == NULL)
        {
          TRANS_LOG("Can not get column item of 'name'");
        }
        else
        {
          output_expr.set_tid_cid(column_item->table_id_, column_item->column_id_);
          if ((ret = project_op->add_output_column(output_expr)) != OB_SUCCESS)
          {
            TRANS_LOG("Add output column to Project faild, ret = %d", ret);
          }
        }
      }
      if (ret == OB_SUCCESS)
      {
        ObBinaryRefRawExpr col(OB_ALL_SYS_PARAM_TID, value_column->get_id(), T_REF_COLUMN);
        ObSqlRawExpr expr(OB_INVALID_ID, OB_ALL_SYS_PARAM_TID, value_column->get_id(), &col);
        ObSqlExpression output_expr;
        const ColumnItem* column_item = NULL;
        if ((ret = expr.fill_sql_expression(output_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Generate output column faild, ret = %d", ret);
        }
        else if ((ret = rpc_scan_op->add_output_column(output_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add output column to TableScan faild, ret = %d", ret);
        }
        else if ((column_item = show_stmt->get_column_item(1)) == NULL)
        {
          TRANS_LOG("Can not get column item of 'value'");
        }
        else
        {
          output_expr.set_tid_cid(column_item->table_id_, column_item->column_id_);
          if ((ret = project_op->add_output_column(output_expr)) != OB_SUCCESS)
          {
            TRANS_LOG("Add output column to Project faild, ret = %d", ret);
          }
        }
      }
    }
    if (ret == OB_SUCCESS)
    {
      out_op = project_op;
    }
  }
  return ret;
}

int ObTransformer::gen_phy_show_warnings(
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObRowDesc row_desc;
  ObValues *values_op = NULL;
  CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat);
  if (OB_SUCCESS == ret)//add qianzm [null operator unjudgement bug1181] 20160520
  {
    if (sql_context_->session_info_ == NULL)
    {
      ret = OB_ERR_GEN_PLAN;
      TRANS_LOG("can not get current session info, err=%d", ret);
    }
    else
    {
      const yysys::WarningBuffer& warnings_buf = sql_context_->session_info_->get_warnings_buffer();
      if (show_stmt->is_count_warnings())
      {
        /* show COUNT(*) warnings */
        if ((ret = row_desc.add_column_desc(OB_INVALID_ID, OB_APP_MIN_COLUMN_ID)) != OB_SUCCESS)
        {
          TRANS_LOG("add row desc error, err=%d", ret);
        }
        else if (ret == OB_SUCCESS && (ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
        {
          TRANS_LOG("set row desc error, err=%d", ret);
        }
        else
        {
          ObRow val_row;
          val_row.set_row_desc(row_desc);
          ObObj num;
          num.set_int(warnings_buf.get_readable_warning_count());
          if ((ret = val_row.set_cell(OB_INVALID_ID, OB_APP_MIN_COLUMN_ID, num)) != OB_SUCCESS)
          {
            TRANS_LOG("Add 'code' to ObRow failed");
          }
          else if ((ret = values_op->add_values(val_row)) != OB_SUCCESS)
          {
            TRANS_LOG("Add value row failed");
          }
        }
      }
      else
      {
        /* show warnings [limit] */
        // add descriptor
        for (int32_t i = 0; ret == OB_SUCCESS && i < 3; i++)
        {
          if ((ret = row_desc.add_column_desc(OB_INVALID_ID, i + OB_APP_MIN_COLUMN_ID)) != OB_SUCCESS)
          {
            TRANS_LOG("add row desc error, err=%d", ret);
            break;
          }
        }
        if (ret == OB_SUCCESS && (ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
        {
          TRANS_LOG("set row desc error, err=%d", ret);
        }
        // add values
        else
        {
          uint32_t j = 0;
          int64_t k = 0;
          for (; ret == OB_SUCCESS && j < warnings_buf.get_readable_warning_count()
               && (k < show_stmt->get_warnings_count() || show_stmt->get_warnings_count() < 0);
               j++, k++)
          {
            ObRow val_row;
            val_row.set_row_desc(row_desc);
            // can not get level, get it from string
            const char* warning_ptr = warnings_buf.get_warning(j);
            if (warning_ptr == NULL)
              continue;
            const char* separator = strchr(warning_ptr, ' ');
            if (separator == NULL)
            {
              YYSYS_LOG(WARN, "Wrong message in warnings buffer: %s", warning_ptr);
              continue;
            }
            ObObj level;
            level.set_varchar(ObString::make_string("Warning"));
            if ((ret = val_row.set_cell(OB_INVALID_ID, OB_APP_MIN_COLUMN_ID, level)) != OB_SUCCESS)
            {
              TRANS_LOG("Add 'level' to ObRow failed");
              break;
            }
            // code, can not get it
            ObObj code;
            code.set_int(99999);
            if ((ret = val_row.set_cell(OB_INVALID_ID, 1 + OB_APP_MIN_COLUMN_ID, code)) != OB_SUCCESS)
            {
              TRANS_LOG("Add 'code' to ObRow failed");
              break;
            }
            // message
            // pls see the warning format
            int32_t msg_len = static_cast<int32_t>(strlen(warning_ptr));
            ObString msg_str(msg_len, msg_len, warning_ptr);
            ObObj message;
            message.set_varchar(msg_str);
            if ((ret = val_row.set_cell(OB_INVALID_ID, 2 + OB_APP_MIN_COLUMN_ID, message)) != OB_SUCCESS)
            {
              TRANS_LOG("Add 'message' to ObRow failed");
              break;
            }
            else if ((ret = values_op->add_values(val_row)) != OB_SUCCESS)
            {
              TRANS_LOG("Add value row failed");
              break;
            }
          }
        }
      }
    }
  }
  if (ret == OB_SUCCESS)
  {
    out_op = values_op;
  }
  return ret;
}

int ObTransformer::gen_phy_show_grants(
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObRowDesc row_desc;
  ObValues *values_op = NULL;
  CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat);
  if (OB_SUCCESS == ret)//add qianzm [null operator unjudgement bug1181] 20160520
  {
    if ((ret = row_desc.add_column_desc(OB_INVALID_ID, OB_APP_MIN_COLUMN_ID)) != OB_SUCCESS)
    {
      TRANS_LOG("add row desc error, err=%d", ret);
    }
    else if ((ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
    {
      TRANS_LOG("set row desc error, err=%d", ret);
    }
    else
    {
      out_op = values_op;
      const ObPrivilege **pp_privilege  = sql_context_->pp_privilege_;
      ObString user_name = show_stmt->get_user_name();
      int64_t pos = 0;
      char buf[512];
      if (show_stmt->get_user_name().length() == 0)
      {
        user_name = sql_context_->session_info_->get_user_name();
      }
      const common::ObSchemaManagerV2 *schema_manager = sql_context_->schema_manager_;
      const ObTableSchema* table_schema = NULL;
      ObPrivilege::NameUserMap *username_map = (const_cast<ObPrivilege*>(*pp_privilege))->get_username_map();
      //add liumz, [multi_database.priv_management.show_grants]:20150610:b
      ObPrivilege::UserDbPriMap *user_db_map = (const_cast<ObPrivilege*>(*pp_privilege))->get_user_database_privilege_map();
      //add:e
      ObPrivilege::UserPrivMap *user_table_map = (const_cast<ObPrivilege*>(*pp_privilege))->get_user_table_map();
      ObPrivilege::User user;
      ret = username_map->get(user_name, user);
      if (-1 == ret || hash::HASH_NOT_EXIST == ret)
      {
        ret = OB_ERR_USER_NOT_EXIST;
        TRANS_LOG("user[%.*s] not exists", user_name.length(), user_name.ptr());
        YYSYS_LOG(WARN, "username:%.*s 's not exist, ret=%d", user_name.length(), user_name.ptr(), ret);
        //ret = OB_ERR_USER_NOT_EXIST;
      }
      else
      {
        ret = OB_SUCCESS;
        const ObBitSet<> &privileges = user.privileges_;
        if (privileges.is_empty())
        {
        }
        else
        {
          //del liumz, [multi_database.priv_management.show_grants]:20150610:b
          /*databuff_printf(buf, 512, pos, "GRANT ");
        if (privileges.has_member(OB_PRIV_ALL))
        {
          databuff_printf(buf, 512, pos, "ALL PRIVILEGES ");
          if (privileges.has_member(OB_PRIV_GRANT_OPTION))
          {
            databuff_printf(buf, 512, pos, ",GRANT OPTION ON * TO '%.*s'", user_name.length(), user_name.ptr());
          }
          else
          {
            databuff_printf(buf, 512, pos, "ON * TO '%.*s'", user_name.length(), user_name.ptr());
          }
        }
        else
        {
          ObPrivilege::privilege_to_string(privileges, buf, 512, pos);
          pos = pos - 1;
          databuff_printf(buf, 512, pos, " ON * TO '%.*s'", user_name.length(), user_name.ptr());
        }*/
          //del:e
          //add liumz, [multi_database.priv_management.show_grants]:20150610:b
          ObPrivilege::privilege_to_string_v2(privileges, buf, 512, pos);
          //add:e
          pos = pos - 1;
          databuff_printf(buf, 512, pos, " ON * TO '%.*s'", user_name.length(), user_name.ptr());
          //add:e
          ObRow val_row;
          val_row.set_row_desc(row_desc);
          ObString grant_str;
          if (pos >= 511)
          {
            // overflow
            ret = OB_BUF_NOT_ENOUGH;
            YYSYS_LOG(WARN, "privilege buffer not enough, ret=%d", ret);
          }
          else
          {
            grant_str.assign_ptr(buf, static_cast<int32_t>(pos));
            ObObj grant_val;
            grant_val.set_varchar(grant_str);
            if (OB_SUCCESS != (ret = val_row.set_cell(OB_INVALID_ID, OB_APP_MIN_COLUMN_ID, grant_val)))
            {
              YYSYS_LOG(WARN, "set cell fail:ret[%d]", ret);
            }
            else if (OB_SUCCESS != (ret = values_op->add_values(val_row)))
            {
              TRANS_LOG("add value row failed");
            }
          }
        }
      }
      //add liumz, [multi_database.priv_management.show_grants]:20150610:b
      if (OB_SUCCESS == ret)
      {
        uint64_t user_id = user.user_id_;
        ObPrivilege::UserDbPriMap::iterator iter = user_db_map->begin();
        for (;iter != user_db_map->end();++iter)
        {
          pos = 0;
          //databuff_printf(buf, 512, pos, "GRANT ");
          const ObPrivilege::UserIdDatabaseId &user_id_db_id = iter->first;
          if (user_id_db_id.userid_ == user_id)
          {
            const ObBitSet<> &privileges = (iter->second).privileges_;
            if (privileges.is_empty())
            {
              continue;
            }
            else
            {
              //ObPrivilege::privilege_to_string(privileges, buf, 512, pos);
              ObString db_name;
              if (OB_SUCCESS != (ret = (*pp_privilege)->get_db_name(user_id_db_id.dbid_, db_name)))
              {
                YYSYS_LOG(WARN, "can not get db name, db_id=%lu", user_id_db_id.dbid_);
              }
              else
              {
                ObPrivilege::privilege_to_string_v2(privileges, buf, 512, pos);
                pos = pos - 1;
                databuff_printf(buf, 512, pos, " ON %.*s.* TO '%.*s'", db_name.length(), db_name.ptr(), user_name.length(), user_name.ptr());
                ObRow val_row;
                val_row.set_row_desc(row_desc);
                ObString grant_str;
                if (pos >= 511)
                {
                  // overflow
                  ret = OB_BUF_NOT_ENOUGH;
                  YYSYS_LOG(WARN, "privilege buffer not enough, ret=%d", ret);
                }
                else
                {
                  grant_str.assign_ptr(buf, static_cast<int32_t>(pos));
                  ObObj grant_val;
                  grant_val.set_varchar(grant_str);
                  if (OB_SUCCESS != (ret = val_row.set_cell(OB_INVALID_ID, OB_APP_MIN_COLUMN_ID, grant_val)))
                  {
                    YYSYS_LOG(WARN, "set cell fail:ret[%d]", ret);
                  }
                  else if (OB_SUCCESS != (ret = values_op->add_values(val_row)))
                  {
                    TRANS_LOG("add value row failed");
                  }
                }
              }
            }
          }
          else
          {
            continue;
          }
        }
      }
      //add:e
      if (OB_SUCCESS == ret)
      {
        uint64_t user_id = user.user_id_;
        ObPrivilege::UserPrivMap::iterator iter = user_table_map->begin();
        for (;iter != user_table_map->end();++iter)
        {
          pos = 0;
          //del liumz,
          //databuff_printf(buf, 512, pos, "GRANT ");
          const ObPrivilege::UserIdTableId &user_id_table_id = iter->first;
          if (user_id_table_id.user_id_ == user_id)
          {
            const ObBitSet<> &privileges = (iter->second).table_privilege_.privileges_;
            if (privileges.is_empty())
            {
              continue;
            }
            else
            {
              //del liumz,
              //ObPrivilege::privilege_to_string(privileges, buf, 512, pos);
              table_schema = schema_manager->get_table_schema(user_id_table_id.table_id_);
              if (NULL == table_schema)
              {
                //�������������ԭ������Ǳ�ĻỰͨ��ͬһ���û��½���һ���±���Ȩ����Ϣ�Ѿ����µ��˱��أ�����schema��Ϣ��û�и��µ�����
                //��������Ϊһ�ִ���Ŀǰ��������ʾ���ű���Ȩ����Ϣ����
                YYSYS_LOG(WARN, "table id=%lu not exist in schema manager", user_id_table_id.table_id_);
              }
              else
              {
                const char *table_name = table_schema->get_table_name();
                //add liumz, [multi_database.priv_management.show_grants]:20150610:b
                ObPrivilege::privilege_to_string_v2(privileges, buf, 512, pos);
                //add:e
                pos = pos - 1;
                databuff_printf(buf, 512, pos, " ON %s TO '%.*s'", table_name, user_name.length(), user_name.ptr());
                ObRow val_row;
                val_row.set_row_desc(row_desc);
                ObString grant_str;
                if (pos >= 511)
                {
                  // overflow
                  ret = OB_BUF_NOT_ENOUGH;
                  YYSYS_LOG(WARN, "privilege buffer not enough, ret=%d", ret);
                }
                else
                {
                  grant_str.assign_ptr(buf, static_cast<int32_t>(pos));
                  ObObj grant_val;
                  grant_val.set_varchar(grant_str);
                  if (OB_SUCCESS != (ret = val_row.set_cell(OB_INVALID_ID, OB_APP_MIN_COLUMN_ID, grant_val)))
                  {
                    YYSYS_LOG(WARN, "set cell fail:ret[%d]", ret);
                  }
                  else if (OB_SUCCESS != (ret = values_op->add_values(val_row)))
                  {
                    TRANS_LOG("add value row failed");
                  }
                }
              }
            }
          }
          else
          {
            continue;
          }
        }
      }
    }
  }
  return ret;
}

int ObTransformer::gen_phy_show_table_status(
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  UNUSED(show_stmt);
  ObValues *values_op = NULL;
  if (NULL == CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else
  {
    // @todo empty
    out_op = values_op;
  }
  return ret;
}

int ObTransformer::gen_phy_show_processlist(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  UNUSED(show_stmt);
  ObTableScan *table_scan_op = NULL;
  if (ret == OB_SUCCESS)
  {
    ObTableRpcScan *table_rpc_scan_op = NULL;
    ObRpcScanHint hint;
    hint.read_method_ = ObSqlReadStrategy::USE_SCAN;
    CREATE_PHY_OPERRATOR(table_rpc_scan_op, ObTableRpcScan, physical_plan, err_stat);
    if (ret == OB_SUCCESS
        && (ret = table_rpc_scan_op->set_table(OB_ALL_SERVER_SESSION_TID, OB_ALL_SERVER_SESSION_TID)) != OB_SUCCESS)
    {
      TRANS_LOG("ObTableRpcScan set table faild");
    }
    if (ret == OB_SUCCESS && (ret = table_rpc_scan_op->init(sql_context_, &hint)) != OB_SUCCESS)
    {
      TRANS_LOG("ObTableRpcScan init faild");
    }
    if (ret == OB_SUCCESS && (ret = physical_plan->add_base_table_version(OB_ALL_SERVER_SESSION_TID, 0)) != OB_SUCCESS)
    {
      TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d", OB_ALL_SERVER_SESSION_TID, ret);
    }
    if (ret == OB_SUCCESS)
    {
      table_scan_op = table_rpc_scan_op;
    }
  }

  // add output columns
  int32_t num = 10; //column num of show processlist
  //for (int32_t i = 1; ret == OB_SUCCESS && i <= num; i++)
  for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
  {
    ObBinaryRefRawExpr col_expr(OB_ALL_SERVER_SESSION_TID, OB_APP_MIN_COLUMN_ID + i, T_REF_COLUMN);
    ObSqlRawExpr col_raw_expr(
          common::OB_INVALID_ID,
          OB_ALL_SERVER_SESSION_TID,
          OB_APP_MIN_COLUMN_ID + i,
          &col_expr);
    ObSqlExpression output_expr;
    if ((ret = col_raw_expr.fill_sql_expression(
           output_expr,
           this,
           logical_plan,
           physical_plan)) != OB_SUCCESS
        || (ret = table_scan_op->add_output_column(output_expr)) != OB_SUCCESS)
    {
      TRANS_LOG("Add table output columns faild");
      break;
    }
  }

  if (ret == OB_SUCCESS)
  {
    out_op = table_scan_op;
  }
  return ret;
}

int ObTransformer::gen_physical_show(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObShowStmt *show_stmt = NULL;
  ObPhyOperator *result_op = NULL;

  /* get statement */
  if (ret == OB_SUCCESS)
  {
    get_stmt(logical_plan, err_stat, query_id, show_stmt);
  }

  if (ret == OB_SUCCESS)
  {
    switch (show_stmt->get_stmt_type())
    {
      case ObBasicStmt::T_SHOW_TABLES:
        ret = gen_phy_show_tables(physical_plan, err_stat, show_stmt, result_op);
        break;
        // add by zhangcd [multi_database.show_tables] 20150616:b
      case ObBasicStmt::T_SHOW_SYSTEM_TABLES:
        ret = gen_phy_show_system_tables(physical_plan, err_stat, show_stmt, result_op);
        break;
        // add by zhangcd [multi_database.show_tables] 20150616:e
        // add by zhangcd [multi_database.show_databases] 20150617:b
      case ObBasicStmt::T_SHOW_DATABASES:
        ret = gen_phy_show_databases(physical_plan, err_stat, show_stmt, result_op);
        break;
        // add by zhangcd [multi_database.show_databases] 20150617:e
        // add by zhangcd [multi_database.show_databases] 20150617:b
      case ObBasicStmt::T_SHOW_CURRENT_DATABASE:
        ret = gen_phy_show_current_database(physical_plan, err_stat, show_stmt, result_op);
        break;
        // add by zhangcd [multi_database.show_databases] 20150617:e
        //add liumengzhan_show_index [20141208]
      case ObBasicStmt::T_SHOW_INDEX:
        ret = gen_phy_show_index(physical_plan, err_stat, show_stmt, result_op);
        break;
        //add:e
      case ObBasicStmt::T_SHOW_ALL_INDEX:
        ret = gen_phy_show_all_index(physical_plan, err_stat, show_stmt, result_op);
        break;
      case ObBasicStmt::T_SHOW_CREATE_INDEX:
        ret = gen_phy_show_create_index(physical_plan, err_stat, show_stmt, result_op);
        break;
      case ObBasicStmt::T_SHOW_COLUMNS:
        ret = gen_phy_show_columns(physical_plan, err_stat, show_stmt, result_op);
        break;
      case ObBasicStmt::T_SHOW_VARIABLES:
        ret = gen_phy_show_variables(physical_plan, err_stat, show_stmt, result_op);
        break;
      case ObBasicStmt::T_SHOW_TABLE_STATUS:
        ret = gen_phy_show_table_status(physical_plan, err_stat, show_stmt, result_op);
        break;
      case ObBasicStmt::T_SHOW_SCHEMA:
      case ObBasicStmt::T_SHOW_SERVER_STATUS:
        TRANS_LOG("This statment not support now!");
        break;
      case ObBasicStmt::T_SHOW_CREATE_TABLE:
        ret = gen_phy_show_create_table(physical_plan, err_stat, show_stmt, result_op);
        break;
      case ObBasicStmt::T_SHOW_CREATE_VIEW:
        ret = gen_phy_show_create_view(physical_plan, err_stat, show_stmt, result_op);
        break;
      case ObBasicStmt::T_SHOW_WARNINGS:
        ret = gen_phy_show_warnings(physical_plan, err_stat, show_stmt, result_op);
        break;
      case ObBasicStmt::T_SHOW_GRANTS:
        ret = gen_phy_show_grants(physical_plan, err_stat, show_stmt, result_op);
        break;
      case ObBasicStmt::T_SHOW_PARAMETERS:
        ret = gen_phy_show_parameters(logical_plan, physical_plan, err_stat, show_stmt, result_op);
        break;
        //add liu jun.[MultiUps_Live] 20150325:b
      case ObBasicStmt::T_SHOW_FUNCTIONS:
        ret = gen_phy_show_partition_functions_rules_groups(logical_plan, physical_plan, err_stat, show_stmt,
                                                            result_op,OB_ALL_PARTITION_RULES_TID,OB_ALL_PARTITION_RULES_NAME);
        break;
        //add 20150325:e
        //add wuna.[MultiUPS] [sql_api] 20160223:b
      case ObBasicStmt::T_SHOW_TABLE_RULES:
        ret = gen_phy_show_partition_functions_rules_groups(logical_plan, physical_plan, err_stat, show_stmt,
                                                            result_op,OB_ALL_TABLE_RULES_TID,OB_ALL_TABLE_RULES_NAME);
        break;
      case ObBasicStmt::T_SHOW_GROUPS:
        ret = gen_phy_show_partition_functions_rules_groups(logical_plan, physical_plan, err_stat, show_stmt,
                                                            result_op,OB_ALL_ALL_GROUP_TID,OB_ALL_ALL_GROUP_NAME);
        break;
        //add 20160223:e
      case ObBasicStmt::T_SHOW_CURRENT_PAXOS_ID:
        ret = gen_phy_show_current_paxos_id(physical_plan, err_stat, show_stmt, result_op);
        break;
      case ObBasicStmt::T_SHOW_PROCESSLIST:
        ret = gen_phy_show_processlist(logical_plan, physical_plan, err_stat, show_stmt, result_op);
        break;
      default:
        ret = OB_ERR_GEN_PLAN;
        TRANS_LOG("Unknown show statment!");
        break;
    }
  }
  if (ret == OB_SUCCESS)
  {
    ObFilter *filter_op = NULL;
    if (show_stmt->get_like_pattern().length() > 0)
    {
      ObObj pattern_val;
      pattern_val.set_varchar(show_stmt->get_like_pattern());
      ObConstRawExpr pattern_expr(pattern_val, T_STRING);
      pattern_expr.set_result_type(ObVarcharType);
      ObBinaryRefRawExpr col_expr(show_stmt->get_sys_table_id(), OB_INVALID_ID, T_REF_COLUMN);
      const ObColumnSchemaV2* name_col = NULL;
      const ObColumnSchemaV2* columns = NULL;
      int32_t column_size = 0;
      ObSchemaChecker schema_checker;
      schema_checker.set_schema(*sql_context_->schema_manager_);
      //mod by liu jun.[MultiUps_Live] 20150325:b
      //if (show_stmt->get_stmt_type() == ObBasicStmt::T_SHOW_PARAMETERS)
      if (show_stmt->get_stmt_type() == ObBasicStmt::T_SHOW_PARAMETERS
          ||show_stmt->get_stmt_type() == ObBasicStmt::T_SHOW_FUNCTIONS
          ||show_stmt->get_stmt_type() == ObBasicStmt::T_SHOW_TABLE_RULES
          ||show_stmt->get_stmt_type() == ObBasicStmt::T_SHOW_GROUPS
          ||show_stmt->get_stmt_type() == ObBasicStmt::T_SHOW_ALL_INDEX)
      {
        /*       if ((name_col = schema_checker.get_column_schema(
                         show_stmt->get_table_item(0).table_name_,
                         ObString::make_string("name")
                         )) == NULL)
                {
                }
       */
        if (show_stmt->get_stmt_type() == ObBasicStmt::T_SHOW_PARAMETERS
            && (name_col = schema_checker.get_column_schema(
                  show_stmt->get_table_item(0).table_name_,
                  ObString::make_string("name")
                  )) == NULL)
        {
        }
        else if (show_stmt->get_stmt_type() == ObBasicStmt::T_SHOW_FUNCTIONS
                 && (name_col = schema_checker.get_column_schema(
                       show_stmt->get_table_item(0).table_name_,
                       ObString::make_string("rule_name")
                       )) == NULL)
        {
        }
        else if (show_stmt->get_stmt_type() == ObBasicStmt::T_SHOW_TABLE_RULES
                 && (name_col = schema_checker.get_column_schema(
                       show_stmt->get_table_item(0).table_name_,
                       ObString::make_string("table_name")
                       )) == NULL)
        {
        }
        else if (show_stmt->get_stmt_type() == ObBasicStmt::T_SHOW_GROUPS
                 && (name_col = schema_checker.get_column_schema(
                       show_stmt->get_table_item(0).table_name_,
                       ObString::make_string("group_name")
                       )) == NULL)
        {
        }
        // 20151019:e
        else if(show_stmt->get_stmt_type() == ObBasicStmt::T_SHOW_ALL_INDEX
                && (name_col = schema_checker.get_column_schema(
                      show_stmt->get_table_item(0).table_name_,
                      ObString::make_string("index_name")
                      )) == NULL)
        {
        }
        else
        {
          col_expr.set_second_ref_id(name_col->get_id());
          col_expr.set_result_type(name_col->get_type());
        }
      }
      else
      {
        if ((columns = schema_checker.get_table_columns(
               show_stmt->get_sys_table_id(),
               column_size)) == NULL
            || column_size <= 0)
        {
          ret = OB_ERR_GEN_PLAN;
          TRANS_LOG("Get show table schema error!");
        }
        else
        {
          col_expr.set_second_ref_id(columns[0].get_id());
          col_expr.set_result_type(columns[0].get_type());
        }
      }
      if (ret == OB_SUCCESS)
      {
        ObBinaryOpRawExpr like_op_expr(&col_expr, &pattern_expr, T_OP_LIKE);
        like_op_expr.set_result_type(ObBoolType);
        ObSqlRawExpr raw_like_expr(OB_INVALID_ID, col_expr.get_first_ref_id(),
                                   col_expr.get_second_ref_id(), &like_op_expr);
        ObSqlExpression *like_expr = ObSqlExpression::alloc();
        if (NULL == like_expr
            || (ret = raw_like_expr.fill_sql_expression(*like_expr, this, logical_plan, physical_plan)) != OB_SUCCESS)
        {
          TRANS_LOG("Gen like filter failed!");
        }
        else if (CREATE_PHY_OPERRATOR(filter_op, ObFilter, physical_plan, err_stat) == NULL)
        {
          ObSqlExpression::free(like_expr);
        }
        else if ((ret = filter_op->set_child(0, *result_op)) != OB_SUCCESS)
        {
          ObSqlExpression::free(like_expr);
          TRANS_LOG("Add child of filter plan failed");
        }
        else if ((ret = filter_op->add_filter(like_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add filter expression failed");
        }
      }
    }
    else if (show_stmt->get_condition_size() > 0)
    {
      CREATE_PHY_OPERRATOR(filter_op, ObFilter, physical_plan, err_stat);
      for (int32_t i = 0; ret == OB_SUCCESS && i < show_stmt->get_condition_size(); i++)
      {
        ObSqlRawExpr *cnd_expr = logical_plan->get_expr(show_stmt->get_condition_id(i));
        if (cnd_expr->is_apply() == true)
        {
          continue;
        }
        else
        {
          ObSqlExpression *filter = ObSqlExpression::alloc();
          if (NULL == filter)
          {
            ret = OB_ALLOCATE_MEMORY_FAILED;
            YYSYS_LOG(ERROR, "no memory");
            break;
          }
          else if ((ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan)) != OB_SUCCESS
                   || (ret = filter_op->add_filter(filter)) != OB_SUCCESS)
          {
            ObSqlExpression::free(filter);
            TRANS_LOG("Add table filter condition faild");
            break;
          }
        }
      } // end for
      if (ret == OB_SUCCESS && (ret = filter_op->set_child(0, *result_op))!= OB_SUCCESS)
      {
        TRANS_LOG("Add child of filter plan failed");
      }
    }
    if (ret == OB_SUCCESS && filter_op != NULL)
    {
      result_op = filter_op;
    }
  }
  if (ret == OB_SUCCESS)
  {
    ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, show_stmt, result_op, index);
  }

  return ret;
}

int ObTransformer::gen_physical_prepare(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObPrepare *result_op = NULL;
  ObPrepareStmt *stmt = NULL;
  /* get prepare statement */
  get_stmt(logical_plan, err_stat, query_id, stmt);
  /* add prepare operator */
  if (ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(result_op, ObPrepare, physical_plan, err_stat);
    if (ret == OB_SUCCESS)
    {
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, stmt, result_op, index);
    }
  }

  if (ret == OB_SUCCESS)
  {
    ObPhyOperator* op = NULL;
    ObString stmt_name;
    int32_t idx = OB_INVALID_INDEX;
    if ((ret = ob_write_string(*mem_pool_, stmt->get_stmt_name(), stmt_name)) != OB_SUCCESS)
    {
      TRANS_LOG("Add prepare plan for stmt %.*s faild",
                stmt->get_stmt_name().length(), stmt->get_stmt_name().ptr());
    }
    else
    {
      result_op->set_stmt_name(stmt_name);

      if ((ret = generate_physical_plan(
             logical_plan,
             physical_plan,
             err_stat,
             stmt->get_prepare_query_id(),
             &idx,
             false
             )) != OB_SUCCESS)
      {
        YYSYS_LOG(WARN, "Create physical plan for query statement failed, err=%d", ret);
      }
      else if ((op = physical_plan->get_phy_query(idx)) == NULL
               || (ret = result_op->set_child(0, *op)) != OB_SUCCESS)
      {
        ret = OB_ERR_ILLEGAL_INDEX;
        TRANS_LOG("Set child of Prepare Operator failed");
      }
    }
  }

  return ret;
}

int ObTransformer::gen_physical_variable_set(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObVariableSet *result_op = NULL;
  ObVariableSetStmt *stmt = NULL;
  /* get variable set statement */
  get_stmt(logical_plan, err_stat, query_id, stmt);
  /* generate operator */
  if (ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(result_op, ObVariableSet, physical_plan, err_stat);
    if (ret == OB_SUCCESS)
    {
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, stmt, result_op, index);
    }
  }
  if (ret == OB_SUCCESS)
  {
    const ObTableSchema *table_schema = NULL;
    const ObColumnSchemaV2* name_column = NULL;
    const ObColumnSchemaV2* type_column = NULL;
    const ObColumnSchemaV2* value_column = NULL;
    if ((table_schema = sql_context_->schema_manager_->get_table_schema(
           OB_ALL_SYS_PARAM_TID)) == NULL)
    {
      ret = OB_ERR_TABLE_UNKNOWN;
      TRANS_LOG("Fail to get table schema for table[%ld]", OB_ALL_SYS_PARAM_TID);
    }
    else if ((name_column = sql_context_->schema_manager_->get_column_schema(
                OB_ALL_SYS_PARAM_TABLE_NAME, "name")) == NULL)
    {
      ret = OB_ERR_COLUMN_NOT_FOUND;
      TRANS_LOG("Column name not found");
    }
    else if ((type_column = sql_context_->schema_manager_->get_column_schema(
                OB_ALL_SYS_PARAM_TABLE_NAME, "data_type")) == NULL)
    {
      ret = OB_ERR_COLUMN_NOT_FOUND;
      TRANS_LOG("Column type not found");
    }
    else if ((value_column = sql_context_->schema_manager_->get_column_schema(
                OB_ALL_SYS_PARAM_TABLE_NAME, "value")) == NULL)
    {
      ret = OB_ERR_COLUMN_NOT_FOUND;
      TRANS_LOG("Column value not found");
    }
    else
    {
      result_op->set_rpc_stub(sql_context_->merger_rpc_proxy_);
      result_op->set_table_id(OB_ALL_SYS_PARAM_TID);
      result_op->set_name_cid(name_column->get_id());
      result_op->set_rowkey_info(table_schema->get_rowkey_info());
      result_op->set_value_column(value_column->get_id(), value_column->get_type());
    }
  }
  int64_t variables_num = stmt->get_variables_size();
  for (int64_t i = 0; ret == OB_SUCCESS && i < variables_num; i++)
  {
    const ObVariableSetStmt::VariableSetNode& var_stmt_node = stmt->get_variable_node(static_cast<int32_t>(i));
    ObVariableSet::VariableSetNode var_op_node;
    ObSqlRawExpr *expr = NULL;
    int64_t var_value = 0;
    var_op_node.is_system_variable_ = var_stmt_node.is_system_variable_;
    var_op_node.is_global_ = (var_stmt_node.scope_type_ == ObVariableSetStmt::GLOBAL);
    if (var_stmt_node.is_system_variable_ &&
        !sql_context_->session_info_->sys_variable_exists(var_stmt_node.variable_name_))
    {
      ret = OB_ERR_VARIABLE_UNKNOWN;
      TRANS_LOG("System variable %.*s Unknown", var_stmt_node.variable_name_.length(),
                var_stmt_node.variable_name_.ptr());
    }
    else if (var_op_node.is_global_ && var_stmt_node.variable_name_ == ObString::make_string("autocommit"))
    {
      ret = OB_NOT_SUPPORTED;
      YYSYS_LOG(USER_ERROR, "Not support set global autocommit");
      break;
    }
    else if ((ret = ob_write_string(*mem_pool_,
                                    var_stmt_node.variable_name_,
                                    var_op_node.variable_name_)) != OB_SUCCESS)
    {
      TRANS_LOG("Make place for variable name %.*s failed",
                var_stmt_node.variable_name_.length(), var_stmt_node.variable_name_.ptr());
    }
    else if ((expr = logical_plan->get_expr(var_stmt_node.value_expr_id_)) == NULL)
    {
      ret = OB_ERR_ILLEGAL_ID;
      TRANS_LOG("Wrong expression id, id=%lu", var_stmt_node.value_expr_id_);
    }
    else if (var_op_node.is_system_variable_
             &&
             expr->get_result_type() != ObNullType
             &&
             expr->get_result_type() != (sql_context_->session_info_->get_sys_variable_type(var_stmt_node.variable_name_))
             )
    {
      ret = OB_OBJ_TYPE_ERROR;
      TRANS_LOG("type not match");
      YYSYS_LOG(WARN, "type not match, ret=%d", ret);
    }
    else if ((var_op_node.variable_expr_ = ObSqlExpression::alloc()) == NULL)
    {
      ret = OB_ALLOCATE_MEMORY_FAILED;
      TRANS_LOG("no memory");
    }
    else if ((ret = result_op->add_variable_node(var_op_node)) != OB_SUCCESS)
    {
      ObSqlExpression::free(var_op_node.variable_expr_);
      var_op_node.variable_expr_ = NULL;
      TRANS_LOG("Add variable entry failed");
    }
    else if ((ret = expr->fill_sql_expression(
                *var_op_node.variable_expr_,
                this,
                logical_plan,
                physical_plan)
              ) != OB_SUCCESS)
    {
      TRANS_LOG("Add value expression failed");
    }
    else if (expr->get_result_type()==ObIntType
             &&
             ((ret = (dynamic_cast<ObConstRawExpr *>(expr->get_expr()))->get_value().get_int(var_value)) ==OB_SUCCESS)
             &&
             (var_value<INT_MIN||var_value>INT_MAX)
             )
    {
      ObString var_name = var_stmt_node.variable_name_;
      if (var_name.compare(ObString::make_string(OB_QUERY_TIMEOUT_PARAM)) == 0)
      {
        ret = OB_VALUE_OUT_OF_RANGE;
        TRANS_LOG("value out of range");
        YYSYS_LOG(WARN, "value out of range, ret=%d",ret);
        snprintf(err_stat.err_msg_, MAX_ERROR_MSG," value out of range");
      }
    }
  }
  return ret;
}

int ObTransformer::gen_physical_execute(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObExecute *result_op = NULL;
  ObExecuteStmt *stmt = NULL;
  /* get execute statement */
  get_stmt(logical_plan, err_stat, query_id, stmt);
  /* generate operator */
  if (ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(result_op, ObExecute, physical_plan, err_stat);
    if (ret == OB_SUCCESS)
    {
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, stmt, result_op, index);
    }
  }

  ObSQLSessionInfo *session_info = NULL;
  if (ret == OB_SUCCESS
      && (sql_context_ == NULL || (session_info = sql_context_->session_info_) == NULL))
  {
    ret = OB_NOT_INIT;
    TRANS_LOG("Session info is not initiated");
  }
  //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20160223:b
  if (OB_SUCCESS == ret)
  {
    result_op->set_sql_context(sql_context_);
  }
  //add 20160223:e

  if (ret == OB_SUCCESS)
  {
    uint64_t stmt_id = OB_INVALID_ID;
    if (session_info->plan_exists(stmt->get_stmt_name(), &stmt_id) == false)
    {
      ret = OB_ERR_PREPARE_STMT_UNKNOWN;
      TRANS_LOG("Can not find stmt %.*s ", stmt->get_stmt_name().length(), stmt->get_stmt_name().ptr());
    }
    else
    {
      result_op->set_stmt_id(stmt_id);
    }
    for (int64_t i = 0; ret == OB_SUCCESS && i < stmt->get_variable_size(); i++)
    {
      const ObString& var_name = stmt->get_variable_name(i);
      if (session_info->variable_exists(var_name))
      {
        //add peiouya [NotNULL_check] [JHOBv0.1] 20131211:b
        bool val_params_constraint = true;
        if (OB_SUCCESS != (ret = result_->get_params_constraint(i, val_params_constraint)))
        {
          TRANS_LOG("Fail to get the constraint of  Variable %.*s!", var_name.length(), var_name.ptr());
        }
        else if (OB_SUCCESS != (ret = session_info->variable_constrain_check(val_params_constraint, var_name)))
        {
          TRANS_LOG("Value of Variable %.*s is NULL, but the bind column can not accept it !", var_name.length(), var_name.ptr());
        }
        else if(ret == OB_SUCCESS)
        {
          //add 20131222:e
          ObString tmp_name;
          if ((ret = ob_write_string(*mem_pool_, var_name, tmp_name)) != OB_SUCCESS
              || (ret = result_op->add_param_name(var_name)) != OB_SUCCESS)
          {
            TRANS_LOG("add variable %.*s failed", var_name.length(), var_name.ptr());
          }
        }
      }
      else
      {
        ret = OB_ERR_VARIABLE_UNKNOWN;
        TRANS_LOG("Variable %.*s Unknown", var_name.length(), var_name.ptr());
      }
    }
  }

  return ret;
}

int ObTransformer::gen_physical_deallocate(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObDeallocate *result_op = NULL;
  ObDeallocateStmt *stmt = NULL;
  /* get deallocate statement */
  get_stmt(logical_plan, err_stat, query_id, stmt);
  /* generate operator */
  if (ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(result_op, ObDeallocate, physical_plan, err_stat);
    if (ret == OB_SUCCESS)
    {
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, stmt, result_op, index);
    }
  }
  if (ret == OB_SUCCESS)
  {
    uint64_t stmt_id = OB_INVALID_ID;
    if (sql_context_== NULL || sql_context_->session_info_ == NULL)
    {
      ret = OB_NOT_INIT;
      TRANS_LOG("Session info is needed");
    }
    else if (sql_context_->session_info_->plan_exists(stmt->get_stmt_name(), &stmt_id) == false)
    {
      ret = OB_ERR_PREPARE_STMT_UNKNOWN;
      TRANS_LOG("Unknown prepared statement handler (%.*s) given to DEALLOCATE PREPARE",
                stmt->get_stmt_name().length(), stmt->get_stmt_name().ptr());
    }
    else
    {
      result_op->set_stmt_id(stmt_id);
    }
  }

  //add gaojt [Delete_Update_Function] [JHOBv0.1] 20160524:b
  if (OB_SUCCESS == ret)
  {
    YYSYS_LOG(DEBUG,"gaojt-test-ud: stmt-name=%.*s",stmt->get_stmt_name().length(),stmt->get_stmt_name().ptr());
    result_op->set_stmt_name(stmt->get_stmt_name());
  }
  //add gaojt 20160524:e

  return ret;
}

// add by liyongfeng:20150105 [secondary index for replace] like gen_phy_static_data_scan() used for insert,
// this is used for replace, only a little different from gen_phy_static_data_scan()
int ObTransformer::gen_phy_static_data_scan_for_replace(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const ObInsertStmt *insert_stmt,
    const ObRowDesc& row_desc,
    const ObSEArray<int64_t, 64> &row_desc_map,
    const uint64_t table_id,
    const ObRowkeyInfo &rowkey_info,
    ObTableRpcScan &table_scan)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  OB_ASSERT(logical_plan);
  OB_ASSERT(physical_plan);
  ObSqlExpression *rows_filter = ObSqlExpression::alloc();
  if (NULL == rows_filter)
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    YYSYS_LOG(WARN, "no memory");
  }
  ObSqlExpression column_ref;
  // construct left operand of IN operator
  // the same order with row_desc
  ExprItem expr_item;
  expr_item.type_ = T_REF_COLUMN;
  expr_item.value_.cell_.tid = table_id;
  int64_t rowkey_column_num = rowkey_info.get_size();
  uint64_t tid = OB_INVALID_ID;

  // begin: from here, is different from gen_phy_static_data_scan(),
  // differences: output columns not only include rowkey columns, but also include other columns
  for (int i = 0; OB_SUCCESS == ret && i < row_desc.get_column_num(); ++i)
  {
    if (OB_UNLIKELY(OB_SUCCESS != (ret = row_desc.get_tid_cid(i, tid, expr_item.value_.cell_.cid))))
    {
      break;
    }

    column_ref.reset();
    column_ref.set_tid_cid(table_id, expr_item.value_.cell_.cid);

    if (rowkey_info.is_rowkey_column(expr_item.value_.cell_.cid))//if rowkey column, add it into row_filter
    {
      if (OB_SUCCESS != (ret = rows_filter->add_expr_item(expr_item)))
      {
        YYSYS_LOG(WARN, "failed to add expr item, err=%d", ret);
        break;
      }
    }
    if (OB_SUCCESS != (ret = column_ref.add_expr_item(expr_item)))
    {
      YYSYS_LOG(WARN, "fialed to add expr item, err=%d", ret);
      break;
    }
    else if (OB_SUCCESS != (ret = column_ref.add_expr_item_end()))
    {
      YYSYS_LOG(WARN, "fialed to add expr item, err=%d", ret);
      break;
    }
    else if (OB_SUCCESS != (ret = table_scan.add_output_column(column_ref)))
    {
      YYSYS_LOG(WARN, "failed to add output column, err=%d", ret);
      break;
    }
  }// end for
  // end here

  // add action flag column
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    column_ref.reset();
    column_ref.set_tid_cid(OB_INVALID_ID, OB_ACTION_FLAG_COLUMN_ID);
    if (OB_SUCCESS != (ret = ObSqlExpressionUtil::make_column_expr(OB_INVALID_ID, OB_ACTION_FLAG_COLUMN_ID, column_ref)))
    {
      YYSYS_LOG(WARN, "fail to make column expr, err=%d", ret);
    }
    else if (OB_SUCCESS != (ret = table_scan.add_output_column(column_ref)))
    {
      YYSYS_LOG(WARN, "failed to add output column, err=%d", ret);
    }
  }
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    expr_item.type_ = T_OP_ROW;
    expr_item.value_.int_ = rowkey_column_num;
    if (OB_SUCCESS != (ret = rows_filter->add_expr_item(expr_item)))
    {
      TRANS_LOG("failed to add expr item, err=%d", ret);
    }
  }
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    expr_item.type_ = T_OP_LEFT_PARAM_END;
    // a in (a,b,c) => 1 Dim;
    expr_item.value_.int_ = 2;
    if (OB_SUCCESS != (ret = rows_filter->add_expr_item(expr_item)))
    {
      YYSYS_LOG(WARN, "failed to add expr item, err=%d", ret);
    }
  }

  uint64_t column_id = OB_INVALID_ID;
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    int64_t row_num = insert_stmt->get_value_row_size();
    //        for (int64_t i = 0; OB_SUCCESS == ret && i < row_num; i++)
    for(int64_t i = row_num - 1; OB_SUCCESS == ret && i>= 0; i--)//modify hushuang 20161103
    {
      const ObArray<uint64_t>& value_row = insert_stmt->get_value_row(i);
      OB_ASSERT(value_row.count() == row_desc_map.count());
      for (int64_t j = 0; OB_SUCCESS == ret && j < row_desc_map.count(); j++)
      {
        ObSqlRawExpr *value_expr = logical_plan->get_expr(value_row.at(row_desc_map.at(j)));
        if (NULL == value_expr)
        {
          ret = OB_ERR_ILLEGAL_ID;
          TRANS_LOG("failed to get value");
        }
        else if (OB_SUCCESS != (ret = row_desc.get_tid_cid(j, tid, column_id)))
        {
          TRANS_LOG("failed to get tid cid, err=%d", ret);
        }
        // success
        else if (rowkey_info.is_rowkey_column(column_id))
        {
          // add rigth oprands of the IN operator
          if (OB_SUCCESS != (ret = value_expr->get_expr()->fill_sql_expression(*rows_filter, this, logical_plan, physical_plan)))
          {
            TRANS_LOG("failed to fill expr, err=%d", ret);
          }
          // add wnghaixing [decimal] for fix delete bug 2014/10/11
          else
          {
            ObObjType cond_val_type;
            uint32_t cond_val_precision;
            uint32_t cond_val_scale;

            // ObObj static_obj
            if (OB_SUCCESS != sql_context_->schema_manager_->get_cond_val_info(tid, column_id, cond_val_type, cond_val_precision, cond_val_scale))
            {
              //YYSYS_LOG(WARN, "Failed to get cond val info");
            }
            //mod liumz, [decimal] for fix delete bug 20160722:b
            //else
            else if(ObDecimalType == cond_val_type)
              //mod:e
            {
              ObPostfixExpression& ops = rows_filter->get_decoded_expression_v2();
              ObObj& obj = ops.get_expr();
              if (ObDecimalType == obj.get_type())
              {
                ops.fix_varchar_and_decimal(cond_val_precision, cond_val_scale);
              }
              else if (ObVarcharType == obj.get_type())
              {
                ops.fix_varchar_and_decimal(cond_val_precision, cond_val_scale);
              }
            }
          }
          // add:e
        }
      }// end for
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        if (rowkey_column_num > 0)
        {
          expr_item.type_ = T_OP_ROW;
          expr_item.value_.int_ = rowkey_column_num;
          if (OB_SUCCESS != (ret = rows_filter->add_expr_item(expr_item)))
          {
            TRANS_LOG("failed to add expr item, err=%d", ret);
          }
        }
      }
    }// end for

    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      expr_item.type_ = T_OP_ROW;
      expr_item.value_.int_ = row_num;
      ExprItem expr_in;
      expr_in.type_ = T_OP_IN;
      expr_in.value_.int_ = 2;
      if (OB_SUCCESS != (ret = rows_filter->add_expr_item(expr_item)))
      {
        TRANS_LOG("failed to add expr item, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = rows_filter->add_expr_item(expr_in)))
      {
        TRANS_LOG("failed to add expr item, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = rows_filter->add_expr_item_end()))
      {
        TRANS_LOG("failed to add expr item, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = table_scan.add_filter(rows_filter)))
      {
        TRANS_LOG("failed to add filter, err=%d", ret);
      }
    }
  }

  return ret;
}
// add:e

int ObTransformer::gen_phy_static_data_scan(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    //mod lijianqiang [seqeunce] 20150515 :b
    //    const ObInsertStmt * insert_stmt,
    ObStmt *stmt,
    //mod 20150515:e
    const ObRowDesc& row_desc,
    const ObSEArray<int64_t, 64> &row_desc_map,
    const uint64_t table_id,
    const ObRowkeyInfo &rowkey_info,
    ObTableRpcScan &table_scan)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  OB_ASSERT(logical_plan);
  //mod lijianqiang [sequence] 20150515:b
  //  OB_ASSERT(insert_stmt);
  OB_ASSERT(stmt);
  //mod 20150515:e
  //add lijianqiang [sequence insert] 20150419:b
  ObSequenceStmt *sequence_stmt = NULL;
  ObInsertStmt * insert_stmt = NULL;
  bool has_sequence = false;

  if (stmt->get_stmt_type() == ObBasicStmt::T_INSERT
      || stmt->get_stmt_type() == ObBasicStmt::T_DELETE
      || stmt->get_stmt_type() == ObBasicStmt::T_UPDATE
      || stmt->get_stmt_type() == ObBasicStmt::T_SELECT)
  {
    sequence_stmt = dynamic_cast<ObSequenceStmt*>(stmt);
    has_sequence = sequence_stmt->has_sequence();
  }
  if (!has_sequence)
  {
    insert_stmt = dynamic_cast<ObInsertStmt*>(stmt);
  }
  //add 20150419:e
  ObSqlExpression *rows_filter = ObSqlExpression::alloc();
  if (NULL == rows_filter)
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    YYSYS_LOG(WARN, "no memory");
  }
  ObSqlExpression column_ref;
  // construct left operand of IN operator
  // the same order with row_desc
  ExprItem expr_item;
  expr_item.type_ = T_REF_COLUMN;
  expr_item.value_.cell_.tid = table_id;
  int64_t rowkey_column_num = rowkey_info.get_size();
  uint64_t tid = OB_INVALID_ID;
  for (int i = 0; OB_SUCCESS == ret && i < row_desc.get_column_num(); ++i)
  {
    if (OB_UNLIKELY(OB_SUCCESS != (ret = row_desc.get_tid_cid(i, tid, expr_item.value_.cell_.cid))))
    {
      break;
    }
    else if (rowkey_info.is_rowkey_column(expr_item.value_.cell_.cid))
    {
      column_ref.reset();
      column_ref.set_tid_cid(table_id, expr_item.value_.cell_.cid);
      if (OB_SUCCESS != (ret = rows_filter->add_expr_item(expr_item)))
      {
        YYSYS_LOG(WARN, "failed to add expr item, err=%d", ret);
        break;
      }
      else if (OB_SUCCESS != (ret = column_ref.add_expr_item(expr_item)))
      {
        YYSYS_LOG(WARN, "failed to add expr_item, err=%d", ret);
        break;
      }
      else if (OB_SUCCESS != (ret = column_ref.add_expr_item_end()))
      {
        YYSYS_LOG(WARN, "failed to add expr item, err=%d", ret);
        break;
      }
      else if (OB_SUCCESS != (ret = table_scan.add_output_column(column_ref)))
      {
        YYSYS_LOG(WARN, "failed to add output column, err=%d", ret);
        break;
      }
    }
  } // end for
  // add action flag column
  //mod lijianqiang [sequence insert] 20150419:b
  //  if (OB_LIKELY(OB_SUCCESS == ret))
  if (OB_LIKELY(OB_SUCCESS == ret && !has_sequence))
    //mod 20150419:e
  {
    column_ref.reset();
    column_ref.set_tid_cid(OB_INVALID_ID, OB_ACTION_FLAG_COLUMN_ID);
    if (OB_SUCCESS != (ret = ObSqlExpressionUtil::make_column_expr(OB_INVALID_ID, OB_ACTION_FLAG_COLUMN_ID, column_ref)))
    {
      YYSYS_LOG(WARN, "fail to make column expr:ret[%d]", ret);
    }
    else if (OB_SUCCESS != (ret = table_scan.add_output_column(column_ref)))
    {
      YYSYS_LOG(WARN, "failed to add output column, err=%d", ret);
    }
  }
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    expr_item.type_ = T_OP_ROW;
    expr_item.value_.int_ = rowkey_column_num;
    if (OB_SUCCESS != (ret = rows_filter->add_expr_item(expr_item)))
    {
      TRANS_LOG("Failed to add expr item, err=%d", ret);
    }
  }
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    expr_item.type_ = T_OP_LEFT_PARAM_END;
    // a in (a,b,c) => 1 Dim;  (a,b) in ((a,b),(c,d)) =>2 Dim; ((a,b),(c,d)) in (...) =>3 Dim
    expr_item.value_.int_ = 2;
    if (OB_SUCCESS != (ret = rows_filter->add_expr_item(expr_item)))
    {
      YYSYS_LOG(WARN, "failed to add expr item, err=%d", ret);
    }
  }
  uint64_t column_id = OB_INVALID_ID;
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    //mod lijianqiang [sequecne insert] 20140410:b
    int64_t row_num = OB_INVALID_INDEX;
    if (!has_sequence)
    {
      row_num = insert_stmt->get_value_row_size();
      for (int64_t i = 0; ret == OB_SUCCESS && i < row_num; i++) // for each row
      {
        const ObArray<uint64_t>& value_row = insert_stmt->get_value_row(i);
        OB_ASSERT(value_row.count() == row_desc_map.count());
        for (int64_t j = 0; ret == OB_SUCCESS && j < row_desc_map.count(); j++)
        {
          ObSqlRawExpr *value_expr = logical_plan->get_expr(value_row.at(row_desc_map.at(j)));
          if (value_expr == NULL)
          {
            ret = OB_ERR_ILLEGAL_ID;
            TRANS_LOG("Get value failed");
          }
          else if (OB_SUCCESS != (ret = row_desc.get_tid_cid(j, tid, column_id)))
          {
            TRANS_LOG("Failed to get tid cid, err=%d", ret);
          }
          // success
          else if (rowkey_info.is_rowkey_column(column_id))
          {
            // add right oprands of the IN operator
            if (OB_SUCCESS != (ret = value_expr->get_expr()->fill_sql_expression(*rows_filter, this, logical_plan, physical_plan)))
            {
              TRANS_LOG("Failed to fill expr, err=%d", ret);
            }
            //add wenghaixing[decimal] for fix insert bug 2014/10/11
            else
            {
              ObObjType cond_val_type;
              uint32_t cond_val_precision;
              uint32_t cond_val_scale;

              //ObObj static_obj;
              if(OB_SUCCESS!=sql_context_->schema_manager_->get_cond_val_info(tid,column_id,cond_val_type,cond_val_precision,cond_val_scale))
              {
                YYSYS_LOG(WARN, "Failed to get cond val info");
              }
              else if(ObDecimalType == cond_val_type)
              {
                ObPostfixExpression& ops=rows_filter->get_decoded_expression_v2();
                ObObj& obj=ops.get_expr();
                if(ObDecimalType==obj.get_type())
                {
                  ops.fix_varchar_and_decimal(cond_val_precision,cond_val_scale);
                }
                else if(ObVarcharType==obj.get_type())
                {
                  ops.fix_varchar_and_decimal(cond_val_precision,cond_val_scale);
                }

              }

            }
            //add:e
          }
        } // end for
        if (OB_LIKELY(ret == OB_SUCCESS))
        {
          if (rowkey_column_num > 0)
          {
            expr_item.type_ = T_OP_ROW;
            expr_item.value_.int_ = rowkey_column_num;
            if (OB_SUCCESS != (ret = rows_filter->add_expr_item(expr_item)))
            {
              TRANS_LOG("Failed to add expr item, err=%d", ret);
            }
          }
        }
      } // end for
    }//end of  if (!has_sequen...
    else//has_sequence
    {
      ObArray<ObString> *sequence_names_array = NULL;
      row_num = sequence_stmt->get_sequence_names_no_dup_size();
      sequence_names_array = &(sequence_stmt->get_sequence_names_no_dup());
      for (int64_t i = 0; ret == OB_SUCCESS && i < row_num; i++) // for each sequence
      {
        ObObj val;
        const ObString& sequence_name = sequence_names_array->at(i);
        val.set_varchar(sequence_name);
        ObConstRawExpr c_expr;
        c_expr.set_expr_type(T_STRING);
        c_expr.set_result_type(ObVarcharType);
        c_expr.set_value(val);
        //        YYSYS_LOG(ERROR, "the sequence_name_is::[%.*s]",sequence_name.length(),sequence_name.ptr());
        if (OB_SUCCESS != (ret = row_desc.get_tid_cid(0, tid, column_id)))
        {
          TRANS_LOG("Failed to get sequence tid cid, err=%d", ret);
        }
        if (rowkey_info.is_rowkey_column(column_id))
        {
          //          YYSYS_LOG(ERROR, "!!!the column_id num is::%ld,table id is::%ld",column_id,tid);
          if ((ret = c_expr.fill_sql_expression(*rows_filter, this, logical_plan, physical_plan)) != OB_SUCCESS)
          {
            TRANS_LOG("Failed to fill sequence expr, err=%d", ret);
          }
        }

        if (OB_LIKELY(ret == OB_SUCCESS))
        {
          if (rowkey_column_num > 0)
          {
            expr_item.type_ = T_OP_ROW;
            expr_item.value_.int_ = rowkey_column_num;
            //            YYSYS_LOG(ERROR, "!!!the rowkey_column_num  is::%ld",rowkey_column_num);
            if (OB_SUCCESS != (ret = rows_filter->add_expr_item(expr_item)))
            {
              TRANS_LOG("Failed to add expr item, err=%d", ret);
            }
          }
        }
      }//end for

      //add output columns
      ExprItem expr_item;
      expr_item.type_ = T_REF_COLUMN;
      expr_item.value_.cell_.tid = table_id;
      //      int64_t rowkey_column_num = rowkey_info.get_size();
      uint64_t tid = OB_INVALID_ID;
      for (int i = 0; OB_SUCCESS == ret && i < row_desc.get_column_num(); i++)
      {
        if (OB_UNLIKELY(OB_SUCCESS != (ret = row_desc.get_tid_cid(i, tid, expr_item.value_.cell_.cid))))
        {
          break;
        }
        else if (!rowkey_info.is_rowkey_column(expr_item.value_.cell_.cid))
        {
          column_ref.reset();
          column_ref.set_tid_cid(tid, expr_item.value_.cell_.cid);
          if (OB_SUCCESS != (ret = column_ref.add_expr_item(expr_item)))
          {
            YYSYS_LOG(WARN, "failed to add expr_item, err=%d", ret);
            break;
          }
          else if (OB_SUCCESS != (ret = column_ref.add_expr_item_end()))
          {
            YYSYS_LOG(WARN, "failed to add expr item, err=%d", ret);
            break;
          }
          else if (OB_SUCCESS != (ret = table_scan.add_output_column(column_ref)))
          {
            YYSYS_LOG(WARN, "failed to add output column, err=%d", ret);
            break;
          }
          //          YYSYS_LOG(ERROR, "the output column is::[%s]",to_cstring(column_ref));
        }
      }//end for
    }// end else
    //mod 2050410:e

    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      expr_item.type_ = T_OP_ROW;
      expr_item.value_.int_ = row_num;
      ExprItem expr_in;
      expr_in.type_ = T_OP_IN;
      expr_in.value_.int_ = 2;
      if (OB_SUCCESS != (ret = rows_filter->add_expr_item(expr_item)))
      {
        TRANS_LOG("Failed to add expr item, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = rows_filter->add_expr_item(expr_in)))
      {
        TRANS_LOG("Failed to add expr item, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = rows_filter->add_expr_item_end()))
      {
        TRANS_LOG("Failed to add expr item end, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = table_scan.add_filter(rows_filter)))
      {
        TRANS_LOG("Failed to add filter, err=%d", ret);
      }
    }
  }
  return ret;
}

int ObTransformer::wrap_ups_executor(
    ObPhysicalPlan *physical_plan,
    const uint64_t query_id,
    ObPhysicalPlan*& new_plan,
    int32_t *index,
    ErrStat& err_stat, bool need_loop)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  OB_ASSERT(physical_plan);
  if (query_id == OB_INVALID_ID || !physical_plan->in_ups_executor())
  {
    ObUpsExecutor *ups_executor = NULL;
    new_plan = (ObPhysicalPlan*)trans_malloc(sizeof(ObPhysicalPlan));
    if (NULL == new_plan)
    {
      TRANS_LOG("no memory");
      ret = OB_ALLOCATE_MEMORY_FAILED;
    }
    else
    {
      new_plan = new(new_plan) ObPhysicalPlan();
      YYSYS_LOG(DEBUG, "new wrapper physical plan, addr=%p", physical_plan);
      //add gaojt [Insert_Subquery_Function] [JHOBv0.1] 20150507:b
      if(need_loop)
      {
        ObIudLoopControl *insert_loop_control = NULL;
        if (NULL == CREATE_PHY_OPERRATOR(insert_loop_control, ObIudLoopControl, physical_plan, err_stat))
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
        }
        else if(NULL == CREATE_PHY_OPERRATOR(ups_executor, ObUpsExecutor, physical_plan, err_stat))
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
        }
        else if (OB_SUCCESS != (ret = insert_loop_control->set_child(0,*(ups_executor))))
        {
          TRANS_LOG("failed to set child, err=%d", ret);
        }
        else if (OB_SUCCESS != (ret = physical_plan->add_phy_query(
                                  insert_loop_control,
                                  index,
                                  query_id == OB_INVALID_ID)))
        {
          YYSYS_LOG(WARN, "failed to add query, err=%d", ret);
        }
        else if (NULL == sql_context_->merge_service_)
        {
          ret = OB_NOT_INIT;
          YYSYS_LOG(WARN, "merge_service_ is null");
        }
        else
        {
          new_plan->set_in_ups_executor(true);
          ups_executor->set_rpc_stub(sql_context_->merger_rpc_proxy_);
          ups_executor->set_inner_plan(new_plan);
          ups_executor->set_sql_context(sql_context_);
          physical_plan->set_ups_executor_op_id(ups_executor->get_id());
        }
        if(OB_SUCCESS==ret)
        {
          insert_loop_control->set_sql_context (*sql_context_);
          if(is_multi_batch_)
          {
            insert_loop_control->set_need_start_trans (false);
            YYSYS_LOG(DEBUG,"is the multi-insert");
          }
          else
          {
            insert_loop_control->set_need_start_trans (true);
          }
        }
        else
        {
          new_plan->~ObPhysicalPlan();
        }
      }
      //add gaojt 20150507:e
      else
      {
        if (NULL == CREATE_PHY_OPERRATOR(ups_executor, ObUpsExecutor, physical_plan, err_stat))
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
        }
        else if (OB_SUCCESS != (ret = physical_plan->add_phy_query(
                                  ups_executor,
                                  index,
                                  query_id == OB_INVALID_ID)))
        {
          YYSYS_LOG(WARN, "failed to add query, err=%d", ret);
        }
        else if (NULL == sql_context_->merge_service_)
        {
          ret = OB_NOT_INIT;
          YYSYS_LOG(WARN, "merge_service_ is null");
        }
        else
        {
          new_plan->set_in_ups_executor(true);
          ups_executor->set_rpc_stub(sql_context_->merger_rpc_proxy_);
          ups_executor->set_inner_plan(new_plan);
          //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20151123:b
          ups_executor->set_sql_context(sql_context_);
          physical_plan->set_ups_executor_op_id(ups_executor->get_id());
        }
        if (OB_SUCCESS != ret)
        {
          new_plan->~ObPhysicalPlan();
        }
      }
    }
  }
  else
  {
    new_plan = physical_plan;
  }
  return ret;
}

int ObTransformer::gen_physical_insert_new(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObInsertStmt *insert_stmt = NULL;
  ObUpsModifyWithDmlType *ups_modify = NULL;
  ObRowDesc row_desc;
  ObRowDescExt row_desc_ext;
  ObSEArray<int64_t, 64> row_desc_map;
  const ObRowkeyInfo *rowkey_info = NULL;
  ObPhysicalPlan* inner_plan = NULL;
  //add fanqiushi_index
  bool is_need_modify_index=false;
  int64_t index_num = 0;
  //add:e
  bool is_insert_select = false;
  if (OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, insert_stmt)))
  {

  }
  else if(insert_stmt->get_insert_query_id() != OB_INVALID_ID)
  {
    is_insert_select = true; //insert ... select ...
  }

  if(OB_SUCCESS == ret)
  {
    //add gaojt [Insert_Subquery_Function] [JHOBv0.1] 20150507:b
    if(insert_stmt->get_is_insert_multi_batch())
    {
      is_multi_batch_ = true;
    }
    //add gaojt 20150507:e

    if (OB_SUCCESS != (ret = wrap_ups_executor(physical_plan, query_id, inner_plan, index, err_stat,is_insert_select)))
    {
      YYSYS_LOG(WARN, "err=%d", ret);
    }
    // modified end
    else if (NULL == CREATE_PHY_OPERRATOR(ups_modify, ObUpsModifyWithDmlType, inner_plan, err_stat))
    {
      ret = OB_ALLOCATE_MEMORY_FAILED;
    }
    else if (OB_SUCCESS != (ret = inner_plan->add_phy_query(
                              ups_modify,
                              physical_plan == inner_plan ? index : NULL,
                              physical_plan != inner_plan)))
    {
      TRANS_LOG("Failed to add main phy query, err=%d", ret);
    }
    else if (OB_SUCCESS != (ret = cons_row_desc(insert_stmt->get_table_id(), insert_stmt,
                                                row_desc_ext, row_desc, rowkey_info, row_desc_map, err_stat)))
    {
      ret = OB_ERROR;
      TRANS_LOG("Fail to get table schema for table[%ld]", insert_stmt->get_table_id());
    }
    else
    {
      ups_modify->set_dml_type(OB_DML_INSERT);
      // check primary key columns
      uint64_t tid = insert_stmt->get_table_id();
      uint64_t cid = OB_INVALID_ID;
      for (int64_t i = 0; i < rowkey_info->get_size(); ++i)
      {
        if (OB_SUCCESS != (ret = rowkey_info->get_column_id(i, cid)))
        {
          YYSYS_LOG(USER_ERROR, "primary key can not be empty");
          ret = OB_ERR_INSERT_NULL_ROWKEY;
          break;
        }
        else if (OB_INVALID_INDEX == row_desc.get_idx(tid, cid))
        {
          YYSYS_LOG(USER_ERROR, "primary key can not be empty");
          ret = OB_ERR_INSERT_NULL_ROWKEY;
          break;
        }
      } // end for
      //add peiouya [NotNULL_check] [JHOBv0.1] 20131222:b
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        ret = column_null_check(logical_plan, insert_stmt, err_stat, OP_INSERT);
      }
      //add 20131222:e
    }
  }
  //mod gaojt 20150505:e

  //add fanqiushi_index
  if (OB_LIKELY(ret == OB_SUCCESS))
  {
    uint64_t main_tid=insert_stmt->get_table_id();
    if (sql_context_->schema_manager_->is_have_modifiable_index(main_tid))
    {
      is_need_modify_index=true;
    }
  }
  //add:e
  if (OB_LIKELY(ret == OB_SUCCESS))
  {
    if (OB_LIKELY(insert_stmt->get_insert_query_id() == OB_INVALID_ID))
    {
      // INSERT ... VALUES ...
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        uint64_t tid = insert_stmt->get_table_id();
        const ObTableSchema *table_schema = NULL;
        if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(tid)))
        {
          ret = OB_ERR_ILLEGAL_ID;
          TRANS_LOG("fail to get table schema for table[%ld]", tid);
        }
        else if (row_desc.get_idx(tid, table_schema->get_create_time_column_id()) != OB_INVALID_INDEX)
        {
          ret = OB_ERR_CREAT_MODIFY_TIME_COLUMN;
          ColumnItem *column_item = insert_stmt->get_column_item_by_id(tid, table_schema->get_create_time_column_id());
          if (column_item != NULL)
            TRANS_LOG("Column '%.*s' of type ObCreateTimeType can not be inserted",
                      column_item->column_name_.length(), column_item->column_name_.ptr());
          else
            TRANS_LOG("Column '%ld' of type ObCreateTimeType can not be inserted",
                      table_schema->get_create_time_column_id());
        }
        else if (row_desc.get_idx(tid, table_schema->get_modify_time_column_id()) != OB_INVALID_INDEX)
        {
          ret = OB_ERR_CREAT_MODIFY_TIME_COLUMN;
          ColumnItem *column_item = insert_stmt->get_column_item_by_id(tid, table_schema->get_modify_time_column_id());
          if (column_item != NULL)
            TRANS_LOG("Column '%.*s' of type ObModifyTimeType can not be inserted",
                      column_item->column_name_.length(), column_item->column_name_.ptr());
          else
            TRANS_LOG("Column '%ld' of type ObModifyTimeType can not be inserted",
                      table_schema->get_modify_time_column_id());
        }
      }
      if (OB_SUCCESS == ret)
      {
        //==================================================================
        //add lijianqiang [sequence insert] 20150407
        //ObSequenceInsert
        bool has_sequence = insert_stmt->has_sequence();
        ObSequenceInsert *sequence_values = NULL;
        if (has_sequence)
        {
          if (OB_LIKELY(OB_SUCCESS == ret))
          {
            CREATE_PHY_OPERRATOR(sequence_values, ObSequenceInsert, inner_plan, err_stat);
            if (OB_SUCCESS == ret)//add qianzm [null operator unjudgement bug1181] 20160520
            {
              if (OB_SUCCESS != (ret = wrap_sequence(logical_plan, physical_plan, err_stat,
                                                     row_desc_map, sequence_values, insert_stmt,
                                                     inner_plan)))
              {
                TRANS_LOG("wrap sequence failed");
              }
              if (OB_LIKELY(OB_SUCCESS == ret))
              {
                sequence_values->init_global_prevval_state_and_lock_sequence_map();
                sequence_values->copy_sequence_info_from_insert_stmt(row_desc_map);//copy sequence info from insert stmt
                sequence_values->set_out_row_desc_and_row_desc_ext(row_desc, row_desc_ext);//for column with sequence obj_cast check
              }
            }
          }
          if (OB_LIKELY(OB_SUCCESS == ret))
          {
            if (OB_SUCCESS != (ret = inner_plan->add_phy_query(sequence_values)))
            {
              YYSYS_LOG(WARN, "failed to add phy query, err=%d", ret);
            }
          }
        }//end if(has_sequence)
        //==================================================================
        //add 20150407:e

        ObTableRpcScan *table_scan = NULL;
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          ObRpcScanHint hint;
          hint.read_method_ = ObSqlReadStrategy::USE_GET;
          hint.is_get_skip_empty_row_ = false;
          hint.read_consistency_ = FROZEN;
          const ObTableSchema *table_schema = NULL;
          int64_t table_id = insert_stmt->get_table_id();
          CREATE_PHY_OPERRATOR(table_scan, ObTableRpcScan, inner_plan, err_stat);
          if (OB_UNLIKELY(OB_SUCCESS != ret))
          {
          }
          else if (OB_SUCCESS != (ret = table_scan->set_table(table_id, table_id)))
          {
            TRANS_LOG("failed to set table id, err=%d", ret);
          }
          else if (OB_SUCCESS != (ret = table_scan->init(sql_context_, &hint)))
          {
            TRANS_LOG("failed to init table scan, err=%d", ret);
          }
          //del lijianqiang [sequence insert] 20150407 :b
          //          else if (OB_SUCCESS != (ret = gen_phy_static_data_scan(logical_plan, inner_plan, err_stat,
          //                                                                 insert_stmt, row_desc, row_desc_map,
          //                                                                 table_id, *rowkey_info, *table_scan)))
          //          {
          //            TRANS_LOG("err=%d", ret);
          //          }
          //del 20150407:e
          else if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_id)))
          {
            ret = OB_ERR_ILLEGAL_ID;
            TRANS_LOG("Fail to get table schema for table[%ld]", table_id);
          }
          else if ((ret = physical_plan->add_base_table_version(
                      table_id,
                      table_schema->get_schema_version()
                      )) != OB_SUCCESS)
          {
            TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d", table_id, ret);
          }
          else
          {
            table_scan->set_rowkey_cell_count(row_desc.get_rowkey_cell_count());
            table_scan->set_cache_bloom_filter(true);
            //add lijianqiang [sequence insert] 20150407 :b
            if (!has_sequence)//if has sequence, this function is finished in sequence op
            {
              if (OB_SUCCESS != (ret = gen_phy_static_data_scan(logical_plan, inner_plan, err_stat,
                                                                insert_stmt, row_desc, row_desc_map,
                                                                table_id, *rowkey_info, *table_scan)))
              {
                TRANS_LOG("err=%d", ret);
              }
            }
            //add 20150407:e
          }
        }
        ObValues *tmp_table = NULL;
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          CREATE_PHY_OPERRATOR(tmp_table, ObValues, inner_plan, err_stat);
          if (OB_UNLIKELY(OB_SUCCESS != ret))
          {
          }
          else if (OB_SUCCESS != (ret = tmp_table->set_child(0, *table_scan)))
          {
            YYSYS_LOG(WARN, "failed to set child, err=%d", ret);
          }
          else if (OB_SUCCESS != (ret = inner_plan->add_phy_query(tmp_table)))
          {
            YYSYS_LOG(WARN, "failed to add phy query, err=%d", ret);
          }
          //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20151124:b
          else
          {
            inner_plan->set_values_op_id(tmp_table->get_id());
          }
          //add 20151124:e
        }
        ObMemSSTableScan *static_data = NULL;
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          CREATE_PHY_OPERRATOR(static_data, ObMemSSTableScan, inner_plan, err_stat);
          if (OB_LIKELY(OB_SUCCESS == ret))
          {
            static_data->set_tmp_table(tmp_table->get_id());
          }
        }
        ObIncScan *inc_scan = NULL;
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          CREATE_PHY_OPERRATOR(inc_scan, ObIncScan, inner_plan, err_stat);
          if (OB_LIKELY(OB_SUCCESS == ret))
          {
            inc_scan->set_scan_type(ObIncScan::ST_MGET);
            inc_scan->set_write_lock_flag();
          }
        }
        ObMultipleGetMerge *fuse_op = NULL;
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          CREATE_PHY_OPERRATOR(fuse_op, ObMultipleGetMerge, inner_plan, err_stat);
          if (OB_UNLIKELY(OB_SUCCESS != ret))
          {
          }
          else if ((ret = fuse_op->set_child(0, *static_data)) != OB_SUCCESS)
          {
            TRANS_LOG("Set child of fuse_op operator failed, err=%d", ret);
          }
          else if ((ret = fuse_op->set_child(1, *inc_scan)) != OB_SUCCESS)
          {
            TRANS_LOG("Set child of fuse_op operator failed, err=%d", ret);
          }
          else
          {
            fuse_op->set_is_ups_row(false);
          }
        }
        ObExprValues *input_values = NULL;
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          CREATE_PHY_OPERRATOR(input_values, ObExprValues, inner_plan, err_stat);
          if (OB_UNLIKELY(OB_SUCCESS != ret))
          {
          }
          else if (OB_SUCCESS != (ret = inner_plan->add_phy_query(input_values)))
          {
            YYSYS_LOG(WARN, "failed to add phy query, err=%d", ret);
          }
          else if ((ret = input_values->set_row_desc(row_desc, row_desc_ext)) != OB_SUCCESS)
          {
            TRANS_LOG("Set descriptor of value operator failed, err=%d", ret);
          }
          else if (OB_SUCCESS != (ret = gen_phy_values(logical_plan, inner_plan, err_stat, insert_stmt,
                                                       row_desc, row_desc_ext, &row_desc_map, *input_values)))
          {
            TRANS_LOG("Failed to generate values, err=%d", ret);
          }
          else
          {
            //add shili [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20150721:b
            //����table_id  stmt_type �������ƻ�ִ�е�ʱ��ʹ��
            inner_plan->set_table_id(insert_stmt->get_table_id());
            inner_plan->set_stmt_type(ObBasicStmt::T_INSERT);
            //add 20150721:e
            //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20151124:b
            inner_plan->set_expr_values_op_id(input_values->get_id());
            //add 20151124:e
            input_values->set_check_rowkey_duplicate(true);
          }
        }
        //add lijianqiang [sequence insert] 20150407:b
        /*Exp:if has sequence,set child after input values and tmp_table created*/
        if (has_sequence && OB_SUCCESS == ret)
        {
          if (OB_SUCCESS != (ret = sequence_values->set_child(1, *input_values)))
          {
            YYSYS_LOG(WARN, "failed to set child input_values, err=%d", ret);
          }
          else if (OB_SUCCESS != (ret = sequence_values->set_child(2, *tmp_table)))
          {
            YYSYS_LOG(WARN, "failed to set child tmp_table, err=%d", ret);
          }
        }
        //add 20150407:e
        ObEmptyRowFilter * empty_row_filter = NULL;
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          CREATE_PHY_OPERRATOR(empty_row_filter, ObEmptyRowFilter, inner_plan, err_stat);
          if (OB_UNLIKELY(OB_SUCCESS != ret))
          {
          }
          else if ((ret = empty_row_filter->set_child(0, *fuse_op)) != OB_SUCCESS)
          {
            TRANS_LOG("Failed to set child");
          }
        }
        ObInsertDBSemFilter *insert_sem = NULL;
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          CREATE_PHY_OPERRATOR(insert_sem, ObInsertDBSemFilter, inner_plan, err_stat);
          if (OB_UNLIKELY(OB_SUCCESS != ret))
          {
          }
          else if ((ret = insert_sem->set_child(0, *empty_row_filter)) != OB_SUCCESS)
          {
            TRANS_LOG("Failed to set child, err=%d", ret);
          }
          else
          {
            inc_scan->set_values(input_values->get_id(), true);
            insert_sem->set_input_values(input_values->get_id());
          }
        }
        //add fanqiushi_index
        ObIndexTrigger *index_trigger = NULL;
        if(OB_LIKELY(OB_SUCCESS == ret)&&is_need_modify_index)
        {
          CREATE_PHY_OPERRATOR(index_trigger, ObIndexTrigger, inner_plan, err_stat);
          if (OB_UNLIKELY(OB_SUCCESS != ret))
          {
          }
          else if ((ret = index_trigger->set_child(0, *insert_sem)) != OB_SUCCESS)
          {
            TRANS_LOG("Failed to set child, err=%d", ret);
          }
          else if(OB_SUCCESS != (ret = sql_context_->schema_manager_->get_all_modifiable_index_num(insert_stmt->get_table_id(), index_num)))
          {

          }
          else
          {
            //inc_scan->set_values(input_values->get_id(), true);
            //insert_sem->set_input_values(input_values->get_id());
            index_trigger->set_i64_values(insert_stmt->get_table_id(),index_num,0);
          }
        }
        //add:e
        //ObWhenFilter *when_filter_op = NULL;
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          if (insert_stmt->get_when_expr_size() > 0)  //fanqiushi_index:insert with when_expr is not considered yet
          {
            //mod shili, [MultiUPS] [merge transaction code]20170323
            //if ((ret = gen_phy_when(logical_plan,
            //                        inner_plan,
            //                        err_stat,
            //                        query_id,
            //                        *insert_sem,
            //                        when_filter_op
            //                        )) != OB_SUCCESS)
            //{
            //}
            //else if ((ret = ups_modify->set_child(0, *when_filter_op)) != OB_SUCCESS)
            //{
            //    TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
            //}
            ret = OB_NOT_SUPPORTED;
            YYSYS_LOG(USER_ERROR,"insert not supple when subquery,ret=%d",ret);
          }
          //modify by fanqiushi_index
          else
          {
            if(is_need_modify_index)
            {
              if (OB_SUCCESS != (ret = ups_modify->set_child(0, *index_trigger)))
              {
                TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
              }
            }
            else
            {
              if (OB_SUCCESS != (ret = ups_modify->set_child(0, *insert_sem)))
              {
                TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
              }
            }
          }
          //modify :e
        }
      }
    }
    else
    {
      // @todo insert ... select ...
      //add gaojt [Insert_Subquery_Function] [JHOBv0.1] 20141028:b
      /*Exp:do some prepare work*/
      uint64_t tid = insert_stmt->get_table_id();
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        const ObTableSchema *table_schema = NULL;
        if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(tid)))
        {
          ret = OB_ERR_ILLEGAL_ID;
          TRANS_LOG("fail to get table schema for table[%ld]", tid);
        }
        else if (row_desc.get_idx(tid, table_schema->get_create_time_column_id()) != OB_INVALID_INDEX)
        {
          ret = OB_ERR_CREAT_MODIFY_TIME_COLUMN;
          ColumnItem *column_item = insert_stmt->get_column_item_by_id(tid, table_schema->get_create_time_column_id());
          if (column_item != NULL)
            TRANS_LOG("Column '%.*s' of type ObCreateTimeType can not be inserted",
                      column_item->column_name_.length(), column_item->column_name_.ptr());
          else
            TRANS_LOG("Column '%ld' of type ObCreateTimeType can not be inserted",
                      table_schema->get_create_time_column_id());
        }
        else if (row_desc.get_idx(tid, table_schema->get_modify_time_column_id()) != OB_INVALID_INDEX)
        {
          ret = OB_ERR_CREAT_MODIFY_TIME_COLUMN;
          ColumnItem *column_item = insert_stmt->get_column_item_by_id(tid, table_schema->get_modify_time_column_id());
          if (column_item != NULL)
            TRANS_LOG("Column '%.*s' of type ObModifyTimeType can not be inserted",
                      column_item->column_name_.length(), column_item->column_name_.ptr());
          else
            TRANS_LOG("Column '%ld' of type ObModifyTimeType can not be inserted",
                      table_schema->get_modify_time_column_id());
        }
      }
      //add 20141028:e

      //add gaojt [Insert_Subquery_Function] [JHOBv0.1] 20141028:b
      /*Exp:build physical plan operators which execute in the MS,including ObBindValues,sub_query,ObValues,
          ObTableRpcScan,ObExprValues
        */
      //transformer sunquery select and get select's operator
      int32_t sub_query_index = OB_INVALID_INDEX;
      ObPhyOperator * sub_query_operator = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        if(OB_SUCCESS != (ret = gen_physical_select(logical_plan, physical_plan, err_stat, insert_stmt->get_insert_query_id(), &sub_query_index)))
        {
          TRANS_LOG("generating physical plan for sub-query error, err=%d", ret);
        }
        else if(OB_INVALID_INDEX == sub_query_index)
        {
          YYSYS_LOG(ERROR, "generating physical plan for sub-query error");
          ret = OB_ERROR;
        }
        else if(NULL == (sub_query_operator = physical_plan->get_phy_query(sub_query_index)))
        {
          ret = OB_INVALID_INDEX;
          TRANS_LOG("wrong get sub query operator");
        }
      }
      //trans end
      //generate ObTableRpcScan operator and init
      ObTableRpcScan *table_scan = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        ObRpcScanHint hint;
        hint.read_method_ = ObSqlReadStrategy::USE_GET;
        hint.is_get_skip_empty_row_ = false;
        hint.read_consistency_ = FROZEN;
        const ObTableSchema *table_schema = NULL;
        int64_t table_id = insert_stmt->get_table_id();
        CREATE_PHY_OPERRATOR(table_scan, ObTableRpcScan, inner_plan, err_stat);
        if (OB_UNLIKELY(OB_SUCCESS != ret))
        {
        }
        else if (OB_SUCCESS != (ret = table_scan->set_table(table_id, table_id)))
        {
          TRANS_LOG("failed to set table id, err=%d", ret);
        }
        else if (OB_SUCCESS != (ret = table_scan->init(sql_context_, &hint)))
        {
          TRANS_LOG("failed to init table scan, err=%d", ret);
        }
        //        else if (OB_SUCCESS != (ret = gen_phy_static_data_scan_for_sub_query(logical_plan, err_stat,
        //                                      insert_stmt, row_desc,
        //                                      table_id, *rowkey_info, *table_scan)))
        //        {
        //          TRANS_LOG("err=%d", ret);
        //        }
        else if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_id)))
        {
          ret = OB_ERR_ILLEGAL_ID;
          TRANS_LOG("Fail to get table schema for table[%ld]", table_id);
        }
        else if ((ret = physical_plan->add_base_table_version(
                    table_id,
                    table_schema->get_schema_version()
                    )) != OB_SUCCESS)
        {
          TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d", table_id, ret);
        }
        else
        {
          table_scan->set_rowkey_cell_count(row_desc.get_rowkey_cell_count());
          table_scan->set_cache_bloom_filter(true);
        }
      }

      //generate ObValues operator and set ObTableRpcScan operator as its children
      ObValues *tmp_table = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        CREATE_PHY_OPERRATOR(tmp_table, ObValues, inner_plan, err_stat);
        if (OB_UNLIKELY(OB_SUCCESS != ret))
        {
        }
        else if (OB_SUCCESS != (ret = tmp_table->set_child(0, *table_scan)))
        {
          YYSYS_LOG(WARN, "failed to set child, err=%d", ret);
        }
        //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20151124:b
        else
        {
          inner_plan->set_values_op_id(tmp_table->get_id());
        }
        //add 20151124:e
      }
      //add wenghaixing[decimal] for fix delete bug 2014/10/10
      if (OB_SUCCESS == ret)
      {
        for(int64_t key_col_num=0;OB_SUCCESS == ret && key_col_num<rowkey_info->get_size();key_col_num++)
        {
          uint64_t key_cid=OB_INVALID_ID;
          if(OB_SUCCESS!=(ret = rowkey_info->get_column_id(key_col_num,key_cid)))
          {
            TRANS_LOG("cannot get rowkey id for get param values");
            break;
          }
          else
          {
            ObObjType cond_val_type;
            uint32_t cond_val_precision;
            uint32_t cond_val_scale;
            if(OB_SUCCESS!=sql_context_->schema_manager_->get_cond_val_info(tid,key_cid,cond_val_type,cond_val_precision,cond_val_scale))
            {
              TRANS_LOG("get rowkey schema failed!");
              break;
            }
            else
            {
              tmp_table->add_rowkey_array(tid,key_cid,cond_val_type,cond_val_precision,cond_val_scale);
            }
          }
        }
      }
      //add e

      //generate ObExprValues operator
      ObExprValues *input_values = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        CREATE_PHY_OPERRATOR(input_values, ObExprValues, inner_plan, err_stat);
        if (OB_UNLIKELY(OB_SUCCESS != ret))
        {
        }
        else if ((ret = input_values->set_row_desc(row_desc, row_desc_ext)) != OB_SUCCESS)
        {
          TRANS_LOG("Set descriptor of value operator failed, err=%d", ret);
        }
        else
        {
          //add shili [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20150721:b
          //����table_id  stmt_type �������ƻ�ִ�е�ʱ��ʹ��
          inner_plan->set_table_id(insert_stmt->get_table_id());
          inner_plan->set_stmt_type(ObBasicStmt::T_INSERT);
          //add 20150721:e
          //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20151124:b
          inner_plan->set_expr_values_op_id(input_values->get_id());
          //add 20151124:e
          input_values->set_from_sub_query();
          input_values->set_check_rowkey_duplicate(true);
        }
      }
      //generate ObBindValues operator and set sub_query,ObValues,ObExprValues,ObTableRpcScan as its children
      ObBindValues * bind_values = NULL;
      if(OB_LIKELY(OB_SUCCESS == ret))
      {
        CREATE_PHY_OPERRATOR(bind_values, ObBindValues, inner_plan, err_stat);
        if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
        {
        }
        else if ((ret = bind_values->set_row_desc(row_desc)) != OB_SUCCESS)
        {
          TRANS_LOG("Set descriptor of value operator failed, err=%d", ret);
        }
        else if ((ret = bind_values->set_row_desc_map(row_desc_map)) != OB_SUCCESS)
        {
          TRANS_LOG("Set descriptor of row map info failed, err=%d", ret);
        }
        else if ((ret = bind_values->set_rowkey_info(*rowkey_info)) != OB_SUCCESS)
        {
          TRANS_LOG("Set rowkey info failed, err=%d", ret);
        }
        else if (OB_SUCCESS != (ret = inner_plan->add_phy_query(bind_values)))
        {
          YYSYS_LOG(WARN, "failed to add phy query, err=%d", ret);
        }
        else if((ret = bind_values->set_child(0, *sub_query_operator)) != OB_SUCCESS)
        {
          TRANS_LOG("Set child of bind_values operator failed, err=%d", ret);
        }
        else if((ret = bind_values->set_child(1, *input_values)) != OB_SUCCESS)
        {
          TRANS_LOG("Set child of bind_values operator failed, err=%d", ret);
        }
        else if((ret = bind_values->set_child(2, *tmp_table)) != OB_SUCCESS)
        {
          TRANS_LOG("Set child of bind_values operator failed, err=%d", ret);
        }
        else if((ret = bind_values->set_child(3, *table_scan)) != OB_SUCCESS)
        {
          TRANS_LOG("Set child of bind_values operator failed, err=%d", ret);
        }
        else
        {
          bind_values->set_sql_context(*sql_context_);
          // add by maosy [Insert_Subquery_Function]  20161109
          ObSelectStmt* select_stmt = logical_plan->get_select_query (insert_stmt->get_insert_query_id ());
          if(select_stmt !=NULL && select_stmt->get_query_hint ().change_value_size_)
          {
            int64_t max_row_size = static_cast<int64_t>(0.8*1024L*1024L);
            bind_values->set_max_row_value_size (max_row_size);
          }
          // add by e
          bind_values->set_table_id(insert_stmt->get_table_id());
          physical_plan->set_insert_select_flag(1);
          ColumnItem col_item_for_bind_val;
          for (int32_t index = 0; index < insert_stmt->get_column_size(); index++)
          {
            const ColumnItem *col_item = insert_stmt->get_column_item(index);
            col_item_for_bind_val.column_id_ = col_item->column_id_;
            col_item_for_bind_val.table_id_ = col_item->table_id_;
            col_item_for_bind_val.data_type_ = col_item->data_type_;
            if(OB_SUCCESS != (ret = bind_values->add_column_item(col_item_for_bind_val)))
            {
              TRANS_LOG("fail to add column item to ob_fill_values");
            }
          }
        }
      }
      //add 20141028:e

      //add gaojt [Insert_Subquery_Function] [JHOBv0.1] 20141028:b
      /*Exp:build physical plan operators which execute in the UPS,including ObMemSSTableScan,ObIncScan,ObMultipleGetMerge,
          ObExprValues,ObEmptyRowFilter,ObInsertDBSemFilter
        */
      //generate ObMemSSTableScan operator
      ObMemSSTableScan *static_data = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        CREATE_PHY_OPERRATOR(static_data, ObMemSSTableScan, inner_plan, err_stat);
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          static_data->set_tmp_table(tmp_table->get_id());
        }
      }

      //generate ObIncScan operator
      ObIncScan *inc_scan = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        CREATE_PHY_OPERRATOR(inc_scan, ObIncScan, inner_plan, err_stat);
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          inc_scan->set_scan_type(ObIncScan::ST_MGET);
          inc_scan->set_write_lock_flag();
        }
      }

      //generate ObMultipleGetMerge operator
      ObMultipleGetMerge *fuse_op = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        CREATE_PHY_OPERRATOR(fuse_op, ObMultipleGetMerge, inner_plan, err_stat);
        if (OB_UNLIKELY(OB_SUCCESS != ret))
        {
        }
        else if ((ret = fuse_op->set_child(0, *static_data)) != OB_SUCCESS)
        {
          TRANS_LOG("Set child of fuse_op operator failed, err=%d", ret);
        }
        else if ((ret = fuse_op->set_child(1, *inc_scan)) != OB_SUCCESS)
        {
          TRANS_LOG("Set child of fuse_op operator failed, err=%d", ret);
        }
        else
        {
          fuse_op->set_is_ups_row(false);
        }
      }

      //generate ObEmptyRowFilter operator
      ObEmptyRowFilter * empty_row_filter = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        CREATE_PHY_OPERRATOR(empty_row_filter, ObEmptyRowFilter, inner_plan, err_stat);
        if (OB_UNLIKELY(OB_SUCCESS != ret))
        {
        }
        else if ((ret = empty_row_filter->set_child(0, *fuse_op)) != OB_SUCCESS)
        {
          TRANS_LOG("Failed to set child");
        }
      }

      //generate ObInsertDBSemFilter operator
      ObInsertDBSemFilter *insert_sem = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        CREATE_PHY_OPERRATOR(insert_sem, ObInsertDBSemFilter, inner_plan, err_stat);
        if (OB_UNLIKELY(OB_SUCCESS != ret))
        {
        }
        else if ((ret = insert_sem->set_child(0, *empty_row_filter)) != OB_SUCCESS)
        {
          TRANS_LOG("Failed to set child, err=%d", ret);
        }
        else
        {
          inc_scan->set_values(input_values->get_id(), true);
          insert_sem->set_input_values(input_values->get_id());
        }
      }
      //add fanqiushi_index
      ObIndexTrigger *index_trigger = NULL;
      if(OB_LIKELY(OB_SUCCESS == ret)&&is_need_modify_index)
      {
        CREATE_PHY_OPERRATOR(index_trigger, ObIndexTrigger, inner_plan, err_stat);
        if (OB_UNLIKELY(OB_SUCCESS != ret))
        {
        }
        else if ((ret = index_trigger->set_child(0, *insert_sem)) != OB_SUCCESS)
        {
          TRANS_LOG("Failed to set child, err=%d", ret);
        }
        else if(OB_SUCCESS != (ret = sql_context_->schema_manager_->get_all_modifiable_index_num(insert_stmt->get_table_id(), index_num)))
        {

        }
        else
        {
          //inc_scan->set_values(input_values->get_id(), true);
          //insert_sem->set_input_values(input_values->get_id());
          index_trigger->set_i64_values(insert_stmt->get_table_id(),index_num,0);
        }
      }
      //add:e

      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        //modify by fanqiushi_index
        //        if (OB_SUCCESS != (ret = ups_modify->set_child(0, *insert_sem)))
        //        {
        //          TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
        //        }

        if(is_need_modify_index)
        {
          if (OB_SUCCESS != (ret = ups_modify->set_child(0, *index_trigger)))
          {
            TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
          }
        }
        else
        {
          if (OB_SUCCESS != (ret = ups_modify->set_child(0, *insert_sem)))
          {
            TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
          }
        }
        //modify:e
      }
    }
  }
  if (ret == OB_SUCCESS)
  {
    if ((ret = merge_tables_version(*physical_plan, *inner_plan)) != OB_SUCCESS)
    {
      TRANS_LOG("Failed to add base tables version, err=%d", ret);
    }
  }
  return ret;
}

int ObTransformer::gen_phy_table_for_update(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan*& physical_plan,
    ErrStat& err_stat,
    ObStmt *stmt,
    uint64_t table_id,
    const ObRowkeyInfo &rowkey_info,
    const ObRowDesc &row_desc,
    const ObRowDescExt &row_desc_ext,
    ObPhyOperator*& table_op, ObPhyOperator *sequence_op//add liuzy [sequence select for update] 20150918:
    )
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  TableItem* table_item = NULL;
  ObTableRpcScan *table_rpc_scan_op = NULL;
  ObFilter *filter_op = NULL;
  ObIncScan *inc_scan_op = NULL;
  ObMultipleGetMerge *fuse_op = NULL;
  ObMemSSTableScan *static_data = NULL;
  ObValues *tmp_table = NULL;
  ObRowDesc rowkey_col_map;
  ObExprValues* get_param_values = NULL;
  const ObTableSchema *table_schema = NULL;
  ObObj rowkey_objs[OB_MAX_ROWKEY_COLUMN_NUMBER]; // used for constructing GetParam
  ObPostfixExpression::ObPostExprNodeType type_objs[OB_MAX_ROWKEY_COLUMN_NUMBER];
  ModuleArena rowkey_alloc(OB_MAX_VARCHAR_LENGTH, ModulePageAllocator(ObModIds::OB_SQL_TRANSFORMER));
  ObCellInfo cell_info;
  cell_info.table_id_ = table_id;
  cell_info.row_key_.assign(rowkey_objs, rowkey_info.get_size());

  bool has_other_cond = false;
  ObRpcScanHint hint;
  hint.read_method_ = ObSqlReadStrategy::USE_GET;
  hint.read_consistency_ = FROZEN;
  hint.is_get_skip_empty_row_ = false;
  //add liuzy [sequence select for update] 20150918:b
  ObSelectStmt *select_stmt = NULL;
  ObSequenceSelect *sequence_select_op = NULL;
  //add lijianqiang [sequence_fix] 20151030:b
  ObSequence * base_sequence_op = NULL;
  base_sequence_op = dynamic_cast<ObSequence *> (sequence_op);
  //add 20151030:e
  if (NULL != sequence_op
      && ObBasicStmt::T_SELECT == stmt->get_stmt_type())
  {
    sequence_select_op = dynamic_cast<ObSequenceSelect *>(sequence_op);
    select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
  }
  if (NULL != select_stmt
      && NULL != sequence_select_op
      && select_stmt->select_clause_has_sequence())
  {
    hint.read_consistency_ = STRONG;
  }
  //add 20150918:e

  if (table_id == OB_INVALID_ID
      || (table_item = stmt->get_table_item_by_id(table_id)) == NULL
      || TableItem::BASE_TABLE != table_item->type_)
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("Wrong table id, tid=%lu", table_id);
  }
  else if (NULL == CREATE_PHY_OPERRATOR(table_rpc_scan_op, ObTableRpcScan, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else if ((ret = table_rpc_scan_op->set_table(table_item->table_id_, table_item->ref_id_)) != OB_SUCCESS)
  {
    TRANS_LOG("ObTableRpcScan set table failed");
  }
  else if (OB_SUCCESS != (ret = table_rpc_scan_op->init(sql_context_, &hint)))
  {
    TRANS_LOG("ObTableRpcScan init failed");
  }
  else if (NULL == CREATE_PHY_OPERRATOR(tmp_table, ObValues, physical_plan, err_stat))
  {
  }
  else if (OB_SUCCESS != (ret = tmp_table->set_child(0, *table_rpc_scan_op)))
  {
    YYSYS_LOG(WARN, "failed to set child op, err=%d", ret);
  }
  else if (OB_SUCCESS != (ret = physical_plan->add_phy_query(tmp_table)))
  {
    YYSYS_LOG(WARN, "failed to add sub query, err=%d", ret);
  }
  //add liuzy [sequence select for update] 20150922:b
  else if (NULL != sequence_select_op
           && select_stmt->select_clause_has_sequence()
           && OB_SUCCESS != (ret = physical_plan->add_phy_query(sequence_select_op)))
  {
    YYSYS_LOG(WARN, "failed to add sub query, err=%d", ret);
  }
  //add 20150922:e
  else if (NULL == CREATE_PHY_OPERRATOR(filter_op, ObFilter, physical_plan, err_stat))
  {
  }
  else if (NULL == CREATE_PHY_OPERRATOR(inc_scan_op, ObIncScan, physical_plan, err_stat))
  {
  }
  else if (NULL == CREATE_PHY_OPERRATOR(fuse_op, ObMultipleGetMerge, physical_plan, err_stat))
  {
  }
  else if (NULL == CREATE_PHY_OPERRATOR(static_data, ObMemSSTableScan, physical_plan, err_stat))
  {
  }
  else if (OB_SUCCESS != (ret = fuse_op->set_child(0, *static_data)))
  {
  }
  else if (OB_SUCCESS != (ret = fuse_op->set_child(1, *inc_scan_op)))
  {
  }
  else if (NULL == CREATE_PHY_OPERRATOR(get_param_values, ObExprValues, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else if (OB_SUCCESS != (ret = physical_plan->add_phy_query(get_param_values)))
  {
    YYSYS_LOG(WARN, "failed to add sub query, err=%d", ret);
  }
  else if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_id)))
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("Fail to get table schema for table[%ld]", table_id);
  }
  else if ((ret = physical_plan->add_base_table_version(
              table_id,
              table_schema->get_schema_version()
              )) != OB_SUCCESS)
  {
    TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d", table_id, ret);
  }
  else
  {
    //add shili [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20150721:b
    //����table_id  stmt_type �������ƻ�ִ�е�ʱ��ʹ��
    physical_plan->set_table_id(table_id);
    physical_plan->set_stmt_type(ObBasicStmt::T_UPDATE);
    //add 20150721:e
    fuse_op->set_is_ups_row(false);

    inc_scan_op->set_scan_type(ObIncScan::ST_MGET);
    inc_scan_op->set_write_lock_flag();
    inc_scan_op->set_hotspot(stmt->get_query_hint().hotspot_);
    inc_scan_op->set_values(get_param_values->get_id(), false);

    static_data->set_tmp_table(tmp_table->get_id());
    //add liuzy [sequence select for update] 20150922:b
    if (NULL != sequence_select_op
        && select_stmt->select_clause_has_sequence())
    {
      sequence_select_op->set_phy_plan(physical_plan);
      sequence_select_op->set_tmp_table(tmp_table->get_id());
    }
    //add 20150922:e
    table_rpc_scan_op->set_rowkey_cell_count(row_desc.get_rowkey_cell_count());
    table_rpc_scan_op->set_need_cache_frozen_data(true);

    get_param_values->set_row_desc(row_desc, row_desc_ext);
    //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20151124:b
    physical_plan->set_expr_values_op_id(get_param_values->get_id());
    physical_plan->set_values_op_id(tmp_table->get_id());
    physical_plan->set_table_rpc_scan_op_id(table_rpc_scan_op->get_id());
    //add 20151124:e
    // set filters
    int32_t num = stmt->get_condition_size();
    uint64_t cid = OB_INVALID_ID;
    int64_t cond_op = T_INVALID;
    ObObj cond_val;
    ObPostfixExpression::ObPostExprNodeType val_type = ObPostfixExpression::BEGIN_TYPE;
    int64_t rowkey_idx = OB_INVALID_INDEX;
    ObRowkeyColumn rowkey_col;
    //add wenghaixing[decimal] for fix delete bug 2014/10/10
    uint64_t tid= table_schema->get_table_id();
    //add e
    //add liuzy [sequence select for update] 20150918:b
    if (NULL != sequence_select_op)
    {
      sequence_select_op->reset_sequence_names_idx(select_stmt->get_column_has_sequene_count());
    }
    //add 20150918:e
    for (int32_t i = 0; i < num; i++)
    {
      ObSqlRawExpr *cnd_expr = logical_plan->get_expr(stmt->get_condition_id(i));
      OB_ASSERT(cnd_expr);
      cnd_expr->set_applied(true);
      ObSqlExpression *filter = ObSqlExpression::alloc();
      if (NULL == filter)
      {
        TRANS_LOG("no memory");
        ret = OB_ALLOCATE_MEMORY_FAILED;
        break;
      }
      else if (OB_SUCCESS != (ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan)))
      {
        ObSqlExpression::free(filter);
        TRANS_LOG("Failed to fill expression, err=%d", ret);
        break;
      }
      //add liuzy [sequence select for update] 20150918:b
      else if (NULL != base_sequence_op
               && base_sequence_op->can_fill_sequence_info()
               && base_sequence_op->is_sequence_cond_id(stmt->get_condition_id(i))
               && OB_SUCCESS == ret
               && (OB_SUCCESS != (ret = base_sequence_op->fill_the_sequence_info_to_cond_expr(filter, OB_INVALID_ID))))
      {
        TRANS_LOG("Failed deal the sequence condition filter,err=%d",ret);
        break;
      }
      else if (OB_SUCCESS != ret)
      {
        break;
      }
      //add 20150918:e
      else if (filter->is_simple_condition(false, cid, cond_op, cond_val, &val_type)
               && (T_OP_EQ == cond_op || T_OP_IS == cond_op)
               && rowkey_info.is_rowkey_column(cid))
      {
        if(T_OP_EQ == cond_op && cond_val.is_null())
        {
          ObSqlExpression *primary_key_null_filter = ObSqlExpression::alloc();
          if(NULL == primary_key_null_filter)
          {
            TRANS_LOG("no memory");
            ret = OB_ALLOCATE_MEMORY_FAILED;
            break;
          }
          *primary_key_null_filter = *filter;
          has_other_cond = true;
          YYSYS_LOG(INFO, "where:primary key = NULL");
          if(OB_SUCCESS != (ret = filter_op->add_filter(primary_key_null_filter)))
          {
            ObSqlExpression::free(primary_key_null_filter);
            TRANS_LOG("Failed to add filter, err=%d", ret);
            break;
          }
        }
        if (

            OB_SUCCESS != (ret = table_rpc_scan_op->add_filter(filter)))
        {
          ObSqlExpression::free(filter);
          TRANS_LOG("Failed to add filter, err=%d", ret);
          break;
        }
        else if (OB_SUCCESS != (ret = rowkey_col_map.add_column_desc(OB_INVALID_ID, cid)))
        {
          TRANS_LOG("Failed to add column desc, err=%d", ret);
          break;
        }
        else if (OB_SUCCESS != (ret = rowkey_info.get_index(cid, rowkey_idx, rowkey_col)))
        {
          TRANS_LOG("Unexpected branch");
          ret = OB_ERR_UNEXPECTED;
          break;
        }
        //add wenghaixing[decimal] for fix delete bug 2014/10/10
        else
        {
          ObObjType cond_val_type;
          uint32_t cond_val_precision;
          uint32_t cond_val_scale;
          ObObj static_obj;
          if(OB_SUCCESS!=sql_context_->schema_manager_->get_cond_val_info(tid,cid,cond_val_type,cond_val_precision,cond_val_scale))
          {

          }
          else
          {
            tmp_table->add_rowkey_array(tid,cid,cond_val_type,cond_val_precision,cond_val_scale);
            if(ObDecimalType==cond_val_type)
            {
              static_obj.set_precision(cond_val_precision);
              static_obj.set_scale(cond_val_scale);
              static_obj.set_type(cond_val_type);
            }
          }

          //add e
          //modify wenghaixing[decimal] for fix delete bug 2014/10/10
          //else if (OB_SUCCESS != (ret = ob_write_obj(rowkey_alloc, cond_val, rowkey_objs[rowkey_idx]))) // deep copy
          if (OB_SUCCESS != (ret = ob_write_obj_for_delete(rowkey_alloc, cond_val, rowkey_objs[rowkey_idx],static_obj))) // deep copy
            //modify e
          {
            TRANS_LOG("failed to copy cell, err=%d", ret);
          }

          else
          {
            type_objs[rowkey_idx] = val_type;
            YYSYS_LOG(DEBUG, "rowkey obj, i=%ld val=%s", rowkey_idx, to_cstring(cond_val));
          }
        }
      }
      else
      {
        // other condition
        has_other_cond = true;
        // YYSYS_LOG(ERROR,"test:whx row_desc-p1[%s]",to_cstring(row_desc));
        if (OB_SUCCESS != (ret = filter_op->add_filter(filter)))
        {
          TRANS_LOG("Failed to add filter, err=%d", ret);
          break;
        }
      }

    } // end for
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      int64_t rowkey_col_num = rowkey_info.get_size();
      uint64_t cid = OB_INVALID_ID;
      for (int64_t i = 0; i < rowkey_col_num; ++i)
      {
        if (OB_SUCCESS != (ret = rowkey_info.get_column_id(i, cid)))
        {
          TRANS_LOG("Failed to get column id, err=%d", ret);
          break;
        }
        else if (OB_INVALID_INDEX == rowkey_col_map.get_idx(OB_INVALID_ID, cid))
        {
          TRANS_LOG("Primary key column %lu not specified in the WHERE clause", cid);
          ret = OB_ERR_LACK_OF_ROWKEY_COL;
          break;
        }
      } // end for
    }
  }
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    // add output columns
    int32_t num = stmt->get_column_size();
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      const ColumnItem *col_item = stmt->get_column_item(i);
      if (col_item && col_item->table_id_ == table_item->table_id_)
      {

        ObBinaryRefRawExpr col_expr(col_item->table_id_, col_item->column_id_, T_REF_COLUMN);
        ObSqlRawExpr col_raw_expr(
              common::OB_INVALID_ID,
              col_item->table_id_,
              col_item->column_id_,
              &col_expr);
        ObSqlExpression output_expr;
        if ((ret = col_raw_expr.fill_sql_expression(
               output_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS
            || (ret = table_rpc_scan_op->add_output_column(output_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add table output columns faild");
          break;
        }

        // for IncScan
        ObConstRawExpr col_expr2;
        if (i < rowkey_info.get_size()) // rowkey column
        {
          if (OB_SUCCESS != (ret = col_expr2.set_value_and_type(rowkey_objs[i])))
          {
            YYSYS_LOG(WARN, "failed to set value, err=%d", ret);
            break;
          }
          else
          {
            switch (type_objs[i])
            {
              case ObPostfixExpression::PARAM_IDX:
                col_expr2.set_expr_type(T_QUESTIONMARK);
                col_expr2.set_result_type(ObVarcharType);
                break;
              case ObPostfixExpression::SYSTEM_VAR:
                col_expr2.set_expr_type(T_SYSTEM_VARIABLE);
                col_expr2.set_result_type(ObVarcharType);
                break;
              case ObPostfixExpression::TEMP_VAR:
                col_expr2.set_expr_type(T_TEMP_VARIABLE);
                col_expr2.set_result_type(ObVarcharType);
                break;
              default:
                break;
            }
          }
        }

        else
        {
          ObObj null_obj;
          col_expr2.set_value_and_type(null_obj);
        }


        ObSqlRawExpr col_raw_expr2(
              common::OB_INVALID_ID,
              col_item->table_id_,
              col_item->column_id_,
              &col_expr2);
        ObSqlExpression output_expr2;
        if ((ret = col_raw_expr2.fill_sql_expression(
               output_expr2,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS)
        {
          TRANS_LOG("Add table output columns failed");
          break;
        }
        else if (OB_SUCCESS != (ret = get_param_values->add_value(output_expr2)))
        {
          TRANS_LOG("Failed to add cell into get param, err=%d", ret);
          break;
        }
        //add wenghaixing[decimal] for fix delete bug 2014/10/10
        else
        {
          get_param_values->set_del_upd();
        }
        //add e

      }
    } // end for

  }
  // add action flag column
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    ObSqlExpression column_ref;
    column_ref.set_tid_cid(OB_INVALID_ID, OB_ACTION_FLAG_COLUMN_ID);
    if (OB_SUCCESS != (ret = ObSqlExpressionUtil::make_column_expr(OB_INVALID_ID, OB_ACTION_FLAG_COLUMN_ID, column_ref)))
    {
      YYSYS_LOG(WARN, "fail to make column expr:ret[%d]", ret);
    }
    else if (OB_SUCCESS != (ret = table_rpc_scan_op->add_output_column(column_ref)))
    {
      YYSYS_LOG(WARN, "failed to add output column, err=%d", ret);
    }
  }
  if (OB_SUCCESS == ret && NULL != sequence_op )
  {
    ObSequenceUpdate *sequence_update_op = dynamic_cast<ObSequenceUpdate *>(sequence_op);
    //add lijianqiang [sequence] 20150909:b
    /*Exp:hanlde the set clause of UPDATE stmt*/
    int row_num = 1;
    if (sequence_update_op!=NULL && OB_SUCCESS != (ret = sequence_update_op->handle_the_set_clause_of_seuqence(row_num)))
    {
      TRANS_LOG("handle the set clause of sequence failed,ret=%d",ret);
    }
    //add 2050909:e
  }

  if (ret == OB_SUCCESS)
  {
    if (has_other_cond)
    {

      if (OB_SUCCESS != (ret = filter_op->set_child(0, *fuse_op)))
      {
        TRANS_LOG("Failed to set child, err=%d", ret);
      }
      else
      {
        table_op = filter_op;
      }

    }
    else
    {

      table_op = fuse_op;

    }
    //add wenghaixing[decimal] for fix delete bug 2014/10/10
    tmp_table->set_fix_obvalues();
    //add e
  }
  return ret;
}
//add wenghaixing [secondary index replace bug_fix]20150517
int ObTransformer::cons_row_desc_with_index(const uint64_t table_id,
                                            const ObStmt *stmt,
                                            ObRowDescExt &row_desc_ext,
                                            ObRowDesc &row_desc,
                                            const ObRowkeyInfo *&rowkey_info,
                                            //common::ObSEArray<int64_t, 64> &row_desc_map,
                                            ErrStat &err_stat)
{
  OB_ASSERT(sql_context_);
  OB_ASSERT(sql_context_->schema_manager_);
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  const ObTableSchema *table_schema = NULL;
  if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_id)))
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("fail to get table schema for table[%ld]", table_id);
  }
  else
  {
    rowkey_info = &table_schema->get_rowkey_info();
    int64_t rowkey_col_num = rowkey_info->get_size();
    row_desc.set_rowkey_cell_count(rowkey_col_num);

    int32_t column_num = stmt->get_column_size();
    uint64_t max_column_id = table_schema->get_max_column_id();
    const ColumnItem* column_item = NULL;
    //row_desc_map.clear();
    //row_desc_map.reserve(column_num);
    ObObj data_type;
    // construct rowkey columns first
    //add wenghaixing DECIMAL OceanBase_BankCommV0.3 2014_7_14:b
    // construct rowkey's precision and scale
    const ObColumnSchemaV2* column_schema_for_rowkey = NULL;
    //add:e
    // construct rowkey columns first
    for (int64_t i = 0; OB_SUCCESS == ret && i < rowkey_col_num; ++i) // for each primary key
    {
      const ObRowkeyColumn *rowkey_column = rowkey_info->get_column(i);
      OB_ASSERT(rowkey_column);
      // find it's index in the input columns
      for (int32_t j = 0; ret == OB_SUCCESS && j < column_num; ++j)
      {
        column_item = stmt->get_column_item(j);
        OB_ASSERT(column_item);
        OB_ASSERT(table_id == column_item->table_id_);
        if (rowkey_column->column_id_ == column_item->column_id_)
        {
          if (OB_SUCCESS != (ret = row_desc.add_column_desc(column_item->table_id_,
                                                            column_item->column_id_)))
          {
            TRANS_LOG("failed to add row desc, err=%d", ret);
          }
          else
          {
            //add wenghaixing DECIMAL OceanBase_BankCommV0.3 2014_7_14:b
            if (NULL == (column_schema_for_rowkey = sql_context_->schema_manager_->get_column_schema(
                           column_item->table_id_, column_item->column_id_)))
            {
              ret = OB_ERR_COLUMN_NOT_FOUND;
              TRANS_LOG("Get column item failed");
              break;
            }
            data_type.set_precision(column_schema_for_rowkey->get_precision());
            data_type.set_scale(column_schema_for_rowkey->get_scale());

            //add e
            data_type.set_type(rowkey_column->type_);
            if (OB_SUCCESS != (ret = row_desc_ext.add_column_desc(column_item->table_id_,
                                                                  column_item->column_id_, data_type)))
            {
              TRANS_LOG("failed to add row desc, err=%d", ret);
            }
          }
          break;
        }
      } // end for
    }   // end for
    // then construct other columns
    const ObColumnSchemaV2* column_schema = NULL;
    for (uint64_t cid = OB_APP_MIN_COLUMN_ID; ret == OB_SUCCESS && cid <= max_column_id; ++cid)
    {
      bool hit_index = false;
      bool in_stmt = false;
      if (OB_SUCCESS != (ret = sql_context_->schema_manager_->column_hint_index(table_id, cid, hit_index)))
      {
        //ret = OB_ERROR;
        YYSYS_LOG(WARN, "column hint index failed,ret = %d, table_id = %ld, cid = %ld",ret, table_id, cid);
        break;
      }
      else if(OB_SUCCESS != (ret = is_column_in_stmt(table_id, cid, stmt, in_stmt)))
      {
        YYSYS_LOG(WARN, "is coloumn in stmt failed,ret = %d, table_id = %ld, cid = %ld", ret, table_id, cid);
        break;
      }
      if (!rowkey_info->is_rowkey_column(cid)&&(hit_index || in_stmt))
      {
        if (NULL == (column_schema = sql_context_->schema_manager_->get_column_schema(
                       table_id, cid)))
        {
          ret = OB_ERR_COLUMN_NOT_FOUND;
          TRANS_LOG("Get column item failed");
          break;
        }
        else if (OB_SUCCESS != (ret = row_desc.add_column_desc(table_id,
                                                               cid)))
        {
          TRANS_LOG("failed to add row desc, err=%d", ret);
        }
        else
        {
          data_type.set_type(column_schema->get_type());
          //add fanqiushi DECIMAL OceanBase_BankCommV0.3 2014_7_9:b
          /*
           *�ò��ִ����ǽ�column_schema�������Ϣ�浽data_type���棬����data_type�������Ϣд��row_desc_ext���� //repaired from messy code by zhuxh 20151014
           *
           *column_schema���û�����ı���schema��data_type���м�����row_desc_ext���ں���������ת����ʱ���õ�
           *
           *�����ӵĴ����ԭ���ǽ�column_schema������precision��scaleҲ�浽data_type����
           */
          data_type.set_precision(column_schema->get_precision());
          data_type.set_scale(column_schema->get_scale());
          //add:e
          if (OB_SUCCESS != (ret = row_desc_ext.add_column_desc(table_id,
                                                                cid, data_type)))
          {
            TRANS_LOG("failed to add row desc, err=%d", ret);
          }
        }
      } // end if not rowkey column
    }   // end for
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      YYSYS_LOG(DEBUG, "row_desc=%s ", to_cstring(row_desc));
    }
  }
  return ret;
}

int ObTransformer::is_column_in_stmt(const uint64_t table_id, const uint64_t column_id, const ObStmt *stmt, bool &in_stmt)
{
  int ret = OB_SUCCESS;
  in_stmt = false;
  if(OB_UNLIKELY(NULL == stmt))
  {
    ret = OB_INVALID_ARGUMENT;
    YYSYS_LOG(WARN, "stmt pointer cannot be NULL");
  }
  else
  {
    int32_t column_num = stmt->get_column_size();
    const ColumnItem *column_item = NULL;
    for(int32_t i =0; i < column_num; i++)
    {
      if(OB_UNLIKELY(NULL == (column_item = stmt->get_column_item(i))))
      {
        ret = OB_INVALID_ARGUMENT;
        YYSYS_LOG(WARN, "stmt pointer cannot be NULL, i = %d, ret = %d", i, ret);
        break;
      }
      else if(table_id != column_item->table_id_)
      {
        ret = OB_INVALID_ARGUMENT;
        YYSYS_LOG(WARN, "table_id is not equal item,table_id[%ld], column_item_tid[%ld]",table_id, column_item->table_id_);
        break;
      }
      else if(column_id == column_item->column_id_)
      {
        in_stmt = true;
        break;
      }
    }
  }
  return ret;
}
//add e
int ObTransformer::cons_row_desc(const uint64_t table_id,
                                 const ObStmt *stmt,
                                 ObRowDescExt &row_desc_ext,
                                 ObRowDesc &row_desc,
                                 const ObRowkeyInfo *&rowkey_info,
                                 ObSEArray<int64_t, 64> &row_desc_map,
                                 ErrStat& err_stat

                                 )
{
  OB_ASSERT(sql_context_);
  OB_ASSERT(sql_context_->schema_manager_);
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  const ObTableSchema *table_schema = NULL;
  if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_id)))
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("fail to get table schema for table[%ld]", table_id);
  }
  else
  {
    rowkey_info = &table_schema->get_rowkey_info();
    int64_t rowkey_col_num = rowkey_info->get_size();
    row_desc.set_rowkey_cell_count(rowkey_col_num);

    int32_t column_num = stmt->get_column_size();
    const ColumnItem* column_item = NULL;
    row_desc_map.clear();
    row_desc_map.reserve(column_num);
    ObObj data_type;
    // construct rowkey columns first
    //add wenghaixing DECIMAL OceanBase_BankCommV0.3 2014_7_14:b
    // construct rowkey's precision and scale
    const ObColumnSchemaV2* column_schema_for_rowkey = NULL;
    //add:e
    // construct rowkey columns first
    for (int64_t i = 0; OB_SUCCESS == ret && i < rowkey_col_num; ++i) // for each primary key
    {
      const ObRowkeyColumn *rowkey_column = rowkey_info->get_column(i);
      OB_ASSERT(rowkey_column);
      // find it's index in the input columns
      for (int32_t j = 0; ret == OB_SUCCESS && j < column_num; ++j)
      {
        column_item = stmt->get_column_item(j);
        OB_ASSERT(column_item);
        OB_ASSERT(table_id == column_item->table_id_);
        if (rowkey_column->column_id_ == column_item->column_id_)
        {
          if (OB_SUCCESS != (ret = row_desc_map.push_back(j)))
          {
            TRANS_LOG("failed to add index map, err=%d", ret);
          }
          else if (OB_SUCCESS != (ret = row_desc.add_column_desc(column_item->table_id_,
                                                                 column_item->column_id_)))
          {
            TRANS_LOG("failed to add row desc, err=%d", ret);
          }
          else
          {
            //add wenghaixing DECIMAL OceanBase_BankCommV0.3 2014_7_14:b
            if (NULL == (column_schema_for_rowkey = sql_context_->schema_manager_->get_column_schema(
                           column_item->table_id_, column_item->column_id_)))
            {
              ret = OB_ERR_COLUMN_NOT_FOUND;
              TRANS_LOG("Get column item failed");
              break;
            }
            data_type.set_precision(column_schema_for_rowkey->get_precision());
            data_type.set_scale(column_schema_for_rowkey->get_scale());

            //add e
            data_type.set_type(rowkey_column->type_);
            if (OB_SUCCESS != (ret = row_desc_ext.add_column_desc(column_item->table_id_,
                                                                  column_item->column_id_, data_type)))
            {
              TRANS_LOG("failed to add row desc, err=%d", ret);
            }
          }
          break;
        }
      } // end for
    }   // end for
    // then construct other columns
    const ObColumnSchemaV2* column_schema = NULL;
    for (int32_t i = 0; ret == OB_SUCCESS && i < column_num; ++i)
    {
      column_item = stmt->get_column_item(i);
      OB_ASSERT(column_item);
      OB_ASSERT(table_id == column_item->table_id_);
      if (!rowkey_info->is_rowkey_column(column_item->column_id_))
      {
        if (NULL == (column_schema = sql_context_->schema_manager_->get_column_schema(
                       column_item->table_id_, column_item->column_id_)))
        {
          ret = OB_ERR_COLUMN_NOT_FOUND;
          TRANS_LOG("Get column item failed");
          break;
        }
        else if (OB_SUCCESS != (ret = row_desc_map.push_back(i)))
        {
          TRANS_LOG("failed to add index map, err=%d", ret);
        }
        else if (OB_SUCCESS != (ret = row_desc.add_column_desc(column_item->table_id_,
                                                               column_item->column_id_)))
        {
          TRANS_LOG("failed to add row desc, err=%d", ret);
        }
        else
        {
          data_type.set_type(column_schema->get_type());
          //add fanqiushi DECIMAL OceanBase_BankCommV0.3 2014_7_9:b
          /*
             *�ò��ִ����ǽ�column_schema�������Ϣ�浽data_type���棬����data_type�������Ϣд��row_desc_ext����
             *
             *column_schema���û�����ı���schema��data_type���м�����row_desc_ext���ں���������ת����ʱ���õ�
             *
             *�����ӵĴ����ԭ���ǽ�column_schema������precision��scaleҲ�浽data_type����
             */
          data_type.set_precision(column_schema->get_precision());
          data_type.set_scale(column_schema->get_scale());
          //add:e
          if (OB_SUCCESS != (ret = row_desc_ext.add_column_desc(column_item->table_id_,
                                                                column_item->column_id_, data_type)))
          {
            TRANS_LOG("failed to add row desc, err=%d", ret);
          }
        }
      } // end if not rowkey column
    }   // end for
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      YYSYS_LOG(DEBUG, "row_desc=%s map_count=%ld", to_cstring(row_desc), row_desc_map.count());
    }
  }
  return ret;
}

int ObTransformer::gen_physical_update_new(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan*& physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObUpdateStmt *update_stmt = NULL;
  ObUpsModifyWithDmlType *ups_modify = NULL;
  ObProject *project_op = NULL;
  uint64_t table_id = OB_INVALID_ID;
  const ObRowkeyInfo *rowkey_info = NULL;
  ObRowDesc row_desc;
  ObRowDescExt row_desc_ext;
  ObSEArray<int64_t, 64> row_desc_map;
  ObPhysicalPlan* inner_plan = NULL;
  ObSequenceUpdate * sequence_update_op =NULL;
  //add wenghaixing [secondary index upd] 20141126
  IndexList out;
  bool is_column_hint_index=false;
  //add e
  //add gaojt [Delete_Update_Function] [JHOBv0.1] 20160302:b
  bool is_delete_update = true;
  bool is_update_rowkey = false;
  ObUpdateRowkey *op_update_rowkey = NULL;
  if (OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, update_stmt)))
  {
  }
  else if(update_stmt->get_is_update_multi_batch())
  {
    YYSYS_LOG(DEBUG,"This is multi-batch in update statement");
    is_multi_batch_ = true;
  }
  if(OB_SUCCESS != ret)
  {
  }
  else if (OB_SUCCESS != (ret = is_hit_update_rowkey(update_stmt->get_update_table_id(), rowkey_info, update_stmt, is_update_rowkey)))
  {
    if (ret == OB_DUPLICATE_COLUMN)
    {
      YYSYS_LOG(USER_ERROR, "Duplicated column");
    }
    YYSYS_LOG(WARN, "faild to set is_hit_update_rowkey, err=%d",ret);
  }
  else if (is_update_rowkey)
  {
    if (update_stmt->has_sequence() || physical_plan->in_ups_executor())
    {
      ret = OB_NOT_SUPPORT_FOR_UPDATE_ROWKEY;
      YYSYS_LOG(USER_ERROR, "The function is NOT support for update rowkey");
    }
    else
    {
      //    YYSYS_LOG(WARN, "start update rowkey");
      table_id = update_stmt->get_update_table_id();
      bool multi_update = false;
      if (OB_SUCCESS != (ret = set_update_rowkey(physical_plan, query_id, op_update_rowkey, index, err_stat)))
      {
        YYSYS_LOG(WARN, "add setoperator failed, err=%d",ret);
      }
      else if (OB_SUCCESS != (ret = is_multi_delete_update(logical_plan, physical_plan, *rowkey_info, update_stmt, err_stat, multi_update)))
      {
        YYSYS_LOG(WARN, "fail to run the function: is_multi_delete_update in delete statement");
      }
      else if (!multi_update)
      {
        op_update_rowkey->set_is_multi_update(multi_update);
        if (OB_SUCCESS != (ret = gen_phy_update_rowkey_for_select_rows(logical_plan, physical_plan, op_update_rowkey, err_stat, query_id, index)))
        {
          YYSYS_LOG(WARN, "gen_phy_update_rowkey_for_select_rows faild, err=%d",ret);
        }
      }
      else
      {
        op_update_rowkey->set_is_multi_update(multi_update);
        if (OB_SUCCESS != (ret = gen_physical_select_for_update_rowkey(logical_plan, physical_plan, op_update_rowkey, err_stat, query_id, index)))
        {
          YYSYS_LOG(WARN, "gen_phy_update_rowkey_select_for_update faild, err=%d",ret);
        }
      }
      if (OB_SUCCESS == ret)
      {
        if (OB_SUCCESS != (ret = gen_physical_delete_new(logical_plan, physical_plan, err_stat, query_id, index, op_update_rowkey)))
        {
          YYSYS_LOG(WARN, "gen_phy_update_rowkey_delete_old_row faild, err=%d",ret);
        }
        else if (OB_SUCCESS != (ret = gen_phy_update_rowkey_insert_new_rows(logical_plan, physical_plan, op_update_rowkey, err_stat, query_id, index)))
        {
          YYSYS_LOG(WARN, "gen_phy_update_rowkey_insert_new_row faild, err=%d",ret);
        }
      }
    }
  }
  else
  {
    if (OB_SUCCESS != ret)
    {
    }
    //add gaojt 20160302:e
    //mod gaojt [Delete_Update_Function] [JHOBv0.1] 20160302:b
    else if (OB_SUCCESS != (ret = wrap_ups_executor(physical_plan, query_id, inner_plan, index, err_stat,
                                                    is_delete_update)))
    {
      YYSYS_LOG(WARN, "err=%d", ret);
    }
    //mod gaojt 20160302:e
    /* generate root operator */
    else if (NULL == CREATE_PHY_OPERRATOR(ups_modify, ObUpsModifyWithDmlType, inner_plan, err_stat))
    {
      ret = OB_ALLOCATE_MEMORY_FAILED;
      TRANS_LOG("Failed to create phy operator");
    }
    else if (OB_SUCCESS != (ret = inner_plan->add_phy_query(
                              ups_modify,
                              physical_plan == inner_plan ? index : NULL,
                              physical_plan != inner_plan)))
    {
      TRANS_LOG("Add ups_modify operator failed");
    }
    else if (NULL == CREATE_PHY_OPERRATOR(project_op, ObProject, inner_plan, err_stat))
    {
      ret = OB_ALLOCATE_MEMORY_FAILED;
      TRANS_LOG("Failed to create phy operator");
    }
    else if (OB_SUCCESS != (ret = cons_row_desc(update_stmt->get_update_table_id(), update_stmt,
                                                row_desc_ext, row_desc, rowkey_info, row_desc_map, err_stat)))
    {
    }
    else
    {
      table_id = update_stmt->get_update_table_id();
      ups_modify->set_dml_type(OB_DML_UPDATE);
    }

    physical_plan->set_table_id(table_id);
    ObWhenFilter *when_filter_op = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      if (update_stmt->get_when_expr_size() > 0)
      {
        if ((ret = gen_phy_when(logical_plan,
                                inner_plan,
                                err_stat,
                                query_id,
                                *project_op,
                                when_filter_op
                                )) != OB_SUCCESS)
        {
        }
        else if ((ret = ups_modify->set_child(0, *when_filter_op)) != OB_SUCCESS)
        {
          TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
        }
      }
    }

    //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20160415:b
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      //wrap add set clause of update stmt to project as a function
      if (OB_SUCCESS != (ret = add_set_clause_for_update_to_project(logical_plan,
                                                                    inner_plan,
                                                                    project_op,
                                                                    row_desc,
                                                                    rowkey_info,
                                                                    update_stmt,
                                                                    table_id,
                                                                    err_stat)))
      {
        TRANS_LOG("add setoperator failed, err=%d", ret);
      }
    }

    //add 20160415:e
    if(OB_LIKELY(OB_SUCCESS == ret))
    {
      for (int64_t column_idx = 0; column_idx < update_stmt->get_update_column_count(); column_idx++)
      {
        uint64_t column_id = OB_INVALID_ID ;
        if (OB_SUCCESS != (ret = update_stmt->get_update_column_id(column_idx, column_id)))
        {
          TRANS_LOG("fail to get update column id for table %lu column_idx=%lu", table_id, column_idx);
          break;
        }
        else if(OB_SUCCESS != (ret = sql_context_->schema_manager_->column_hint_index(table_id,column_id,out)))
        {
          YYSYS_LOG(WARN,"failed to query if column hit index!table_id[%ld],column_id[%ld]",table_id,column_id);
        }
        else if(out.get_count()>0)
        {
          is_column_hint_index=true;
        }
      }
    }
    if (OB_SUCCESS == ret && update_stmt->has_sequence())
    {
      //add shili, [MultiUPS] [merge transaction code]20170309
      physical_plan->set_result_set(result_);
      inner_plan->set_result_set(result_);
      //add e
      YYSYS_LOG(INFO, "handle the sequence for update set clause2");
      if(NULL == CREATE_PHY_OPERRATOR(sequence_update_op, ObSequenceUpdate, inner_plan, err_stat))
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        TRANS_LOG("Failed to create sequence phy operator");
      }
      else if(OB_SUCCESS !=
              (ret = wrap_sequence(logical_plan, physical_plan, err_stat, row_desc_map, sequence_update_op,
                                   update_stmt, inner_plan)))
      {
        TRANS_LOG("wrap sequence failed");
      }
      else
      {
        YYSYS_LOG(INFO, "handle the sequence for update set clause1");
        if(OB_SUCCESS != (ret = sequence_update_op->prepare_sequence_prevval()))
        {
          TRANS_LOG("prepare sequence info failed!");
        }
        else
        {
          sequence_update_op->init_global_prevval_state_and_lock_sequence_map();
          sequence_update_op->copy_sequence_info_from_update_stmt();
          sequence_update_op->set_out_row_desc_and_row_desc_ext(row_desc, row_desc_ext);
          sequence_update_op->set_project_for_update(project_op);//we need to store the sequence info to the project op,we get the point to the project here
        }
        //add by maosy [MultiUps 1.0] [sequence and secondary index ] 20170615 b
        //            int64_t row_num = 1;
        //            if(OB_SUCCESS != (ret = sequence_update_op->handle_the_set_clause_of_seuqence(row_num)))
        //            {
        //                TRANS_LOG("handle the set clause of  sequence failed!");
        //            }
        //del by maosy e
      }
    }
    ObIndexTriggerUpd *index_trigger_upd = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      if(is_column_hint_index)
      {
        //add by maosy  [MultiUPS 1.0][secondary index optimize]20170511 b:
        if( OB_SUCCESS !=(ret =gen_physical_index_trigger_for_update(physical_plan,
                                                                     err_stat,
                                                                     index_trigger_upd,
                                                                     project_op,
                                                                     table_id,
                                                                     row_desc,
                                                                     row_desc_ext,
                                                                     rowkey_info,
                                                                     update_stmt,
                                                                     out)))
        {
          YYSYS_LOG(WARN,"failed to constrate index operator ,ret = %d",ret);
        }
        else if (OB_SUCCESS!=(ret = index_trigger_upd->set_child(0, *project_op)))
        {
          TRANS_LOG("Failed to set child, err=%d", ret);
        }
        //add by maosy [MultiUps 1.0] [sequence and secondary index ] 20170615 b
        //else if(OB_SUCCESS != (ret = gen_expr_array(update_stmt, index_trigger_upd, row_desc, logical_plan, inner_plan, err_stat)))
        else if(OB_SUCCESS != (ret = gen_expr_array(index_trigger_upd, project_op, err_stat)))
          // add by maosy e
        {
          YYSYS_LOG(WARN, "failed to gen expr_array,ret = %d", ret);
        }
      }
    }
    // add by maosy e
    YYSYS_LOG(DEBUG,"ROW_DESC = %s",to_cstring(row_desc));
    if(OB_LIKELY(OB_SUCCESS == ret)&&update_stmt->get_when_expr_size()<=0)
    {
      if(!is_column_hint_index)
      {
        int64_t index_num = 0;
        if(OB_SUCCESS != (ret = sql_context_->schema_manager_->get_all_modifiable_index_num(table_id, index_num)))
        {
          TRANS_LOG("get all modifiable index_num failed, err=%d", ret);
        }
        else
        {
          project_op->set_index_num(index_num);
          if (OB_SUCCESS != (ret = ups_modify->set_child(0, *project_op)))
          {
            TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
          }
        }
      }
      else
      {
        if (OB_SUCCESS != (ret = ups_modify->set_child(0, *index_trigger_upd)))
        {
          TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
        }
      }
    }
    bool multi_update = false;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      ObPhyOperator* table_op = NULL;
      //add lijianqiang [sequence] 20150909:b
      if (OB_SUCCESS == ret && update_stmt->has_sequence())
      {
        sequence_update_op->set_index_trigger_update(index_trigger_upd, is_column_hint_index);
        //add by maosy [MultiUps 1.0] [secondary index optimize] 20170622 b:
        sequence_update_op->set_out_row_desc_and_row_desc_ext(row_desc, row_desc_ext);
        //add by maosy e
      }
      //add 20150909:e

      if(OB_SUCCESS != (ret = is_multi_delete_update(logical_plan,inner_plan,*rowkey_info,update_stmt,err_stat,multi_update)))
      {
        YYSYS_LOG(WARN,"fail to run the function: is_multi_delete_update in delete statement");
      }
      if(OB_SUCCESS == ret)
      {
        if(!multi_update)//������
        {
          if(!is_column_hint_index)//û�ж�������
          {
            if (OB_SUCCESS != (ret = gen_phy_table_for_update(logical_plan, inner_plan, err_stat,
                                                              update_stmt, table_id, *rowkey_info,
                                                              row_desc, row_desc_ext, table_op,

                                                              sequence_update_op
                                                              //add 20150518:e
                                                              )))
            {
              YYSYS_LOG(WARN,"fail to run the function: gen_phy_table_for_update");
            }
          }
          else
          {
            if (OB_SUCCESS != (ret = gen_phy_table_for_update_v2(logical_plan, inner_plan, err_stat,
                                                                 update_stmt, table_id, *rowkey_info,
                                                                 row_desc, row_desc_ext, table_op
                                                                 //add lijianqiang [sequence update] 20160316:b
                                                                 ,sequence_update_op
                                                                 //add 20160316:e
                                                                 )))
            {
              YYSYS_LOG(WARN,"fail to run the function: gen_phy_table_for_update in update statement");
            }
          }
        }
        else//��������
        {
          //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
          //���ԭ������Ϊrow��action_flag����ǰ�Ǽ������޸ĵģ����Ǿ����޸ĵĲ�̫�ã����Բ�����ʹ�ã�
          //�������ʱ����˵�ɣ�
          if( is_column_hint_index )
          {
            index_trigger_upd->set_data_row_desc(row_desc,true);
          }
          //add by maosy  20170415 e
          if (OB_SUCCESS != (ret = gen_phy_table_for_update_new(logical_plan, inner_plan,physical_plan, err_stat,
                                                                update_stmt, table_id, *rowkey_info,
                                                                row_desc, row_desc_ext, table_op,true,
                                                                //add lijianqiang [sequence] 20150909:b
                                                                sequence_update_op,
                                                                //add 20150909:e
                                                                is_column_hint_index)))

          {
            YYSYS_LOG(WARN,"fail to run the function: gen_phy_table_for_update_new");
          }
          else
          {
            bool need_start_trans =false;
            if( !is_multi_batch_)//���������£����Ҳ���hint
            {
              need_start_trans =true;
            }
            if(index!=NULL && PHY_IUD_LOOP_CONTROL== physical_plan->get_phy_query (*index)->get_type())
            {
              (dynamic_cast<ObIudLoopControl *> (physical_plan->get_phy_query (*index)))->set_need_start_trans (need_start_trans);
            }
            else if( PHY_IUD_LOOP_CONTROL== physical_plan->get_phy_query (0)->get_type())
            {
              (dynamic_cast<ObIudLoopControl *> (physical_plan->get_phy_query (0)))->set_need_start_trans (need_start_trans);
            }
          }
        }
        if (OB_SUCCESS == ret && OB_SUCCESS != (ret = project_op->set_child(0, *table_op)))
        {
          TRANS_LOG("Failed to set child, err=%d", ret);
        }
      }
      //add wenghaixing [secondary index upd.bugfix]20150127
      if(OB_SUCCESS == ret && is_column_hint_index && PHY_FILTER == table_op->get_type())
      {
        index_trigger_upd->set_cond_bool(true);
      }
      //add e
    }
    if (ret == OB_SUCCESS)
    {
      if ((ret = merge_tables_version(*physical_plan, *inner_plan)) != OB_SUCCESS)
      {
        TRANS_LOG("Failed to add base tables version, err=%d", ret);
      }
    }
    //add by maosy [MultiUps 1.0] [hot update and prepare] 20170515 b
    //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20160407:b
    //if (OB_SUCCESS == ret && !IS_SYS_TABLE_ID(table_id))
    if (OB_SUCCESS == ret && !IS_SYS_TABLE_ID(table_id)
        && !multi_update && !update_stmt->has_sequence()
        && ObBasicStmt::T_PREPARE != logical_plan->get_main_stmt()->get_stmt_type()
        && sql_context_->merge_service_->get_config().using_hot_update) //add hongchen [hot_table_update] 20170810
      // add by maosy  20170515 e
    {
      /**
             * FOR UPDATE STMT,there are three plans in MultiUps:
             *   1.the raw physical plan as befor, for normal table.
             *   2.the pre_execution physical plan which will execute in ups without static data,
             *     for hot table and rule changed table.
             *   3.the full row execution physical plan which will be executed when the pre_execution
             *     is failed, for hot table and rule changed table.
             */
      if (OB_SUCCESS != (ret = gen_physical_update_new_pre_execution_plan(
                           logical_plan,
                           physical_plan,
                           update_stmt,
                           table_id,
                           row_desc,
                           row_desc_ext,
                           row_desc_map,
                           rowkey_info,
                           err_stat,
                           query_id
                           //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
                           ,out)))
        //add by maosy e
      {
        TRANS_LOG("gen physical update new pre execution plan failed, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = gen_physical_update_new_full_row_execution_plan(
                                logical_plan,
                                physical_plan,
                                update_stmt,
                                table_id,
                                row_desc,
                                row_desc_ext,
                                row_desc_map,
                                rowkey_info,
                                err_stat,
                                query_id
                                //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
                                ,out)))
        // add by maosy e
      {
        TRANS_LOG("gen physical update new full row execution plan failed, err=%d", ret);
      }
    }
    //add 20160407:e
  }
  return ret;
}

//add by maosy [MultiUps 1.0] [sequence and secondary index ] 20170615 b
int ObTransformer::gen_expr_array(ObIndexTriggerUpd *index_trigger_upd, ObProject *project, ErrStat &err_stat)
{
  int ret = OB_SUCCESS;
  ObSqlExpression expr;
  ObObj cast_obj;
  uint64_t tid = OB_INVALID_ID;
  uint64_t cid = OB_INVALID_ID;
  // uint64_t column_id = OB_INVALID_ID;
  const ObColumnSchemaV2 *column_schema = NULL;
  if(NULL == project || NULL == index_trigger_upd)
  {
    ret = OB_ERROR;
    YYSYS_LOG(WARN, "update_stmt cannot be NULL");
  }
  else
  {
    int64_t count = project->get_output_column_size();
    for(int64_t index = 0 ; index <count ; index++)
    {
      if(OB_SUCCESS !=(ret =project->get_output_columns().at(index,expr) ))
      {
        YYSYS_LOG(WARN,"failed to get expr ,ret = %d,index = %ld",ret ,index);
      }
      else if(OB_SUCCESS !=(ret = index_trigger_upd->add_set_column(expr)))
      {
        YYSYS_LOG(WARN,"failed to get expr ,ret = %d,index = %ld",ret ,index);
      }
      else
      {
        tid = expr.get_table_id();
        cid = expr.get_column_id();
        if (NULL == (column_schema = sql_context_->schema_manager_->get_column_schema(tid, cid)))
        {
          ret = OB_ERR_COLUMN_NOT_FOUND;
          TRANS_LOG("Get column item failed");
          break;
        }
        else
        {
          cast_obj.set_type(column_schema->get_type());
          cast_obj.set_precision(column_schema->get_precision());
          cast_obj.set_scale(column_schema->get_scale());
          if(OB_SUCCESS != (ret = index_trigger_upd->add_cast_obj(cast_obj)))
          {
            TRANS_LOG("fail to add cast obj to update operator, ret[%d]", ret);
            break;
          }
        }
      }
    }//end for
  }
  return ret ;
}
// add by e
int ObTransformer::gen_expr_array(ObUpdateStmt *update_stmt, ObIndexTriggerUpd *index_trigger_upd, const ObRowDesc &row_desc,
                                  ObLogicalPlan *logical_plan,ObPhysicalPlan* inner_plan,ErrStat& err_stat)
{
  int ret = OB_SUCCESS;
  ObSqlExpression expr;
  ObObj cast_obj;
  uint64_t tid = OB_INVALID_ID;
  uint64_t cid = OB_INVALID_ID;
  // uint64_t column_id = OB_INVALID_ID;
  const ObColumnSchemaV2 *column_schema = NULL;
  if(NULL == update_stmt || NULL == index_trigger_upd)
  {
    ret = OB_ERROR;
    YYSYS_LOG(WARN, "update_stmt cannot be NULL");
  }
  if(OB_SUCCESS == ret)
  {
    for (int64_t i = 0; i < row_desc.get_rowkey_cell_count(); ++i)
    {
      if (OB_SUCCESS != (ret = row_desc.get_tid_cid(i, tid, cid)))
      {
        TRANS_LOG("Failed to get tid cid");
        break;
      }
      else
      {
        ObBinaryRefRawExpr col_raw_ref(tid, cid, T_REF_COLUMN);
        expr.reset();
        expr.set_tid_cid(tid, cid);
        ObSqlRawExpr col_ref(0, tid, cid, &col_raw_ref);
        if (OB_SUCCESS != (ret = col_ref.fill_sql_expression(expr, this, logical_plan, inner_plan)))
        {
          TRANS_LOG("Failed to fill expression, err=%d", ret);
          break;
        }
        else if (OB_SUCCESS != (ret = index_trigger_upd->add_set_column(expr)))
        {
          TRANS_LOG("Failed to add output column");
          break;
        }
      }
      if(OB_SUCCESS == ret)
      {
        if (NULL == (column_schema = sql_context_->schema_manager_->get_column_schema(tid, cid)))
        {
          ret = OB_ERR_COLUMN_NOT_FOUND;
          TRANS_LOG("Get column item failed");
          break;
        }
        else
        {
          expr.set_tid_cid(tid, cid);
          cast_obj.set_type(column_schema->get_type());
          cast_obj.set_precision(column_schema->get_precision());
          cast_obj.set_scale(column_schema->get_scale());
          // add <column_id, expression> to project operator
          if(OB_SUCCESS != (ret = index_trigger_upd->add_cast_obj(cast_obj)))
          {
            TRANS_LOG("fail to add cast obj to update operator, ret[%d]", ret);
            break;
          }
        }
      }
    }
  }
  //add lijianqiang [set_row_key_ignore] 20151020:b
  const ObTableSchema *table_schema = NULL;
  const ObRowkeyInfo *row_key_info = NULL;
  if (OB_SUCCESS == ret)
  {
    if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(tid)))
    {
      ret = OB_SCHEMA_ERROR;
      TRANS_LOG("fail to get table schema");
    }
    else if (NULL == (row_key_info = &(table_schema->get_rowkey_info())))
    {
      ret = OB_ERR_UNEXPECTED;
      TRANS_LOG("fail to get row key info");
    }
  };
  //add 20151020:e
  if(OB_SUCCESS == ret)
  {
    const ObColumnSchemaV2 *column_schema = NULL;
    uint64_t expr_id = OB_INVALID_ID;
    ObSqlRawExpr *raw_expr = NULL;

    for (int64_t column_idx = 0; column_idx < update_stmt->get_update_column_count(); column_idx++)
    {
      expr.reset();
      uint64_t column_id = OB_INVALID_ID;
      if (OB_SUCCESS != (ret = update_stmt->get_update_column_id(column_idx, column_id)))
      {
        TRANS_LOG("fail to get update column id for table %lu column_idx=%lu", tid, column_idx);
        break;
      }
      //add lijianqiang [set_row_key_ignore] 20151020:b
      /*Exp: if is row key here, skip*/

      else if (row_key_info->is_rowkey_column(column_id))
      {
        continue;
      }

      //add 20151020:e
      else if (NULL == (column_schema = sql_context_->schema_manager_->get_column_schema(tid, column_id)))
      {
        ret = OB_ERR_COLUMN_NOT_FOUND;
        TRANS_LOG("Get column item failed");
        break;
      }
      // get expression
      else if (OB_SUCCESS != (ret = update_stmt->get_update_expr_id(column_idx, expr_id)))
      {
        YYSYS_LOG(WARN, "fail to get update expr for table %lu column %lu. column_idx=%ld", tid, column_id, column_idx);
        break;
      }
      else if (NULL == (raw_expr = logical_plan->get_expr(expr_id)))
      {
        YYSYS_LOG(WARN, "fail to get expr from logical plan for table %lu column %lu. column_idx=%ld", tid, column_id, column_idx);
        ret = OB_ERR_UNEXPECTED;
        break;
      }
      else if (OB_SUCCESS != (ret = raw_expr->fill_sql_expression(expr, this, logical_plan, inner_plan)))
      {
        YYSYS_LOG(WARN, "fail to fill sql expression. ret=%d", ret);
        break;
      }
      else if(NULL != index_trigger_upd)
      {
        expr.set_tid_cid(tid, column_id);
        cast_obj.set_type(column_schema->get_type());
        cast_obj.set_precision(column_schema->get_precision());
        cast_obj.set_scale(column_schema->get_scale());
        // add <column_id, expression> to project operator
        if (OB_SUCCESS != (ret = index_trigger_upd->add_set_column(expr)))
        {
          TRANS_LOG("fail to add update expr to update operator,ret [%d]", ret);
          break;
        }
        else if(OB_SUCCESS != (ret = index_trigger_upd->add_cast_obj(cast_obj)))
        {
          TRANS_LOG("fail to add cast obj to update operator, ret[%d]", ret);
          break;
        }
      }
    }
  }
  return ret;
}

int ObTransformer::gen_physical_delete_new(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan* physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index
    ,ObUpdateRowkey *op_update_rowkey
    )
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  OB_ASSERT(logical_plan);
  OB_ASSERT(physical_plan);
  ObDeleteStmt *delete_stmt = NULL;
  ObUpsModifyWithDmlType *ups_modify = NULL;
  ObProject *project_op = NULL;
  uint64_t table_id = OB_INVALID_ID;
  const ObRowkeyInfo *rowkey_info = NULL;
  ObRowDesc row_desc;
  ObRowDescExt row_desc_ext;
  ObSEArray<int64_t, 64> row_desc_map;
  ObPhysicalPlan* inner_plan = NULL;
  //add liumengzhan_delete_index
  ObDeleteIndex *delete_index_op = NULL;
  bool is_need_modify_index = false;
  uint64_t index_tid_array[OB_MAX_INDEX_NUMS];
  uint64_t index_array_count = 0;
  //add:e
  bool is_update_rowkey = false;
  ObUpdateStmt *update_stmt = NULL;
  UpsExecutorType ups_executor_type = DELETE_OLD_ROWS;
  if (op_update_rowkey != NULL)
  {
    is_update_rowkey  = true;
  }
  //add gaojt [Delete_Update_Function] [JHOBv0.1] 20160302:b
  bool is_delete_update = true;
  if (is_update_rowkey)
  {
    if (OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, update_stmt)))
    {
    }
    else if (update_stmt->get_is_update_multi_batch())
    {
      is_multi_batch_ = true;
    }
  }
  else
  {
    if (OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, delete_stmt)))
    {
    }
    else if(delete_stmt->get_is_detete_multi_batch())
    {
      YYSYS_LOG(DEBUG,"is multi-delete_update");
      is_multi_batch_ = true;
    }
  }
  if(OB_SUCCESS != ret)
  {

  }
  else if (is_update_rowkey)
  {
    if (OB_SUCCESS != (ret = wrap_update_rowkey_ups_executor(physical_plan, query_id, inner_plan, op_update_rowkey, ups_executor_type,err_stat)))
    {
      YYSYS_LOG(WARN, "failed to wrap_update_rowkey_ups_executor, err=%d",ret);
    }
  }
  //add gaojt 20160302:e
  //mod gaojt [Delete_Update_Function] [JHOBv0.1] 20160302:b
  else if (OB_SUCCESS != (ret = wrap_ups_executor(physical_plan, query_id, inner_plan, index, err_stat,is_delete_update)))
  {
    YYSYS_LOG(WARN, "err=%d", ret);
  }
  //  else if (OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, update_stmt)))
  //  {
  //  }
  table_id = is_update_rowkey ? (update_stmt->get_update_table_id()) : (delete_stmt->get_delete_table_id());
  physical_plan->set_table_id(table_id);
  if (OB_SUCCESS != ret)
  {
  }
  //mod gaojt 20160302:e
  /* generate root operator */
  else if (NULL == CREATE_PHY_OPERRATOR(ups_modify, ObUpsModifyWithDmlType, inner_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator");
  }
  else if (OB_SUCCESS != (ret = inner_plan->add_phy_query(
                            ups_modify,
                            physical_plan == inner_plan ? index : NULL,
                            physical_plan != inner_plan)))
  {
    TRANS_LOG("Add ups_modify operator failed");
  }
  else if (NULL == CREATE_PHY_OPERRATOR(project_op, ObProject, inner_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator");
  }
  if (is_update_rowkey)
  {
    if (OB_SUCCESS != (ret = cons_row_desc(table_id, update_stmt, row_desc_ext, row_desc, rowkey_info, row_desc_map, err_stat)))
    {
    }
    else
    {
      ups_modify->set_dml_type(OB_DML_DELETE);
      inner_plan->set_table_id(table_id);
      inner_plan->set_stmt_type(ObBasicStmt::T_DELETE);
    }
  }
  else if (OB_SUCCESS != (ret = cons_row_desc(delete_stmt->get_delete_table_id(), delete_stmt,
                                              row_desc_ext, row_desc, rowkey_info, row_desc_map, err_stat)))
  {
  }
  else
  {
    //table_id = delete_stmt->get_delete_table_id();
    ups_modify->set_dml_type(OB_DML_DELETE);
    //add shili [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20150721:b
    //����table_id  stmt_type �������ƻ�ִ�е�ʱ��ʹ��
    inner_plan->set_table_id(table_id);
    inner_plan->set_stmt_type(ObBasicStmt::T_DELETE);
    //add 20150721:e
  }
  //add liumengzhan_delete_index
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    is_need_modify_index = sql_context_->schema_manager_->is_have_modifiable_index(table_id);
  }
  //add:e
  ObWhenFilter *when_filter_op = NULL;
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    //if (delete_stmt->get_when_expr_size() > 0)
    if (is_update_rowkey ? (update_stmt->get_when_expr_size() > 0) : (delete_stmt->get_when_expr_size() > 0))
    {
      if (is_need_modify_index)
      {
        if (NULL == CREATE_PHY_OPERRATOR(delete_index_op, ObDeleteIndex, inner_plan, err_stat))
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
          TRANS_LOG("Failed to create physical operator: ObDeleteIndex");
        }
        else if ((ret = gen_phy_when(logical_plan,
                                     inner_plan,
                                     err_stat,
                                     query_id,
                                     *project_op,
                                     when_filter_op
                                     )) != OB_SUCCESS)
        {}
        else if (OB_SUCCESS != (ret = delete_index_op->set_child(0, *when_filter_op)))
        {
          TRANS_LOG("Set child of ObDelteIndex operator failed, err=%d", ret);
        }
        else if ((ret = ups_modify->set_child(0, *delete_index_op)) != OB_SUCCESS)
        {
          TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
        }
      }
      else
      {
        if ((ret = gen_phy_when(logical_plan,
                                inner_plan,
                                err_stat,
                                query_id,
                                *project_op,
                                when_filter_op
                                )) != OB_SUCCESS)
        {
        }
        else if ((ret = ups_modify->set_child(0, *when_filter_op)) != OB_SUCCESS)
        {
          TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
        }
      }
    }
    //add liumengzhan_delete_index
    else if (is_need_modify_index)
    {
      if (NULL == CREATE_PHY_OPERRATOR(delete_index_op, ObDeleteIndex, inner_plan, err_stat))
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        TRANS_LOG("Failed to create phy operator: ObDeleteIndex");
      }
      else if (OB_SUCCESS != (ret = ups_modify->set_child(0, *delete_index_op)))
      {
        TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = delete_index_op->set_child(0, *project_op)))
      {
        TRANS_LOG("Set child of ObDeleteIndex operator failed, err=%d", ret);
      }
    }
    //add:e
    else if (OB_SUCCESS != (ret = ups_modify->set_child(0, *project_op)))
    {
      TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
    }
  }
  ObSqlExpression expr;
  // fill rowkey columns into the Project op
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    uint64_t tid = OB_INVALID_ID;
    uint64_t cid = OB_INVALID_ID;
    for (int64_t i = 0; i < row_desc.get_rowkey_cell_count(); ++i)
    {
      if (OB_SUCCESS != (ret = row_desc.get_tid_cid(i, tid, cid)))
      {
        TRANS_LOG("Failed to get tid cid");
        break;
      }
      else
      {
        ObBinaryRefRawExpr col_raw_ref(tid, cid, T_REF_COLUMN);
        expr.reset();
        ObSqlRawExpr col_ref(OB_INVALID_ID, tid, cid, &col_raw_ref);
        if (OB_SUCCESS != (ret = col_ref.fill_sql_expression(expr, this, logical_plan, inner_plan)))
        {
          TRANS_LOG("Failed to fill expression, err=%d", ret);
          break;
        }
        else if (OB_SUCCESS != (ret = project_op->add_output_column(expr)))
        {
          TRANS_LOG("Failed to add output column");
          break;
        }
      }
    }
    //add liumengzhan_delete_index
    //fill index table rowkey columns into the Project op
    if (OB_LIKELY(OB_SUCCESS == ret) && is_need_modify_index)
    {
      if (OB_SUCCESS != (ret = sql_context_->schema_manager_->get_all_modifiable_index_tid(table_id, index_tid_array, index_array_count)))
      {
        TRANS_LOG("fail to get index table array for table[%ld]", table_id);
      }
      else
      {
        for (uint64_t i=0; i<index_array_count && OB_LIKELY(OB_SUCCESS == ret); i++)
        {
          uint64_t index_cid = OB_INVALID_ID;
          uint64_t index_tid = index_tid_array[i];
          const ObTableSchema *index_table_schema = sql_context_->schema_manager_->get_table_schema(index_tid);
          if (NULL == index_table_schema)
          {
            ret = OB_SCHEMA_ERROR;
            TRANS_LOG("Failed to get index table schema, tid=%ld, ret=%d", index_tid, ret);
            break;
          }
          const ObRowkeyInfo &index_rowkey_info = index_table_schema->get_rowkey_info();
          for (int64_t j=0; j<index_rowkey_info.get_size(); j++)
          {
            if (OB_SUCCESS != (ret = index_rowkey_info.get_column_id(j, index_cid)))
            {
              TRANS_LOG("Failed to get index column id, err=%d", ret);
              break;
            }
            else if (!rowkey_info->is_rowkey_column(index_cid) && !project_op->is_duplicated_output_column(index_cid))
            {
              ObBinaryRefRawExpr col_raw_ref(table_id, index_cid, T_REF_COLUMN);
              expr.reset();
              ObSqlRawExpr col_ref(OB_INVALID_ID, table_id, index_cid, &col_raw_ref);
              if (OB_SUCCESS != (ret = col_ref.fill_sql_expression(expr, this, logical_plan, inner_plan)))
              {
                TRANS_LOG("Failed to fill expression, err=%d", ret);
                break;
              }
              else if (OB_SUCCESS != (ret = project_op->add_output_column(expr)))
              {
                TRANS_LOG("Failed to add output column, err=%d", ret);
                break;
              }
            }
          }//end for
        }//end for
      }
    }
    //add:e
    // add ObActionFlag::OB_DEL_ROW cell
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      ObObj del_row;
      del_row.set_int(ObActionFlag::OP_DEL_ROW);
      ObConstRawExpr const_expr(del_row, T_INT);
      expr.reset();
      ObSqlRawExpr const_del(OB_INVALID_ID, table_id, OB_ACTION_FLAG_COLUMN_ID, &const_expr);
      if (OB_SUCCESS != (ret = const_del.fill_sql_expression(expr, this, logical_plan, inner_plan)))
      {
        TRANS_LOG("Failed to fill expression, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = project_op->add_output_column(expr)))
      {
        TRANS_LOG("Failed to add output column");
      }
    }
  }
  //add liumengzhan_delete_index
  if (OB_LIKELY(OB_SUCCESS == ret)&&is_need_modify_index)
  {
    ObRowDesc desc_for_whole_row;
    ObRowDescExt desc_ext_whole_row;
    if (is_update_rowkey)
    {
      if (OB_SUCCESS != (ret = cons_del_upd_row_desc(update_stmt, table_id, desc_for_whole_row, desc_ext_whole_row)))
      {
        TRANS_LOG("cons whole row desc error, err=%d", ret);
        ret = OB_INVALID_ARGUMENT;
      }
      else
      {
        row_desc = desc_for_whole_row;
        row_desc_ext = desc_ext_whole_row;
      }
    }
    else
      if(OB_SUCCESS != (ret = cons_del_upd_row_desc(delete_stmt, table_id, desc_for_whole_row, desc_ext_whole_row)))
      {
        TRANS_LOG("cons whole row desc error, err=%d", ret);
        ret = OB_INVALID_ARGUMENT;
      }
      else
      {
        row_desc = desc_for_whole_row;
        row_desc_ext = desc_ext_whole_row;

      }
  }
  //add:e
  //add lijianqiang [sequence delete] 20150515:b
  ObSequenceDelete * sequence_delete = NULL;
  if (is_update_rowkey)
  {

  }
  else
    if (delete_stmt->has_sequence())
    {
      //add shili, [MultiUPS] [merge transaction code]20170309
      physical_plan->set_result_set(result_);
      inner_plan->set_result_set(result_);
      //add e
      // 1.ObSequenceDelete
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        CREATE_PHY_OPERRATOR(sequence_delete, ObSequenceDelete, inner_plan, err_stat);
      }
      if (OB_SUCCESS != ret)//add qianzm [null operator unjudgement bug1181] 20160520
      {
      }
      else if (OB_SUCCESS != (ret = wrap_sequence(logical_plan, physical_plan, err_stat,
                                                  row_desc_map, sequence_delete, delete_stmt,
                                                  inner_plan)))
      {
        TRANS_LOG("wrap sequence failed");
      }
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        if (OB_SUCCESS != (ret = sequence_delete->copy_sequence_info_from_delete_stmt()))
        {
          TRANS_LOG("copy sequence info from delete stmt failed!");
        }
      }
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        //get the sequence info from the "__all_sequences"
        if (OB_SUCCESS != (ret = sequence_delete->prepare_sequence_prevval()))
        {
          TRANS_LOG("prepare sequence info failed!");
        }
      }
    }
  //add 20150515:e

  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    ObPhyOperator* table_op = NULL;
    bool multi_delete = false;
    if (is_update_rowkey)
    {
      if(OB_SUCCESS != (ret = is_multi_delete_update(logical_plan,inner_plan,*rowkey_info,update_stmt,err_stat,multi_delete)))
      {
        YYSYS_LOG(WARN,"fail to run the function: is_multi_delete_update in delete statement");
      }
    }
    else
      if(OB_SUCCESS != (ret = is_multi_delete_update(logical_plan,inner_plan,*rowkey_info,delete_stmt,err_stat,multi_delete)))
      {
        YYSYS_LOG(WARN,"fail to run the function: is_multi_delete_update in delete statement");
      }
    if(!multi_delete)
    {
      //add liumengzhan_delete_index
      //change gen_phy_table_for_update to gen_phy_table_for_update_v2
      if(is_need_modify_index)
      {
        if (is_update_rowkey)
        {
          if (OB_SUCCESS != (ret = gen_phy_table_for_update_v2(logical_plan, inner_plan, err_stat,
                                                               update_stmt,
                                                               table_id, *rowkey_info,
                                                               row_desc, row_desc_ext, table_op,
                                                               sequence_delete
                                                               )))
          {
            YYSYS_LOG(WARN, "fail to run the function: gen_phy_table_for_update");
          }
        }
        else
          if (OB_SUCCESS != (ret = gen_phy_table_for_update_v2(logical_plan, inner_plan, err_stat,
                                                               delete_stmt, table_id, *rowkey_info,
                                                               row_desc, row_desc_ext, table_op
                                                               //add lijianqiang [sequence delete] 20160320:b
                                                               ,sequence_delete
                                                               //add 20160320:e
                                                               )))
          {
            YYSYS_LOG(WARN,"fail to run the function: gen_phy_table_for_update");
          }
      }
      else
      {
        if (is_update_rowkey)
        {
          if (OB_SUCCESS != (ret = gen_phy_table_for_update(logical_plan, inner_plan, err_stat,
                                                            update_stmt,
                                                            table_id, *rowkey_info,
                                                            row_desc, row_desc_ext, table_op,
                                                            sequence_delete
                                                            )))
          {
            YYSYS_LOG(WARN, "fail to run the function: gen_phy_table_for_update in delete statement");
          }
        }
        else
          if (OB_SUCCESS != (ret = gen_phy_table_for_update(logical_plan, inner_plan, err_stat,
                                                            delete_stmt, table_id, *rowkey_info,
                                                            row_desc, row_desc_ext, table_op,
                                                            //add lijianqiang [sequence] 20150518:b
                                                            sequence_delete
                                                            //add 20150518:e
                                                            )))
          {
            YYSYS_LOG(WARN,"fail to run the function: gen_phy_table_for_update in delete statement");
          }
      }
    }
    else
    {
      //add gaojt [Delete_Update_Function] [JHOBv0.1] 20160222:b
      /*when the condition satisfys the original request of delete statement,
                       *then call the original fucntion
                       */
      if (is_update_rowkey)
      {
        if (OB_SUCCESS != (ret = gen_phy_table_for_update_new(logical_plan, inner_plan,physical_plan, err_stat,
                                                              update_stmt,
                                                              table_id, *rowkey_info,
                                                              row_desc, row_desc_ext, table_op, true,
                                                              sequence_delete,
                                                              is_need_modify_index)))
        {
          YYSYS_LOG(WARN, "fail to run the function: gen_phy_table_for_update_new");
        }
      }
      else
        if (OB_SUCCESS != (ret = gen_phy_table_for_update_new(logical_plan, inner_plan,physical_plan, err_stat,
                                                              delete_stmt, table_id, *rowkey_info,
                                                              row_desc, row_desc_ext, table_op,true,
                                                              //add lijianqiang [sequence] 20150909:b
                                                              sequence_delete,
                                                              //add 20150909:e
                                                              is_need_modify_index)))

        {
          YYSYS_LOG(WARN,"fail to run the function: gen_phy_table_for_update_new");
        }
    }
    if(OB_SUCCESS == ret)
    {
      if (!is_update_rowkey)
      {
        // add by maosy [Delete_Update_Function_isolation_RC] 20161218
        bool need_start_trans =false;
        if(multi_delete && !is_multi_batch_)
        {
          need_start_trans =true;
        }
        if(index!=NULL && PHY_IUD_LOOP_CONTROL== physical_plan->get_phy_query (*index)->get_type())
        {
          (dynamic_cast<ObIudLoopControl *> (physical_plan->get_phy_query (*index)))->set_need_start_trans (need_start_trans);
        }
        else if( PHY_IUD_LOOP_CONTROL== physical_plan->get_phy_query (0)->get_type())
        {
          (dynamic_cast<ObIudLoopControl *> (physical_plan->get_phy_query (0)))->set_need_start_trans (need_start_trans);
        }
        // add by maosy 20161218
      }
      if (OB_SUCCESS != (ret = project_op->set_child(0, *table_op)))
      {
        TRANS_LOG("Failed to set child, err=%d", ret);
      }
    }
  }

  //add liumengzhan_delete_index
  if (OB_LIKELY(OB_SUCCESS == ret) && is_need_modify_index)
  {
    if (OB_SUCCESS != (ret = delete_index_op->set_input_values(table_id, index_array_count)))
    {
      TRANS_LOG("Failed to set input values for phy operator delete_index_op, err=%d", ret);
    }
    ObRowDesc main_row_desc;
    ObRowDescExt main_row_desc_ext;//not used
    if (OB_LIKELY(OB_SUCCESS == ret)&&OB_SUCCESS != (ret = cons_index_row_desc(table_id, main_row_desc, main_row_desc_ext)))
    {
      TRANS_LOG("Failed to construct main row desc, err=%d", ret);
    }
    else
    {
      delete_index_op->set_row_desc(main_row_desc);
    }
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      ObRowDesc index_row_desc;
      ObRowDescExt index_row_desc_ext;//not used
      for (uint64_t i=0; i<index_array_count; i++)
      {
        index_row_desc.reset();
        index_row_desc_ext.reset();
        uint64_t index_table_id = index_tid_array[i];
        if (OB_SUCCESS != (ret = cons_index_row_desc(index_table_id, index_row_desc, index_row_desc_ext)))
        {
          TRANS_LOG("Failed to construct main row desc, err=%d", ret);
          break;
        }
        else if (OB_SUCCESS != (ret = delete_index_op->add_index_row_desc(i, index_row_desc)))
        {
          TRANS_LOG("Failed to add index row desc, err=%d", ret);
          break;
        }
        else if (OB_SUCCESS != (ret = delete_index_op->add_index_tid(i, index_table_id)))
        {
          TRANS_LOG("Failed to add index table id, err=%d", ret);
          break;
        }
      }
    }
  }
  //add:e
  if (ret == OB_SUCCESS)
  {
    if ((ret = merge_tables_version(*physical_plan, *inner_plan)) != OB_SUCCESS)
    {
      TRANS_LOG("Failed to add base tables version, err=%d", ret);
    }
  }
  return ret;
}

//add liumengzhan_delete_index
int ObTransformer::cons_index_row_desc(uint64_t table_id, ObRowDesc &row_desc, ObRowDescExt &row_desc_ext)
{
  UNUSED(row_desc_ext);
  int ret = OB_SUCCESS;
  uint64_t column_id = OB_INVALID_ID;
  //  ObObj data_type;
  const ObTableSchema *table_schema = sql_context_->schema_manager_->get_table_schema(table_id);
  if (NULL == table_schema)
  {
    ret = OB_SCHEMA_ERROR;
    YYSYS_LOG(ERROR, "Failed to get index table schema, tid=%ld, ret=%d", table_id, ret);
  }
  else
  {
    const ObRowkeyInfo rowkey_info = table_schema->get_rowkey_info();
    int64_t rowkey_size = rowkey_info.get_size();
    row_desc.set_rowkey_cell_count(rowkey_size);
    for (int64_t i=0; i<rowkey_size; i++)
    {
      //      const ObColumnSchemaV2 *column_schema = NULL;
      if (OB_SUCCESS != (ret = rowkey_info.get_column_id(i, column_id)))
      {
        YYSYS_LOG(ERROR, "Failed to get column id, ret=%d", ret);
        break;
      }
      else if (OB_SUCCESS != (ret = row_desc.add_column_desc(table_id, column_id)))
      {
        YYSYS_LOG(ERROR, "Failed to add column desc, ret=%d", ret);
        break;
      }
      //      else if (NULL == (column_schema = sql_context_->schema_manager_->get_column_schema(table_id, column_id)))
      //      {
      //        YYSYS_LOG(ERROR, "Failed to get column schema, ret=%d", ret);
      //        break;
      //      }
      //      else
      //      {
      //        data_type.set_type(column_schema->get_type());
      //        data_type.set_precision(column_schema->get_precision());
      //        data_type.set_scale(column_schema->get_scale());
      //        if (OB_SUCCESS != (ret = row_desc_ext.add_column_desc(table_id, column_id, data_type)))
      //        {
      //          YYSYS_LOG(ERROR, "Failed to add column desc ext, ret=%d", ret);
      //          break;
      //        }
      //      }
    }//end for
    //add ObActionFlag: OP_DEL_ROW
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      if (OB_SUCCESS != (ret = row_desc.add_column_desc(table_id, OB_ACTION_FLAG_COLUMN_ID)))
      {
        YYSYS_LOG(ERROR, "Failed to add column desc, ret=%d", ret);
      }
      //      else
      //      {
      //        data_type.set_type(ObIntType);
      //        if (OB_SUCCESS != (ret = row_desc_ext.add_column_desc(table_id, OB_ACTION_FLAG_COLUMN_ID, data_type)))
      //        {
      //          YYSYS_LOG(ERROR, "Failed to add column desc ext, ret=%d", ret);
      //        }
      //      }
    }//end if
  }
  return ret;
}
//add e

int ObTransformer::gen_physical_start_trans(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan* physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  OB_ASSERT(logical_plan);
  OB_ASSERT(physical_plan);
  ObStartTransStmt *stmt = NULL;
  ObStartTrans *start_trans = NULL;
  if (OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, stmt)))
  {
  }
  /* generate root operator */
  else if (NULL == CREATE_PHY_OPERRATOR(start_trans, ObStartTrans, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator");
  }
  else if (OB_SUCCESS != (ret = add_phy_query(logical_plan, physical_plan, err_stat,
                                              query_id, stmt, start_trans, index)))
  {
    TRANS_LOG("Add ups_modify operator failed");
  }
  else
  {
    start_trans->set_rpc_stub(sql_context_->merger_rpc_proxy_);
    start_trans->set_trans_param(stmt->get_with_consistent_snapshot()?READ_ONLY_TRANS:READ_WRITE_TRANS);
  }
  return ret;
}

int ObTransformer::gen_physical_priv_stmt(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan* physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  OB_ASSERT(logical_plan);
  OB_ASSERT(physical_plan);
  ObBasicStmt * stmt = NULL;
  ObPrivExecutor *priv_executor = NULL;
  if (OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, stmt)))
  {
  }
  /* generate root operator */
  else if (NULL == CREATE_PHY_OPERRATOR(priv_executor, ObPrivExecutor, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator");
  }
  else if (OB_SUCCESS != (ret = add_phy_query(logical_plan, physical_plan, err_stat,
                                              query_id, stmt, priv_executor, index)))
  {
    TRANS_LOG("Add create user operator failed");
  }
  else
  {
    ObBasicStmt * basic_stmt = NULL;
    if (stmt->get_stmt_type() == ObBasicStmt::T_CREATE_USER)
    {
      void *ptr = trans_malloc(sizeof(ObCreateUserStmt));
      if (ptr == NULL)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR, "malloc ObCreateUserStmt in transform mem pool failed, ret=%d", ret);
      }
      else
      {
        basic_stmt = new (ptr) ObCreateUserStmt(*(dynamic_cast<ObCreateUserStmt*>(stmt)));
      }
    }
    else if (stmt->get_stmt_type() == ObBasicStmt::T_DROP_USER)
    {
      void *ptr = trans_malloc(sizeof(ObDropUserStmt));
      if (ptr == NULL)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR, "malloc ObDropUserStmt in transform mem pool failed, ret=%d", ret);
      }
      else
      {
        basic_stmt = new (ptr) ObDropUserStmt(*(dynamic_cast<ObDropUserStmt*>(stmt)));
      }
    }
    else if (stmt->get_stmt_type() == ObBasicStmt::T_GRANT)
    {
      void *ptr = trans_malloc(sizeof(ObGrantStmt));
      if (ptr == NULL)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR, "malloc ObGrantStmt in transform mem pool failed, ret=%d", ret);
      }
      else
      {
        basic_stmt = new (ptr) ObGrantStmt(*(dynamic_cast<ObGrantStmt*>(stmt)));
      }
    }
    else if (stmt->get_stmt_type() == ObBasicStmt::T_REVOKE)
    {
      void *ptr = trans_malloc(sizeof(ObRevokeStmt));
      if (ptr == NULL)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR, "malloc ObRevokeStmt in transform mem pool failed, ret=%d", ret);
      }
      else
      {
        basic_stmt = new (ptr) ObRevokeStmt(*(dynamic_cast<ObRevokeStmt*>(stmt)));
      }
    }
    else if (stmt->get_stmt_type() == ObBasicStmt::T_RENAME_USER)
    {
      void *ptr = trans_malloc(sizeof(ObRenameUserStmt));
      if (ptr == NULL)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR, "malloc ObRenameUserStmt in transform mem pool failed, ret=%d", ret);
      }
      else
      {
        basic_stmt = new (ptr) ObRenameUserStmt(*(dynamic_cast<ObRenameUserStmt*>(stmt)));
      }
    }
    else if (stmt->get_stmt_type() == ObBasicStmt::T_SET_PASSWORD)
    {
      void *ptr = trans_malloc(sizeof(ObSetPasswordStmt));
      if (ptr == NULL)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR, "malloc ObSetPasswordStmt in transform mem pool failed, ret=%d", ret);
      }
      else
      {
        basic_stmt = new (ptr) ObSetPasswordStmt(*(dynamic_cast<ObSetPasswordStmt*>(stmt)));
      }
    }
    else if (stmt->get_stmt_type() == ObBasicStmt::T_LOCK_USER)
    {
      void *ptr = trans_malloc(sizeof(ObLockUserStmt));
      if (ptr == NULL)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR, "malloc ObGrantStmt in transform mem pool failed, ret=%d", ret);
      }
      else
      {
        basic_stmt = new (ptr) ObLockUserStmt(*(dynamic_cast<ObLockUserStmt*>(stmt)));
      }
    }
    //add wenghaixing [database manage]20150609
    else if (stmt->get_stmt_type() == ObBasicStmt::T_CREATE_DATABASE)
    {
      void *ptr = trans_malloc(sizeof(ObCreateDbStmt));
      if(NULL == ptr)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR, "malloc ObCreateDbStatement in transform mem pool failed, ret=%d", ret);
      }
      else
      {
        basic_stmt = new (ptr) ObCreateDbStmt(*(dynamic_cast<ObCreateDbStmt*>(stmt)));
      }
    }
    else if (stmt->get_stmt_type() == ObBasicStmt::T_USE_DATABASE)
    {
      void *ptr = trans_malloc(sizeof(ObUseDbStmt));
      if(NULL == ptr)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR, "malloc ObUseDbStatement in transform mem pool failed, ret=%d", ret);
      }
      else
      {
        basic_stmt = new (ptr) ObUseDbStmt(*(dynamic_cast<ObUseDbStmt*>(stmt)));
      }
    }
    else if(stmt->get_stmt_type() == ObBasicStmt::T_DROP_DATABASE)
    {
      void *ptr = trans_malloc(sizeof(ObDropDbStmt));
      if(NULL == ptr)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR, "malloc ObDropDbStatement in transform mem pool failed, ret=%d", ret);
      }
      else
      {
        basic_stmt = new (ptr) ObDropDbStmt(*(dynamic_cast<ObDropDbStmt*>(stmt)));
      }
    }
    //add e
    priv_executor->set_stmt(basic_stmt);
    priv_executor->set_context(sql_context_);
  }
  return ret;
}

int ObTransformer::gen_physical_change_obi_stmt(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan* physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObChangeObiStmt *change_obi_stmt = NULL;
  ObChangeObi *change_obi = NULL;
  if (OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, change_obi_stmt)))
  {
  }
  else
  {
    CREATE_PHY_OPERRATOR(change_obi, ObChangeObi, physical_plan, err_stat);
    if (OB_SUCCESS == ret)
    {
      ObString target_server_addr;
      change_obi_stmt->get_target_server_addr(target_server_addr);
      change_obi->set_force(change_obi_stmt->get_force());
      change_obi->set_target_role(change_obi_stmt->get_target_role());
      if (OB_SUCCESS != (ret = change_obi->set_target_server_addr(target_server_addr)))
      {
      }
      else if (OB_SUCCESS != (ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, change_obi_stmt, change_obi, index)))
      {
        YYSYS_LOG(WARN, "add_phy_query failed, ret=%d", ret);
      }
      else
      {
        ObObj old_ob_query_timeout;
        ObObj change_obi_timeout_value;
        change_obi_timeout_value.set_int(mergeserver::ObMergeServerMain::get_instance()->get_merge_server().get_config().change_obi_timeout);
        ObString ob_query_timeout = ObString::make_string(OB_QUERY_TIMEOUT_PARAM);
        if (OB_SUCCESS != (ret = sql_context_->session_info_->get_sys_variable_value(ob_query_timeout, old_ob_query_timeout)))
        {
          YYSYS_LOG(WARN, "get old session timeout value failed, ret=%d", ret);
        }
        else if (OB_SUCCESS != (ret = change_obi->set_change_obi_timeout(change_obi_timeout_value)))
        {
          YYSYS_LOG(ERROR, "set change obi timeout failed, ret=%d", ret);
        }
        else
        {
          change_obi->set_check_ups_log_interval(static_cast<int>(mergeserver::ObMergeServerMain::get_instance()->get_merge_server().get_config().check_ups_log_interval));
          change_obi->set_old_ob_query_timeout(old_ob_query_timeout);
          change_obi->set_context(sql_context_);
        }
      }

    }
  }
  return ret;
}
int ObTransformer::gen_physical_kill_stmt(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan* physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObKillStmt *kill_stmt = NULL;
  ObKillSession *kill_op = NULL;

  /* get statement */
  if (ret == OB_SUCCESS)
  {
    get_stmt(logical_plan, err_stat, query_id, kill_stmt);
  }
  /* generate operator */
  if (ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(kill_op, ObKillSession, physical_plan, err_stat);
    if (ret == OB_SUCCESS)
    {
      kill_op->set_rpc_stub(sql_context_->merger_rpc_proxy_);
      kill_op->set_session_mgr(sql_context_->session_mgr_);
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, kill_stmt, kill_op, index);
    }
  }

  if (ret == OB_SUCCESS)
  {
    kill_op->set_session_id(kill_stmt->get_thread_id());
    kill_op->set_is_query(kill_stmt->is_query());
    kill_op->set_is_global(kill_stmt->is_global());
  }

  return ret;
}

int ObTransformer::gen_physical_end_trans(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan* physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  OB_ASSERT(logical_plan);
  OB_ASSERT(physical_plan);
  ObEndTransStmt *stmt = NULL;
  ObEndTrans *end_trans = NULL;
  if (OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, stmt)))
  {
  }
  /* generate root operator */
  else if (NULL == CREATE_PHY_OPERRATOR(end_trans, ObEndTrans, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator");
  }
  else if (OB_SUCCESS != (ret = add_phy_query(logical_plan, physical_plan, err_stat,
                                              query_id, stmt, end_trans, index)))
  {
    TRANS_LOG("Add ups_modify operator failed");
  }
  else
  {
    end_trans->set_rpc_stub(sql_context_->merger_rpc_proxy_);
    end_trans->set_trans_param(sql_context_->session_info_->get_trans_id(), stmt->get_is_rollback());
  }
  return ret;
}

int ObTransformer::gen_phy_select_for_update(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObSelectStmt *select_stmt = NULL;
  ObPhyOperator *result_op = NULL;
  //ObLockFilter *lock_op = NULL;
  ObProject *project_op = NULL;
  uint64_t table_id = OB_INVALID_ID;
  const ObRowkeyInfo *rowkey_info = NULL;
  ObPhysicalPlan *inner_plan = NULL;
  ObRowDesc row_desc;
  ObRowDescExt row_desc_ext;
  ObSEArray<int64_t, 64> row_desc_map;
  //add liuzy [sequence select for update] 20150918:b
  ObSequenceSelect *sequence_select_op = NULL;
  //add 20150918:e

  if ((ret = get_stmt(logical_plan, err_stat, query_id, select_stmt)) != OB_SUCCESS)
  {
  }
  else if (!select_stmt->is_for_update()
           || select_stmt->get_from_item_size() > 1
           || select_stmt->get_table_size() > 1
           || (select_stmt->get_table_size() > 0
               && select_stmt->get_table_item(0).type_ != TableItem::BASE_TABLE
               && select_stmt->get_table_item(0).type_ != TableItem::ALIAS_TABLE
               )
           || select_stmt->get_group_expr_size() > 0
           || select_stmt->get_agg_fun_size() > 0
           || select_stmt->get_order_item_size() > 0
           || select_stmt->has_limit())
  {
    ret = OB_NOT_SUPPORTED;
    TRANS_LOG("This select statement is not allowed by implement");
  }
  else if ((ret = wrap_ups_executor(physical_plan, query_id, inner_plan, index, err_stat)) != OB_SUCCESS)
  {
    YYSYS_LOG(WARN, "err=%d", ret);
  }
  else
  {
    //add shili, [MultiUPS] [merge transaction code]20170309
    physical_plan->set_result_set(result_);
    inner_plan->set_result_set(result_);
    //add e
  }

  if(OB_SUCCESS!=ret)
  {}
  else if (CREATE_PHY_OPERRATOR(project_op, ObProject, inner_plan, err_stat) == NULL)
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator");
  }
  //add liuzy [sequence select for update] 20150918:b
  else if (select_stmt->has_sequence()
           && CREATE_PHY_OPERRATOR(sequence_select_op, ObSequenceSelect, physical_plan, err_stat) == NULL)
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator");
  }
  else if (select_stmt->has_sequence()
           && OB_SUCCESS != (ret = wrap_sequence(logical_plan, physical_plan, err_stat,
                                                 row_desc_map, sequence_select_op, select_stmt)))
  {
    TRANS_LOG("wrap sequence failed");
  }
  else if (select_stmt->has_sequence()
           && OB_SUCCESS != (ret = sequence_select_op->prepare_sequence_prevval()))
  {
    TRANS_LOG("prepare sequence info failed!");
  }
  //add 20150918:e
  else if ((ret = inner_plan->add_phy_query(
              project_op,
              physical_plan == inner_plan ? index : NULL,
              physical_plan != inner_plan)))

  {
    TRANS_LOG("Add top operator failed");
  }
  /* select ... from DUAL */
  else if (select_stmt->get_table_size() == 0)
  {
    if (CREATE_PHY_OPERRATOR(result_op, ObDualTableScan, inner_plan, err_stat) == NULL)
    {
      TRANS_LOG("Generate dual table operator failed, ret=%d", ret);
    }
  }
  else
  {
    //add liuzy [sequence select for update] 20150921:b
    if (NULL != sequence_select_op)
    {
      sequence_select_op->copy_sequence_info_from_select_stmt(select_stmt);
      sequence_select_op->set_for_update(select_stmt->is_for_update());
      if (select_stmt->select_clause_has_sequence())
      {
        sequence_select_op->set_project_op(project_op->get_id());
      }
    }
    //add 2050921:e
    table_id = select_stmt->get_table_item(0).table_id_;
    if ((ret = cons_row_desc(table_id,
                             select_stmt,
                             row_desc_ext,
                             row_desc,
                             rowkey_info,
                             row_desc_map, err_stat)) != OB_SUCCESS)
    {
    }
    else
    {
      //lock_op->set_write_lock_flag();
    }
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      if ((ret = gen_phy_table_for_update(logical_plan,inner_plan, err_stat,
                                          select_stmt, table_id, *rowkey_info,
                                          row_desc, row_desc_ext, result_op, sequence_select_op//add liuzy [select for update] 20150918 /*Exp: add default argument ObSequenceOp*/
                                          )) != OB_SUCCESS)
      {
      }
      //add shili [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20150717:b
      //����table_id  stmt_type �������ƻ�ִ�е�ʱ��ʹ��
      else
      {
        inner_plan->set_table_id(table_id);
        inner_plan->set_stmt_type(ObBasicStmt::T_SELECT);
      }
      //add 20150717:e
      /*
      else if ((ret = lock_op->set_child(0, *result_op)) != OB_SUCCESS)
      {
        TRANS_LOG("Failed to set child, err=%d", ret);
      }
      else
      {
        result_op = lock_op;
      }
      */
    }
  }
  // add output columns
  for (int32_t i = 0; ret == OB_SUCCESS && i < select_stmt->get_select_item_size(); i++)
  {
    const SelectItem& select_item = select_stmt->get_select_item(i);
    ObSqlExpression output_expr;
    ObSqlRawExpr *expr = NULL;
    if ((expr = logical_plan->get_expr(select_item.expr_id_)) == NULL)
    {
      ret = OB_ERR_ILLEGAL_ID;
      TRANS_LOG("Wrong expression id");
    }
    else if ((ret = expr->fill_sql_expression(
                output_expr,
                this,
                logical_plan,
                inner_plan)) != OB_SUCCESS)
    {
      TRANS_LOG("Generate post-expression faild");
    }
    else if ((ret = project_op->add_output_column(output_expr)) != OB_SUCCESS)
    {
      TRANS_LOG("Add output column to project operator faild");
    }
  }
  // generate physical plan for order by
  if (ret == OB_SUCCESS && select_stmt->get_order_item_size() > 0)
  {
    ret = gen_phy_order_by(logical_plan, inner_plan, err_stat, select_stmt, result_op, result_op);
  }
  // generate physical plan for limit
  if (ret == OB_SUCCESS && select_stmt->has_limit())
  {
    ret = gen_phy_limit(logical_plan, inner_plan, err_stat, select_stmt, result_op, result_op);
  }
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    ObWhenFilter *when_filter_op = NULL;
    if (select_stmt->get_when_expr_size() > 0)
    {
      if ((ret = gen_phy_when(logical_plan,
                              inner_plan,
                              err_stat,
                              query_id,
                              *result_op,
                              when_filter_op
                              )) != OB_SUCCESS)
      {
      }
      else if ((ret = project_op->set_child(0, *when_filter_op)) != OB_SUCCESS)
      {
        TRANS_LOG("Set child of project_op operator failed, err=%d", ret);
      }
    }
    else if ((ret = project_op->set_child(0, *result_op)) != OB_SUCCESS)
    {
      TRANS_LOG("Set child of project_op operator failed, err=%d", ret);
    }
  }
  if (ret == OB_SUCCESS)
  {
    if ((ret = merge_tables_version(*physical_plan, *inner_plan)) != OB_SUCCESS)
    {
      TRANS_LOG("Failed to add base tables version, err=%d", ret);
    }
  }
  return ret;
}

int ObTransformer::gen_physical_alter_system(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    int32_t* index)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObAlterSysCnfStmt *alt_sys_stmt = NULL;
  ObAlterSysCnf     *alt_sys_op = NULL;

  /* get statement */
  if ((get_stmt(logical_plan, err_stat, query_id, alt_sys_stmt)) != OB_SUCCESS)
  {
  }
  /* generate operator */
  else if (CREATE_PHY_OPERRATOR(alt_sys_op, ObAlterSysCnf, physical_plan, err_stat) == NULL)
  {
  }
  else if ((ret = add_phy_query(logical_plan,
                                physical_plan,
                                err_stat,
                                query_id,
                                alt_sys_stmt,
                                alt_sys_op, index)
            ) != OB_SUCCESS)
  {
    TRANS_LOG("Add physical operator failed, err=%d", ret);
  }
  else
  {
    alt_sys_op->set_sql_context(*sql_context_);
    hash::ObHashMap<ObSysCnfItemKey, ObSysCnfItem>::iterator iter;
    for (iter = alt_sys_stmt->sys_cnf_begin(); iter != alt_sys_stmt->sys_cnf_end(); iter++)
    {
      ObSysCnfItem cnf_item = iter->second;
      if ((ret = ob_write_string(*mem_pool_,
                                 iter->second.param_name_,
                                 cnf_item.param_name_)) != OB_SUCCESS)
      {
        TRANS_LOG("Failed to copy param name, err=%d", ret);
        break;
      }
      else if ((ret = ob_write_obj(*mem_pool_,
                                   iter->second.param_value_,
                                   cnf_item.param_value_)) != OB_SUCCESS)
      {
        TRANS_LOG("Failed to copy param value, err=%d", ret);
        break;
      }
      else if ((ret = ob_write_string(*mem_pool_,
                                      iter->second.comment_,
                                      cnf_item.comment_)) != OB_SUCCESS)
      {
        TRANS_LOG("Failed to copy comment, err=%d", ret);
        break;
      }
      else if ((ret = ob_write_string(*mem_pool_,
                                      iter->second.server_ip_,
                                      cnf_item.server_ip_)) != OB_SUCCESS)
      {
        TRANS_LOG("Failed to copy server ip, err=%d", ret);
        break;
      }
      else if ((ret = alt_sys_op->add_sys_cnf_item(cnf_item)) != OB_SUCCESS)
      {
        TRANS_LOG("Failed to add config item, err=%d", ret);
        break;
      }
    }
  }
  return ret;
}

int ObTransformer::gen_phy_show_parameters(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObTableRpcScan *table_op = NULL;
  ObProject *project_op = NULL;
  ObRpcScanHint hint;
  hint.read_method_ = ObSqlReadStrategy::USE_SCAN;
  if (CREATE_PHY_OPERRATOR(table_op, ObTableRpcScan, physical_plan, err_stat) == NULL)
  {
  }
  else if (CREATE_PHY_OPERRATOR(project_op, ObProject, physical_plan, err_stat) == NULL)
  {
  }
  else if ((ret = project_op->set_child(0, *table_op)) != OB_SUCCESS)
  {
    TRANS_LOG("Set child of project failed, ret=%d", ret);
  }
  else if ((ret = table_op->set_table(
              OB_ALL_SYS_CONFIG_STAT_TID,
              OB_ALL_SYS_CONFIG_STAT_TID)
            ) != OB_SUCCESS)
  {
    TRANS_LOG("ObTableRpcScan set table faild, table id = %lu", OB_ALL_SYS_CONFIG_STAT_TID);
  }
  else if ((ret = table_op->init(sql_context_, &hint)) != OB_SUCCESS)
  {
    TRANS_LOG("ObTableRpcScan init faild");
  }
  else if ((ret = physical_plan->add_base_table_version(OB_ALL_SYS_CONFIG_STAT_TID, 0)) != OB_SUCCESS)
  {
    TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d", OB_ALL_SYS_CONFIG_STAT_TID, ret);
  }
  else
  {
    ObString cnf_name = ObString::make_string(OB_ALL_SYS_CONFIG_STAT_TABLE_NAME);
    ObString ip_name = ObString::make_string("server_ip");
    ObString port_name = ObString::make_string("server_port");
    ObString type_name = ObString::make_string("server_type");
    for (int32_t i = 0; i < show_stmt->get_column_size(); i++)
    {
      const ColumnItem* column_item = show_stmt->get_column_item(i);
      ObString cname;
      if (column_item->column_name_ == ip_name)
      {
        cname = ObString::make_string("svr_ip");
      }
      else if (column_item->column_name_ == port_name)
      {
        cname = ObString::make_string("svr_port");
      }
      else if (column_item->column_name_ == type_name)
      {
        cname = ObString::make_string("svr_type");
      }
      else
      {
        cname = column_item->column_name_;
      }
      const ObColumnSchemaV2* column_schema = NULL;
      if ((column_schema = sql_context_->schema_manager_->get_column_schema(
             cnf_name,
             cname
             )) == NULL)
      {
        ret = OB_ERR_COLUMN_UNKNOWN;
        TRANS_LOG("Can not get relative column %.*s from %s",
                  column_item->column_name_.length(), column_item->column_name_.ptr(),
                  OB_ALL_SYS_CONFIG_STAT_TABLE_NAME);
        break;
      }
      else
      {
        // add table scan columns
        ObBinaryRefRawExpr col_expr(OB_ALL_SYS_CONFIG_STAT_TID, column_schema->get_id(), T_REF_COLUMN);
        ObSqlRawExpr col_raw_expr(
              common::OB_INVALID_ID,
              OB_ALL_SYS_CONFIG_STAT_TID,
              column_schema->get_id(),
              &col_expr);
        ObSqlExpression output_expr;
        if ((ret = col_raw_expr.fill_sql_expression(
               output_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS
            || (ret = table_op->add_output_column(output_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add table output columns faild");
          break;
        }

        // add project columns
        col_raw_expr.set_table_id(column_item->table_id_);
        col_raw_expr.set_column_id(column_item->column_id_);
        output_expr.reset();
        if ((ret = col_raw_expr.fill_sql_expression(
               output_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS
            || (ret = project_op->add_output_column(output_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add project output columns faild");
          break;
        }
      }
    } // end for
  }
  if (ret == OB_SUCCESS)
  {
    out_op = project_op;
  }
  return ret;
}

//add liu jun.[MultiUPS] [sql_api] 20150325:b
//mod wuna [MultiUPS] [sql_api] 20160223:b
//int ObTransformer::gen_phy_show_functions(
//  ObLogicalPlan *logical_plan,
//  ObPhysicalPlan *physical_plan,
//  ErrStat& err_stat,
//  ObShowStmt *show_stmt,
//  ObPhyOperator *&out_op)
int ObTransformer::gen_phy_show_partition_functions_rules_groups(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op,
    const uint64_t table_id,
    const char* const table_name)
//mod 20160223:e
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObTableRpcScan *table_op = NULL;
  ObProject *project_op = NULL;
  ObRpcScanHint hint;
  hint.read_method_ = ObSqlReadStrategy::USE_SCAN;
  if (CREATE_PHY_OPERRATOR(table_op, ObTableRpcScan, physical_plan, err_stat) == NULL)
  {
    TRANS_LOG("Generate table rpc scan operator failed, ret=%d", ret);
  }
  else if (CREATE_PHY_OPERRATOR(project_op, ObProject, physical_plan, err_stat) == NULL)
  {
    TRANS_LOG("Generate project operator failed, ret=%d", ret);
  }
  else if ((ret = project_op->set_child(0, *table_op)) != OB_SUCCESS)
  {
    TRANS_LOG("Set child of project failed, ret=%d", ret);
  }
  else if ((ret = table_op->set_table(
              table_id,
              table_id)
            ) != OB_SUCCESS)
  {
    TRANS_LOG("ObTableRpcScan set table faild, table id = %lu", table_id);
  }
  else if ((ret = table_op->init(sql_context_, &hint)) != OB_SUCCESS)
  {
    TRANS_LOG("ObTableRpcScan init faild");
  }
  else if ((ret = physical_plan->add_base_table_version(table_id, 0)) != OB_SUCCESS)
  {
    TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d", table_id, ret);
  }
  else
  {
    ObString cnf_name = ObString::make_string(table_name);
    for (int32_t i = 0; i < show_stmt->get_column_size(); i++)
    {
      const ColumnItem* column_item = show_stmt->get_column_item(i);
      ObString cname;
      cname = column_item->column_name_;
      const ObColumnSchemaV2* column_schema = NULL;
      if ((column_schema = sql_context_->schema_manager_->get_column_schema(
             cnf_name,
             cname
             )) == NULL)
      {
        ret = OB_ERR_COLUMN_UNKNOWN;
        TRANS_LOG("Can not get relative column %.*s from %s",
                  column_item->column_name_.length(), column_item->column_name_.ptr(),
                  table_name);
        break;
      }
      else
      {
        // add table scan columns
        ObBinaryRefRawExpr col_expr(table_id, column_schema->get_id(), T_REF_COLUMN);
        ObSqlRawExpr col_raw_expr(
              common::OB_INVALID_ID,
              table_id,
              column_schema->get_id(),
              &col_expr);
        ObSqlExpression output_expr;
        if ((ret = col_raw_expr.fill_sql_expression(
               output_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS
            || (ret = table_op->add_output_column(output_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add table output columns faild");
          break;
        }

        // add project columns
        col_raw_expr.set_table_id(column_item->table_id_);
        col_raw_expr.set_column_id(column_item->column_id_);
        output_expr.reset();
        if ((ret = col_raw_expr.fill_sql_expression(
               output_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS
            || (ret = project_op->add_output_column(output_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add project output columns faild");
          break;
        }
      }
    } // end for
  }
  if (ret == OB_SUCCESS)
  {
    out_op = project_op;
  }
  return ret;
}
//add 20150325:e

int ObTransformer::gen_phy_show_current_paxos_id(
    ObPhysicalPlan *physical_plan,
    ErrStat &err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObRowDesc row_desc;
  uint64_t table_id = OB_INVALID_ID;
  uint64_t column_id = OB_INVALID_ID;
  ObValues *values_op = NULL;
  CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat);
  if (ret == OB_SUCCESS)
  {
    if (show_stmt->get_column_size() != 1)
    {
      YYSYS_LOG(WARN, "wrong columns' number of %s, column size %d", OB_PAXOS_ID_SHOW_TABLE_NAME, show_stmt->get_column_size());
      ret = OB_ERR_COLUMN_SIZE;
      TRANS_LOG("wrong columns' number of %s", OB_PAXOS_ID_SHOW_TABLE_NAME);
    }
    else
    {
      const ColumnItem *column_item = show_stmt->get_column_item(0);
      table_id = column_item->table_id_;
      column_id = column_item->column_id_;
      if ((ret = row_desc.add_column_desc(table_id, column_id)) != OB_SUCCESS
          || (ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
      {
        TRANS_LOG("add row desc error, err=%d",ret);
      }
    }
    ObObj value;
    ObRow val_row;
    ObSQLSessionInfo *session_info = NULL;
    int64_t paxos_id = OB_INVALID_PAXOS_ID;
    if (NULL == sql_context_ || NULL == (session_info = sql_context_->session_info_))
    {
      ret = OB_NOT_INIT;
      TRANS_LOG("sql_context not init");
    }
    else if (!session_info->get_autocommit() || session_info->get_trans_start())
    {
      if (session_info->get_trans_id().is_valid())
      {
        if (session_info->get_participant_num() == 1)
        {
          paxos_id = session_info->get_paxos_id();
        }
        else
        {
          paxos_id = 9;
        }
      }
    }
    if (ret == OB_SUCCESS)
    {
      value.set_int(paxos_id);
      val_row.set_row_desc(row_desc);
      if ((ret = val_row.set_cell(table_id, column_id, value)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value to ObRow failed");
      }
      else if (ret == OB_SUCCESS && (ret = values_op->add_values(val_row)) != OB_SUCCESS)
      {
        TRANS_LOG("Add value row failed");
      }
    }
  }
  if (ret == OB_SUCCESS)
  {
    out_op = values_op;
  }
  return ret;
}

int ObTransformer::get_table_rules(
    const ObTableSchema &table_schema,
    ObString &prefix_name,
    ObString &rule_name,
    ObString &par_list,
    ErrStat &err_stat)
{
  int ret = err_stat.err_code_ = OB_SUCCESS;
  int64_t cur_version = sql_context_->session_info_->get_frozen_version()+1;
  ObTableRuleNode table_node;
  if (OB_SUCCESS != (ret = sql_context_->partition_mgr_->get_table_rule_node(table_schema.get_table_id(), cur_version, &table_node)))
  {
    YYSYS_LOG(INFO, "get none table rule node,ret=%d",ret);
  }
  else
  {
    prefix_name = table_node.get_prefix_name();
    rule_name = table_node.get_rule_name();
    par_list = table_node.get_para_list();
  }
  return ret;
}

int ObTransformer::get_partition_rules(
    ObString &rule_name,
    int64_t &rule_par_num,
    ObString &rule_par_list,
    ObString &rule_body,
    ErrStat &err_stat)
{
  int ret = err_stat.err_code_ = OB_SUCCESS;
  char show_partition_rules_buff[OB_MAX_SQL_LENGTH];
  int cnt = snprintf(show_partition_rules_buff, OB_MAX_SQL_LENGTH, "select rule_par_num,rule_par_list,rule_body from %s where rule_name='%.*s'",OB_ALL_PARTITION_RULES_NAME,
                     rule_name.length(), rule_name.ptr());
  ObString show_partition_rules;
  show_partition_rules.assign_ptr(show_partition_rules_buff,cnt);
  ObResultSet par_rules_result;
  if (OB_SUCCESS != (ret = par_rules_result.init()))
  {
    YYSYS_LOG(WARN, "init result set failed, ret=%d",ret);
  }
  else if (OB_SUCCESS != (ret = ObSql::direct_execute(show_partition_rules, par_rules_result, *sql_context_)))
  {
    TRANS_LOG(par_rules_result.get_message());
    YYSYS_LOG(WARN, "direct_execute failed, sql=%.*s ret=%d", show_partition_rules.length(), show_partition_rules.ptr(), ret);
  }
  else if (OB_SUCCESS != (ret = par_rules_result.open()))
  {
    YYSYS_LOG(WARN, "open result set failed, sql=%.*s ret=%d", show_partition_rules.length(), show_partition_rules.ptr(), ret);
  }
  else
  {
    const ObRow *row = NULL;
    ret = par_rules_result.get_next_row(row);
    if (OB_SUCCESS != ret)
    {
      YYSYS_LOG(WARN, "get next row from ObResultSet failed,ret=%d", ret);
    }
    else
    {
      const ObObj *par_num_cell = NULL;
      const ObObj *par_list_cell = NULL;
      const ObObj *rule_body_cell = NULL;
      uint64_t table_id = OB_INVALID_ID;
      uint64_t column_id = OB_INVALID_ID;
      if (OB_SUCCESS != (ret = row->raw_get_cell(0, par_num_cell, table_id, column_id)))
      {
        YYSYS_LOG(INFO, "raw get par_num_cell failed, ret=%d",ret);
      }
      else if (OB_SUCCESS !=(ret = row->raw_get_cell(1, par_list_cell, table_id, column_id)))
      {
        YYSYS_LOG(INFO, "raw get par_list_cell failed, ret=%d",ret);
      }
      else if (OB_SUCCESS !=(ret = row->raw_get_cell(2, rule_body_cell, table_id, column_id)))
      {
        YYSYS_LOG(INFO, "raw get rule_body_cell failed, ret=%d",ret);
      }
      else
      {
        if (ObIntType != par_num_cell->get_type())
        {
          ret = OB_ERR_UNEXPECTED;
          YYSYS_LOG(WARN, "rule_par_num error,unexpected type, ret=%d",ret);
        }
        else if (OB_SUCCESS != (ret = par_num_cell->get_int(rule_par_num)))
        {
          YYSYS_LOG(WARN, "failed to get int value from ObObj, ret=%d",ret);
        }
        else
        {
          ObString par_list;
          if (ObVarcharType != par_list_cell->get_type())
          {
            ret = OB_ERR_UNEXPECTED;
            YYSYS_LOG(WARN, "rule_par_lise error,unexpected type, ret = %d",ret);
          }
          else if (OB_SUCCESS != (ret = par_list_cell->get_varchar(par_list)))
          {
            YYSYS_LOG(WARN, "failed to get varchar from ObObj, ret=%d",ret);
          }
          else if (OB_SUCCESS != (ret = ob_write_string(*mem_pool_, par_list, rule_par_list)))
          {
            YYSYS_LOG(WARN, "failed to clone , ret=%d",ret);
          }
          else
          {
            ObString func_body;
            if (ObVarcharType != rule_body_cell->get_type())
            {
              ret = OB_ERR_UNEXPECTED;
              YYSYS_LOG(WARN, "rule_body error,unexpected type, ret=%d",ret);
            }
            if (OB_SUCCESS != (ret = rule_body_cell->get_varchar(func_body)))
            {
              YYSYS_LOG(WARN, "failed to get varchar from ObObj, ret=%d",ret);
            }
            else if (OB_SUCCESS != (ret = ob_write_string(*mem_pool_, func_body, rule_body)))
            {
              YYSYS_LOG(WARN, "failed to clone , ret=%d",ret);
            }
            else
            {
            }
          }
        }
      }
    }
    int err = par_rules_result.close();
    if (OB_SUCCESS != err)
    {
      YYSYS_LOG(WARN, "failed to close result set,err=%d",err);
    }
    par_rules_result.reset();
  }
  return ret;
}

int ObTransformer::add_table_partition(
    const ObTableSchema &table_schema,
    char *buf,
    const int64_t &buf_len,
    int64_t &pos,
    ErrStat &err_stat)
{
  int ret = err_stat.err_code_ = OB_SUCCESS;
  ObString prefix_name;
  ObString rule_name;
  ObString par_list;
  if (OB_SUCCESS != (ret = get_table_rules(table_schema, prefix_name, rule_name, par_list, err_stat)))
  {
    YYSYS_LOG(WARN, "get systable __all_table_rules failed,ret=%d",ret);
  }
  else if (!prefix_name.compare(OB_DEFAULT_GROUP_NAME) && NULL == rule_name.ptr())
  {
    //���������д����
  }
  else if (prefix_name.compare(OB_DEFAULT_GROUP_NAME) && NULL == rule_name.ptr())
  {
    databuff_printf(buf, buf_len, pos, "\nPARTITION BY (%.*s)",prefix_name.length(), prefix_name.ptr());
  }
  else
  {
    int64_t rule_par_num;
    ObString rule_par_list;
    ObString rule_body;
    if (OB_SUCCESS != (ret = get_partition_rules(rule_name, rule_par_num, rule_par_list, rule_body, err_stat)))
    {
      YYSYS_LOG(WARN, "get systable __all_partition_rules failed,ret=%d",ret);
    }
    else if ('_' == rule_name.ptr()[0] && '_' == rule_name.ptr()[1])
    {
      char func_name[9];
      memcpy(func_name, rule_name.ptr(),8);
      func_name[8] = '\0';
      if (!strcmp(func_name, "__range@"))
      {
        if (1 == rule_par_num)
        {
          databuff_printf(buf, buf_len, pos, "\nPARTITION BY RANGE(%.*s)",par_list.length(), par_list.ptr());
        }
        else
        {
          databuff_printf(buf, buf_len, pos, "\nPARTITION BY RANGE COLUMNS(%.*s)",par_list.length(), par_list.ptr());
        }
        char *pre_name = NULL;
        char *saveptr_one = NULL;
        char *token_one = NULL;
        char temp_pre_name[prefix_name.length() + 1];
        memcpy(temp_pre_name, prefix_name.ptr(), prefix_name.length());
        temp_pre_name[prefix_name.length()] = '\0';
        pre_name = strtok_r(temp_pre_name, "#", &saveptr_one);
        char tok[prefix_name.length() + 1];
        snprintf(tok, prefix_name.length(), "%s#,",pre_name);
        token_one = strtok_r(saveptr_one, tok, &saveptr_one);
        char *saveptr_two = NULL;
        char *token_two = NULL;
        char temp_rule_body[rule_body.length() + 1];
        memcpy(temp_rule_body, rule_body.ptr(), rule_body.length());
        temp_rule_body[rule_body.length()] = '\0';
        token_two = strtok_r(temp_rule_body, "()", &saveptr_two);
        databuff_printf(buf, buf_len, pos, "\n(PARTITION %s VALUES LESS THAN (%s)",token_one, token_two);
        saveptr_two++;
        while (NULL != (token_one = strtok_r(NULL, tok, &saveptr_one)) &&
               NULL != (token_two = strtok_r(NULL, "()", &saveptr_two)))
        {
          saveptr_two++;
          databuff_printf(buf, buf_len, pos, "\n,PARTITION %s VALUES LESS THAN (%s)",token_one, token_two);
        }
        databuff_printf(buf, buf_len, pos, ")");
        databuff_printf(buf, buf_len, pos, "WITH PREFIX(%s)",pre_name);
      }
      else
      {
        func_name[7] = '\0';
        if (!strcmp(func_name,"__list@"))
        {
          if (1 == rule_par_num)
          {
            databuff_printf(buf, buf_len, pos, "\nPARTITION BY LIST(%.*s)",par_list.length(), par_list.ptr());
          }
          else
          {
            databuff_printf(buf, buf_len, pos, "\nPARTITION BY LIST COLUMNS(%.*s)",par_list.length(), par_list.ptr());
          }
          char *pre_name = NULL;
          char *saveptr_one = NULL;
          char *token_one = NULL;
          char temp_pre_name[prefix_name.length() + 1];
          memcpy(temp_pre_name, prefix_name.ptr(), prefix_name.length());
          temp_pre_name[prefix_name.length()] = '\0';
          pre_name = strtok_r(temp_pre_name, "#", &saveptr_one);
          char tok[prefix_name.length() + 1];
          snprintf(tok, prefix_name.length(), "%s#,",pre_name);
          token_one = strtok_r(saveptr_one, tok, &saveptr_one);
          char *saveptr_two = NULL;
          char *token_two = NULL;
          char temp_rule_body[rule_body.length() + 1];
          memcpy(temp_rule_body, rule_body.ptr(), rule_body.length());
          temp_rule_body[rule_body.length()] = '\0';
          token_two = strtok_r(temp_rule_body, "[]", &saveptr_two);
          databuff_printf(buf, buf_len, pos, "\n(PARTITION %s VALUES IN (%s)",token_one, token_two);
          saveptr_two++;
          while (NULL != (token_one = strtok_r(NULL, tok, &saveptr_one)) &&
                 NULL != (token_two = strtok_r(NULL, "[]", &saveptr_two)))
          {
            saveptr_two++;
            databuff_printf(buf, buf_len, pos, "\n,PARTITION %s VALUES IN (%s)",token_one, token_two);
          }
          databuff_printf(buf, buf_len, pos, ")");
          databuff_printf(buf, buf_len, pos, "WITH PREFIX(%s)",pre_name);
        }
        else
        {
          YYSYS_LOG(WARN, " range or list func_name error");
        }
      }
    }
    else
    {
      databuff_printf(buf, buf_len, pos, "\nPARTITION BY (%.*s,%.*s,%.*s)",prefix_name.length(), prefix_name.ptr(),
                      rule_name.length(), rule_name.ptr(), par_list.length(), par_list.ptr());
      databuff_printf(buf, buf_len, pos, "\n/*%.*s(%.*s) = %.*s*/",rule_name.length(), rule_name.ptr(),
                      rule_par_list.length(), rule_par_list.ptr(), rule_body.length(), rule_body.ptr());
    }
  }
  return ret;
}

int ObTransformer::gen_phy_show_create_table(
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObRowDesc row_desc;
  ObValues *values_op = NULL;

  int32_t num = show_stmt->get_column_size();
  //if (OB_UNLIKELY(num != 2))
  if (OB_UNLIKELY(num != 1))
  {
    ret = OB_ERR_COLUMN_SIZE;
    TRANS_LOG("wrong columns' number of %s", OB_CREATE_TABLE_SHOW_TABLE_NAME);
  }
  else if (CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat) == NULL)
  {
  }
  else
  {
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      const ColumnItem* column_item = show_stmt->get_column_item(i);
      if ((ret = row_desc.add_column_desc(column_item->table_id_, column_item->column_id_)) != OB_SUCCESS)
      {
        TRANS_LOG("Add row desc error, err=%d", ret);
        break;
      }
    }
    if ((ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
    {
      TRANS_LOG("Set row desc error, err=%d", ret);
    }
  }

  const ObTableSchema *table_schema = NULL;
  if (ret != OB_SUCCESS)
  {
  }
  else if ((table_schema = sql_context_->schema_manager_->get_table_schema(
              show_stmt->get_show_table_id()
              )) == NULL)
  {
    ret = OB_ERR_TABLE_UNKNOWN;
    TRANS_LOG("Unknow table id = %lu, err=%d", show_stmt->get_show_table_id(), ret);
  }
  else
  {
    uint64_t table_id = OB_INVALID_ID;
    uint64_t column_id = OB_INVALID_ID;
    ObRow val_row;
    val_row.set_row_desc(row_desc);
    int64_t pos = 0;
    char buf[OB_MAX_VARCHAR_LENGTH];

    // add table_name
    //int32_t name_len = static_cast<int32_t>(strlen(table_schema->get_table_name()));
    //ObString name_val(name_len, name_len, table_schema->get_table_name());
    //ObObj name;
    //name.set_varchar(name_val);
    //if ((ret = row_desc.get_tid_cid(0, table_id, column_id)) != OB_SUCCESS)
    //{
    //    TRANS_LOG("Get table_name desc failed");
    //}
    //else if ((ret = val_row.set_cell(table_id, column_id, name)) != OB_SUCCESS)
    //{
    //    TRANS_LOG("Add table_name to ObRow failed, ret=%d", ret);
    //}
    // add table definition
    /*else*/ if ((ret = row_desc.get_tid_cid(0, table_id, column_id)) != OB_SUCCESS)
    {
      TRANS_LOG("Get table definition desc failed");
    }
    else if ((ret = cons_table_definition(
                *table_schema,
                buf,
                OB_MAX_VARCHAR_LENGTH,
                pos,
                err_stat)) != OB_SUCCESS)
    {
      TRANS_LOG("Generate table definition failed");
    }
    else
    {
      ObString value_str(static_cast<int32_t>(pos), static_cast<int32_t>(pos), buf);
      ObObj value;
      value.set_varchar(value_str);
      if ((ret = val_row.set_cell(table_id, column_id, value)) != OB_SUCCESS)
      {
        TRANS_LOG("Add table_definiton to ObRow failed, ret=%d", ret);
      }
    }
    // add final value row
    if (ret == OB_SUCCESS && (ret = values_op->add_values(val_row)) != OB_SUCCESS)
    {
      TRANS_LOG("Add value row failed");
    }
  }
  if (ret == OB_SUCCESS)
  {
    out_op = values_op;
  }
  return ret;
}

int ObTransformer::gen_phy_show_create_view(
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObRowDesc row_desc;
  ObValues *values_op = NULL;

  int32_t num = show_stmt->get_column_size();
  if (OB_UNLIKELY(num != 1))
  {
    ret = OB_ERR_COLUMN_SIZE;
    TRANS_LOG("wrong columns' number of %s", OB_CREATE_VIEW_SHOW_TABLE_NAME);
  }
  else if (CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat) == NULL)
  {
  }
  else
  {
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      const ColumnItem* column_item = show_stmt->get_column_item(i);
      if ((ret = row_desc.add_column_desc(column_item->table_id_, column_item->column_id_)) != OB_SUCCESS)
      {
        TRANS_LOG("Add row desc error, err=%d", ret);
        break;
      }
    }
    if ((ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
    {
      TRANS_LOG("Set row desc error, err=%d", ret);
    }
  }

  const ObTableSchema *table_schema = NULL;
  if (ret != OB_SUCCESS)
  {
  }
  else if ((table_schema = sql_context_->schema_manager_->get_table_schema(
              show_stmt->get_show_table_id()
              )) == NULL)
  {
    ret = OB_ERR_TABLE_UNKNOWN;
    TRANS_LOG("Unknow table id = %lu, err=%d", show_stmt->get_show_table_id(), ret);
  }
  else
  {
    uint64_t table_id = OB_INVALID_ID;
    uint64_t column_id = OB_INVALID_ID;
    ObRow val_row;
    val_row.set_row_desc(row_desc);
    int64_t pos = 0;
    char buf[OB_MAX_VARCHAR_LENGTH];

   if ((ret = row_desc.get_tid_cid(0, table_id, column_id)) != OB_SUCCESS)
    {
      TRANS_LOG("Get table definition desc failed");
    }
    else
    {
      const char *view_ptr = table_schema->get_text();
      databuff_printf(buf, OB_MAX_VARCHAR_LENGTH, pos, "%s", view_ptr);
      ObString value_str(static_cast<int32_t>(pos), static_cast<int32_t>(pos), buf);
      ObObj value;
      value.set_varchar(value_str);
      if ((ret = val_row.set_cell(table_id, column_id, value)) != OB_SUCCESS)
      {
        TRANS_LOG("Add table_definiton to ObRow failed, ret=%d", ret);
      }
    }
    // add final value row
    if (ret == OB_SUCCESS && (ret = values_op->add_values(val_row)) != OB_SUCCESS)
    {
      TRANS_LOG("Add value row failed");
    }
  }
  if (ret == OB_SUCCESS)
  {
    out_op = values_op;
  }
  return ret;
}

int ObTransformer::cons_table_definition(
    const ObTableSchema& table_schema,
    char* buf,
    const int64_t& buf_len,
    int64_t& pos,
    ErrStat& err_stat)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  const ObColumnSchemaV2* columns = NULL;
  int32_t column_size = 0;
  if ((columns = sql_context_->schema_manager_->get_table_schema(
         table_schema.get_table_id(),
         column_size)) == NULL
      || column_size <= 0)
  {
    ret = OB_ERR_TABLE_UNKNOWN;
    TRANS_LOG("Unknow table id = %lu, err=%d", table_schema.get_table_id(), ret);
  }
  else
  {
    int32_t name_len = static_cast<int32_t>(strlen(table_schema.get_table_name()));
    ObString name_val(name_len, name_len, table_schema.get_table_name());
    char dn[OB_MAX_DATBASE_NAME_LENGTH];
    char tn[OB_MAX_TABLE_NAME_LENGTH];
    ObString dname;
    ObString tname;
    dname.assign_buffer(dn, OB_MAX_DATBASE_NAME_LENGTH);
    tname.assign_buffer(tn, OB_MAX_TABLE_NAME_LENGTH);
    name_val.split_two(dname, tname);
    databuff_printf(buf, buf_len, pos, "CREATE TABLE %.*s (\n",
                    tname.length(), tname.ptr());
    //databuff_printf(buf, buf_len, pos, "CREATE TABLE %s (\n",
    //                table_schema.get_table_name());
  }

  // add columns
  for (int32_t i = 0; ret == OB_SUCCESS && i < column_size; i++)
  {
    if (i > 0)
    {
      databuff_printf(buf, buf_len, pos, ",");
    }
    switch(columns[i].get_type())
    {
      case ObVarcharType:
        databuff_printf(buf, buf_len, pos, "%s %s (%lu)",
                        columns[i].get_name(), ObObj::get_sql_type(columns[i].get_type()), columns[i].get_size());
        break;
      case ObDecimalType:
        databuff_printf(buf, buf_len, pos, "%s %s (%u,%u)",
                        columns[i].get_name(), ObObj::get_sql_type(columns[i].get_type()),
                        columns[i].get_precision(), columns[i].get_scale());
        break;
      case ObIntType:
        databuff_printf(buf, buf_len, pos, "%s %s",
                        columns[i].get_name(), "BIGINT");
        break;
      case ObInt32Type:
        databuff_printf(buf, buf_len, pos, "%s %s",
                        columns[i].get_name(), "INT");
        break;
      default:
        databuff_printf(buf, buf_len, pos, "%s %s",
                        columns[i].get_name(), ObObj::get_sql_type(columns[i].get_type()));
        break;
    }
    if (!columns[i].get_default_value_is_nullable())
    {
      switch (columns[i].get_type())
      {
        case ObVarcharType:
          databuff_printf(buf, buf_len, pos, " DEFAULT '%s'",
                          columns[i].get_default_val());
          break;
        default:
          databuff_printf(buf, buf_len, pos, " DEFAULT %s",
                          columns[i].get_default_val());
          break;
      }
    }
    if (!columns[i].is_nullable())
    {
      databuff_printf(buf, buf_len, pos, " NOT NULL");
    }
    databuff_printf(buf, buf_len, pos, "\n");
  }

  // add rowkeys
  const ObRowkeyInfo& rowkey_info = table_schema.get_rowkey_info();
  databuff_printf(buf, buf_len, pos, ", PRIMARY KEY(");
  for (int64_t j = 0; ret == OB_SUCCESS && j < rowkey_info.get_size(); j++)
  {
    const ObColumnSchemaV2* col = NULL;
    if ((col = sql_context_->schema_manager_->get_column_schema(
           table_schema.get_table_id(),
           rowkey_info.get_column(j)->column_id_
           )) == NULL)
    {
      ret = OB_ERR_COLUMN_UNKNOWN;
      TRANS_LOG("Get column %lu failed", rowkey_info.get_column(j)->column_id_);
      break;
    }
    else if (j != rowkey_info.get_size() - 1)
    {
      databuff_printf(buf, buf_len, pos, "%s, ", col->get_name());
    }
    else
    {
      databuff_printf(buf, buf_len, pos, "%s)\n", col->get_name());
    }
  }

  // add table options
  if (ret == OB_SUCCESS)
  {
    databuff_printf(buf, buf_len, pos, ") ");
    //if (table_schema.get_max_sstable_size() >= 0)
    //{
    //    databuff_printf(buf, buf_len, pos, "TABLET_MAX_SIZE = %ld, ",
    //                    table_schema.get_max_sstable_size());
    //}
    //if (table_schema.get_block_size() >= 0)
    //{
    //    databuff_printf(buf, buf_len, pos, "TABLET_BLOCK_SIZE = %d, ",
    //                    table_schema.get_block_size());
    //}
    if (*table_schema.get_expire_condition() != '\0')
    {
      databuff_printf(buf, buf_len, pos, "EXPIRE_INFO = '%s', ",
                      table_schema.get_expire_condition());
    }
    if (*table_schema.get_comment_str() != '\0')
    {
      databuff_printf(buf, buf_len, pos, "COMMENT = '%s', ",
                      table_schema.get_comment_str());
    }
    databuff_printf(buf, buf_len, pos, "COMPRESS_METHOD = '%s', ",
                    table_schema.get_compress_func_name());
    //if( !table_schema.is_merge_dynamic_data())
    //{
    //    databuff_printf(buf, buf_len, pos, "CONSISTENT_MODE=STATIC ");
    //}
    databuff_printf(buf, buf_len, pos, "REPLICA_NUM = %ld ",
                    table_schema.get_replica_count());
    //databuff_printf(buf, buf_len, pos,
    // "REPLICA_NUM = %ld, "
    //                "USE_BLOOM_FILTER = %s",
    // table_schema.get_replica_num(),
    //                table_schema.is_use_bloomfilter() ? "TRUE" : "FALSE");
  }
  if ((ret = add_table_partition(table_schema,
                                 buf,
                                 OB_MAX_VARCHAR_LENGTH,
                                 pos,
                                 err_stat)) != OB_SUCCESS)
  {
    YYSYS_LOG(WARN, "add table partition failed,ret=%d",ret);
  }
  databuff_printf(buf, buf_len, pos, ";");
  return ret;
}

int ObTransformer::gen_phy_when(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    const uint64_t& query_id,
    ObPhyOperator& child_op,
    ObWhenFilter *& when_filter)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObStmt *stmt = NULL;
  if (OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, stmt)))
  {
  }
  /* generate root operator */
  else if (CREATE_PHY_OPERRATOR(when_filter, ObWhenFilter, physical_plan, err_stat) == NULL)
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator");
  }
  else if ((ret = when_filter->set_child(0, child_op)) != OB_SUCCESS)
  {
    TRANS_LOG("Add first child of ObWhenFilter failed, ret=%d", ret);
  }
  else
  {
    when_filter->set_when_number(stmt->get_when_number());
    int32_t sub_index = OB_INVALID_INDEX;
    uint64_t expr_id = OB_INVALID_ID;
    ObSqlRawExpr *when_expr = NULL;
    ObUnaryOpRawExpr *when_func = NULL;
    ObUnaryRefRawExpr *sub_query = NULL;
    ObPhyOperator *sub_plan = NULL;
    for(int32_t i = 0; ret == OB_SUCCESS && i < stmt->get_when_fun_size(); i++)
    {
      expr_id = stmt->get_when_func_id(i);
      if ((when_expr = logical_plan->get_expr(expr_id)) == NULL
          || (when_func = static_cast<ObUnaryOpRawExpr*>(when_expr->get_expr())) == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Wrong expr id = %lu of when function, ret=%d", expr_id, ret);
      }
      else if ((sub_query = static_cast<ObUnaryRefRawExpr*>(when_func->get_op_expr())) == NULL)
      {
        ret = OB_ERR_ILLEGAL_VALUE;
        TRANS_LOG("Wrong expr of %dth when function, ret=%d", i, ret);
      }
      else if ((ret = generate_physical_plan(
                  logical_plan,
                  physical_plan,
                  err_stat,
                  sub_query->get_ref_id(),
                  &sub_index)) != OB_SUCCESS)
      {
      }
      else if ((sub_plan = physical_plan->get_phy_query(sub_index)) == NULL)
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Wrong sub-query index %d of when function, ret=%d", sub_index, ret);
      }
      else
      {
        switch (when_func->get_expr_type())
        {
          case T_ROW_COUNT:
          {
            ObRowCount *row_count_op = NULL;
            if (CREATE_PHY_OPERRATOR(row_count_op, ObRowCount, physical_plan, err_stat) == NULL)
            {
              break;
            }
            else if ((ret = row_count_op->set_child(0, *sub_plan)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of ObRowCount failed, ret=%d", ret);
            }
            else if ((ret = when_filter->set_child(i + 1, *row_count_op)) != OB_SUCCESS)
            {
              TRANS_LOG("Add child of ObWhenFilter failed, ret=%d", ret);
            }
            else
            {
              row_count_op->set_tid_cid(when_expr->get_table_id(), when_expr->get_column_id());
              row_count_op->set_when_func_index(i);
            }
            break;
          }
          default:
          {
            ret = OB_ERR_ILLEGAL_TYPE;
            TRANS_LOG("Unknown type of %dth when function, ret=%d", i, ret);
            break;
          }
        }
        if (ret != OB_SUCCESS)
        {
          break;
        }
        else if ((ret = physical_plan->remove_phy_query(sub_index)) != OB_SUCCESS)
        {
          TRANS_LOG("Remove sub-query plan failed, ret=%d", ret);
        }
      }
    }
    for(int32_t i = 0; ret == OB_SUCCESS && i < stmt->get_when_expr_size(); i++)
    {
      uint64_t expr_id = stmt->get_when_expr_id(i);
      ObSqlRawExpr *raw_expr = logical_plan->get_expr(expr_id);
      ObSqlExpression expr;
      if (OB_UNLIKELY(raw_expr == NULL))
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Wrong id = %lu to get expression, ret=%d", expr_id, ret);
      }
      else if ((ret = raw_expr->fill_sql_expression(
                  expr,
                  this,
                  logical_plan,
                  physical_plan)
                ) != OB_SUCCESS)
      {
        TRANS_LOG("Generate ObSqlExpression failed, ret=%d", ret);
      }
      else if ((ret = when_filter->add_filter(expr)) != OB_SUCCESS)
      {
        TRANS_LOG("Add when filter failed, ret=%d", ret);
      }
    }
  }
  return ret;
}

int ObTransformer::get_all_index(uint64_t table_id, uint64_t idx_id[], int32_t &index_num)
{
  int ret = OB_SUCCESS;
  char show_index_buff[OB_MAX_SQL_LENGTH];
  int cnt = snprintf(show_index_buff, OB_MAX_SQL_LENGTH, "select table_id from %s where data_table_id =%lu",FIRST_TABLET_TABLE_NAME,
                     table_id);
  ObString show_index;
  show_index.assign_ptr(show_index_buff, cnt);
  ObResultSet index_id_result;
  if (OB_SUCCESS != (ret = index_id_result.init()))
  {
    YYSYS_LOG(WARN, "init result set failed, ret=%d",ret);
  }
  else if (OB_SUCCESS != (ret = ObSql::direct_execute(show_index, index_id_result, *sql_context_)))
  {
    YYSYS_LOG(WARN, "direct_execute get index id failed, sql=%.*s ret=%d", show_index.length(), show_index.ptr(), ret);
  }
  else if (OB_SUCCESS != (ret = index_id_result.open()))
  {
    YYSYS_LOG(WARN, "open result set failed, sql=%.*s ret=%d", show_index.length(), show_index.ptr(), ret);
  }
  else
  {
    const ObRow *row = NULL;
    for (index_num = 0;ret == OB_SUCCESS;index_num++)
    {
      ret = index_id_result.get_next_row(row);
      if (OB_ITER_END == ret)
      {
        ret = OB_SUCCESS;
        break;
      }
      else if (OB_SUCCESS != ret)
      {
        YYSYS_LOG(WARN, "get next row from ObResultSet failed,ret=%d",ret);
      }
      else
      {
        const ObObj *pcell = NULL;
        uint64_t table_id = OB_INVALID_ID;
        uint64_t column_id = OB_INVALID_ID;
        if (OB_SUCCESS != (ret = row->raw_get_cell(0, pcell, table_id, column_id)))
        {
          YYSYS_LOG(WARN, "raw get cell(index_id) failed, ret=%d",ret);
        }
        else
        {
          int64_t index_id;
          if (ObIntType != pcell->get_type())
          {
            ret = OB_ERR_UNEXPECTED;
            YYSYS_LOG(WARN, "got type of %d cell from row, expected type=%d",pcell->get_type(), ObIntType);
          }
          else if (OB_SUCCESS != (ret = pcell->get_int(index_id)))
          {
            YYSYS_LOG(WARN, "failed to get int from ObObj, ret=%d",ret);
          }
          else
          {
            idx_id[index_num]=index_id;
          }
        }
      }
    }
    int err = index_id_result.close();
    if (OB_SUCCESS != err)
    {
      YYSYS_LOG(WARN, "failed to close result set,err=%d",err);
    }
    index_id_result.reset();
  }
  return ret;
}

int ObTransformer::gen_phy_show_create_index(
    ObPhysicalPlan *physical_plan,
    ErrStat &err_stat,
    ObShowStmt *show_stmt,
    ObPhyOperator *&out_op)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObRowDesc row_desc;
  ObValues *values_op = NULL;
  int32_t num = show_stmt->get_column_size();
  if (OB_UNLIKELY(num != 1))
  {
    ret = OB_ERR_COLUMN_SIZE;
    TRANS_LOG("wrong columns' number of %s", OB_CREATE_INDEX_SHOW_TABLE_NAME);
  }
  else if (CREATE_PHY_OPERRATOR(values_op, ObValues, physical_plan, err_stat) == NULL)
  {
  }
  else
  {
    int32_t i = 0;
    const ColumnItem *column_item = show_stmt->get_column_item(i);
    if ((ret = row_desc.add_column_desc(column_item->table_id_, column_item->column_id_)) != OB_SUCCESS)
    {
      TRANS_LOG("Add row desc error, err=%d",ret);
    }
    else if ((ret = values_op->set_row_desc(row_desc)) != OB_SUCCESS)
    {
      TRANS_LOG("Set row desc error, err=%d",ret);
    }
  }
  const ObTableSchema *table_schema = NULL;
  uint64_t idx_id[OB_MAX_INDEX_NUMS];
  if (ret != OB_SUCCESS)
  {
  }
  else if ((table_schema = sql_context_->schema_manager_->get_table_schema(
              show_stmt->get_show_table_id()
              )) == NULL)
  {
    ret = OB_ERR_TABLE_UNKNOWN;
    TRANS_LOG("Unknow table id = %lu, err=%d", show_stmt->get_show_table_id(), ret);
  }
  else
  {
    int32_t name_len = static_cast<int32_t>(strlen(table_schema->get_table_name()));
    ObString name_val(name_len, name_len, table_schema->get_table_name());
    char dn[OB_MAX_DATBASE_NAME_LENGTH];
    char tn[OB_MAX_TABLE_NAME_LENGTH];
    ObString dname;
    ObString tname;
    dname.assign_buffer(dn, OB_MAX_DATBASE_NAME_LENGTH);
    tname.assign_buffer(tn, OB_MAX_TABLE_NAME_LENGTH);
    name_val.split_two(dname, tname);
    int32_t index_num = 0;
    if (OB_SUCCESS != (ret = get_all_index(show_stmt->get_show_table_id(),idx_id, index_num)))
    {
      YYSYS_LOG(WARN, "failed to get index id from __first_tablet_entry! ret=[%d]",ret);
    }
    else
    {
      int32_t i=0;
      while (OB_SUCCESS == ret)
      {
        const ObTableSchema *idx_table_schema = NULL;
        if (i == index_num)
        {
          ret = OB_SUCCESS;
          break;
        }
        else if ((idx_table_schema = sql_context_->schema_manager_->get_table_schema(idx_id[i])) == NULL)
        {
          ret = OB_ERR_TABLE_UNKNOWN;
          TRANS_LOG("Unknow index table id = %lu, err=%d", idx_id[i], ret);
          break;
        }
        else
        {
          i++;
          uint64_t table_id = OB_INVALID_ID;
          uint64_t column_id = OB_INVALID_ID;
          ObRow val_row;
          val_row.set_row_desc(row_desc);
          int64_t pos = 0;
          char buf[OB_MAX_VARCHAR_LENGTH];
          if ((ret = row_desc.get_tid_cid(0, table_id, column_id)) != OB_SUCCESS)
          {
            TRANS_LOG("Get index definition desc failed");
          }
          else
          {
            int32_t idx_name_len = static_cast<int32_t>(strlen(idx_table_schema->get_table_name()));
            ObString idx_name_val(idx_name_len, idx_name_len, idx_table_schema->get_table_name());
            char idx_dn[OB_MAX_DATBASE_NAME_LENGTH];
            char idx_tn[OB_MAX_TABLE_NAME_LENGTH];
            ObString idx_dname;
            ObString idx_tname;
            idx_dname.assign_buffer(idx_dn, OB_MAX_DATBASE_NAME_LENGTH);
            idx_tname.assign_buffer(idx_tn, OB_MAX_TABLE_NAME_LENGTH);
            idx_name_val.split_two(idx_dname, idx_tname);
            char idx_table_id[OB_MAX_COLUMN_NAME_LENGTH];
            snprintf(idx_table_id, OB_MAX_COLUMN_NAME_LENGTH, "__%ld__idx__",idx_table_schema->get_table_id());
            int32_t len = static_cast<int32_t>(strlen(idx_table_id));
            databuff_printf(buf, OB_MAX_VARCHAR_LENGTH, pos, "CREATE INDEX %.*s ON %.*s (",
                            idx_tname.length()-len, idx_tname.ptr()+len, tname.length(), tname.ptr());
            if ((ret = cons_index_definition(
                   *idx_table_schema,
                   buf,
                   OB_MAX_VARCHAR_LENGTH,
                   pos,
                   err_stat)) != OB_SUCCESS)
            {
              TRANS_LOG("Generate index definition failed");
            }
            else
            {
              ObString value_str(static_cast<int32_t>(pos), static_cast<int32_t>(pos), buf);
              ObObj value;
              value.set_varchar(value_str);
              if ((ret = val_row.set_cell(table_id,column_id, value)) != OB_SUCCESS)
              {
                TRANS_LOG("Add index_definition to ObRow failed, ret=%d",ret);
              }
            }
          }
          if (ret == OB_SUCCESS && (ret = values_op->add_values(val_row)) != OB_SUCCESS)
          {
            TRANS_LOG("Add value row failed");
          }
        }
      }
    }
  }
  if (ret == OB_SUCCESS)
  {
    out_op = values_op;
  }
  return ret;
}

int ObTransformer::cons_index_definition(
    const ObTableSchema &table_schema,
    char *buf,
    const int64_t &buf_len,
    int64_t &pos,
    ErrStat &err_stat)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  const ObRowkeyInfo &rowkey_info = table_schema.get_rowkey_info();
  for (int64_t j = 0; ret == OB_SUCCESS && j < rowkey_info.get_size(); j++)
  {
    const ObColumnSchemaV2 *col = NULL;
    if ((col = sql_context_->schema_manager_->get_column_schema(
           table_schema.get_table_id(),
           rowkey_info.get_column(j)->column_id_
           )) == NULL)
    {
      ret = OB_ERR_COLUMN_UNKNOWN;
      TRANS_LOG("Get column %lu failed", rowkey_info.get_column(j)->column_id_);
      break;
    }
    else if (j != rowkey_info.get_size() - 1)
    {
      databuff_printf(buf, buf_len, pos, "%s, ",col->get_name());
    }
    else
    {
      databuff_printf(buf, buf_len, pos, "%s) ",col->get_name());
    }
  }
  const ObColumnSchemaV2 *columns = NULL;
  int32_t column_size = 0;
  if (ret != OB_SUCCESS)
  {
  }
  else if ((columns = sql_context_->schema_manager_->get_table_schema(
              table_schema.get_table_id(),
              column_size)) == NULL
           || column_size <= 0)
  {
    ret = OB_ERR_TABLE_UNKNOWN;
    TRANS_LOG("Unknow table id = %lu, err=%d",table_schema.get_table_id(), ret);
  }
  else
  {
    int32_t num = 0;
    int32_t col_[column_size];
    for (int32_t i = 0; ret == OB_SUCCESS && i < column_size; i++)
    {
      bool is_rowkey = false;
      for (int32_t j = 0; ret == OB_SUCCESS && j < rowkey_info.get_size(); j++)
      {
        if (columns[i].get_id() == rowkey_info.get_column(j)->column_id_)
        {
          is_rowkey = true;
        }
      }
      if (!is_rowkey && strcmp(columns[i].get_name(), OB_INDEX_VIRTUAL_COL_NAME))
      {
        col_[num] = i;
        num++;
      }
    }
    if (0 < num)
    {
      databuff_printf(buf, buf_len, pos, "storing (");
      for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
      {
        if (i != num-1)
        {
          databuff_printf(buf, buf_len, pos, "%s, ", columns[col_[i]].get_name());
        }
        else
        {
          databuff_printf(buf, buf_len, pos, "%s)", columns[col_[i]].get_name());
        }
      }
    }
  }
  databuff_printf(buf, buf_len, pos, ";");
  return ret;
}

//add peiouya [NotNULL_check] [JHOBv0.1] 20131222:b
/*expr:
Function:     column_null_check
Calls:        gen_physical_insert_new; gen_physical_replace
Input:        logical_plan  type:ObLogicalPlan*
Input:        insert_stmt   type:ObInsertStmt*
Input:        op_type       type:enum operateType
Output:       err_stat      type:ErrStat&
return:       ret           type:int
*/
int ObTransformer::column_null_check(
    ObLogicalPlan *logical_plan,
    ObInsertStmt *insert_stmt,
    ErrStat& err_stat,
    enum operateType op_type)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObArray<uint64_t> colArray;

  if ((OP_INSERT != op_type) && (OP_REPLACE != op_type))
  {
    ret = OB_SUCCESS;
    return ret;
  }

  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    uint64_t tid = insert_stmt->get_table_id();
    int32_t name_len= static_cast<int32_t>(strlen(sql_context_->schema_manager_->get_table_schema(tid)->get_table_name()));
    const ObString table_name(name_len,name_len,sql_context_->schema_manager_->get_table_schema(tid)->get_table_name());

    if( !TableSchema::is_system_table(table_name) && OB_LIKELY(OB_SUCCESS == ret) )
    {
      const ObColumnSchemaV2 *col = NULL;
      int32_t size = 0;
      if (!IS_SHOW_TABLE(tid))
      {
        col = sql_context_->schema_manager_->get_table_schema(tid, size);
      }
      for (int64_t j = 0; j < size; j++)
      {
        if ((!col[j].is_nullable()) && (NULL == insert_stmt->get_column_item_by_id(tid, col[j].get_id())))
        {
          TRANS_LOG("column:'%s' can not be null",col[j].get_name());   //Corrections YYSYS_LOG->TRANS_LOG add by peiouya 2013/12/22
          ret = (op_type == OP_INSERT ? OB_ERR_INSERT_NULL_COLUMN:OB_ERR_REPLACE_NULL_COLUMN);
          break;
        }
        else if ((!col[j].is_nullable()) && (NULL != insert_stmt->get_column_item_by_id(tid, col[j].get_id())))
        {
          colArray.push_back(col[j].get_id());
        }
      }
      ////////////////////////////////////////////////////
      if (OB_LIKELY(ret == OB_SUCCESS))
      {
        int64_t value_vectors_size = insert_stmt->get_value_row_size();

        int64_t para_count = 0;

        for (int64_t k = 0; (ret == OB_SUCCESS) && (k < value_vectors_size); k++)
        {
          const oceanbase::common::ObArray<uint64_t>& value_row = insert_stmt->get_value_row(k);
          for (int64_t m = 0; (ret == OB_SUCCESS) && (m < value_row.count()); m++)
          {
            ObSqlRawExpr* ObSRawExpr = logical_plan->get_expr(value_row.at(m));
            const ColumnItem* column_item = insert_stmt->get_column_item((int32_t)m);
            for (int64_t n = 0; (ret == OB_SUCCESS) && (n < colArray.count()); n++)
            {
              if ( (column_item->column_id_ == colArray.at(n)) && ( ObNullType == ObSRawExpr->get_expr()->get_result_type()))
              {
                TRANS_LOG("column:'%.*s' can not be null!",column_item->column_name_.length(),column_item->column_name_.ptr());
                ret = (op_type == OP_INSERT ? OB_ERR_INSERT_NULL_COLUMN:OB_ERR_REPLACE_NULL_COLUMN);
                break;
              }
            }
            //add peiouya [NotNULL_check]  20131222:b
            /*expr:prepare/execute Null constraint*/
            if (OB_LIKELY(ret == OB_SUCCESS))
            {
              col = sql_context_->schema_manager_->get_column_schema(tid, column_item->column_id_);
              if((NULL != col) && (T_QUESTIONMARK == ObSRawExpr->get_expr()->get_expr_type()))
              {
                if (para_count >= result_->get_params().count())
                {
                  para_count -= para_count;
                }
                bool is_null = col->is_nullable();
                if (OB_SUCCESS != (ret = result_->set_params_constraint(para_count, is_null)))
                {
                  TRANS_LOG("Fail to save the constraint of  column %s!", col->get_name());
                  break;
                }
                para_count++;
              }
            }
            //add 20131222:e
          }
        }
      }
    }
  }
  colArray.clear();
  return ret;

}//add 20131222:e

//add wenghaixing[decimal] for fix delete bug 2014/10/10
int ObTransformer::ob_write_obj_for_delete(ModuleArena &allocator, const ObObj &src, ObObj &dst,ObObj type)
{

  int ret,ret2=OB_SUCCESS;
  if(type.get_type()!=ObDecimalType)
  {

    ret2=ob_write_obj(allocator,src,dst);

  }
  else
  {
    const ObObj *ob1=NULL;
    ob1=&src;
    ObObj casted_cell;
    char buff[MAX_PRINTABLE_SIZE];
    memset(buff,0,MAX_PRINTABLE_SIZE);
    ObString os2;
    os2.assign_ptr(buff,MAX_PRINTABLE_SIZE);
    casted_cell.set_varchar(os2);
    if(OB_SUCCESS!=(ret=obj_cast(*ob1,type,casted_cell,ob1)))
    {

    }
    else
    {
      //ObString str;
      //ObString str_clone;
      //ob1->get_decimal(str);
      //ObDecimal od,od_cmp;
      ObDecimal od,old_tmp;
      uint64_t *t2 = NULL;
      uint32_t len;
      if(OB_SUCCESS!=(ret= ob1->get_decimal(od)))
      {
        YYSYS_LOG(WARN, "faild to get decimal!");
      }
      else
      {
        old_tmp=od;
        len = ob1->get_nwords();
      }
      if(OB_SUCCESS==ret)
      {

        if(OB_SUCCESS!=(ret=od.modify_value(ob1->get_precision(),ob1->get_scale())))
        {
          //YYSYS_LOG(ERROR, "faild to do modify_value(),od.p=%d,od.s=%d,od.v=%d,src.p=%d,src.s=%d..od=%.*s", od.get_precision(),od.get_scale(),od.get_vscale(),src.get_precision(),src.get_scale(),str.length(),str.ptr());
        }
        else if(old_tmp!=od)
        {
          ret=OB_ERROR;
        }
        else
        {
          if (od.get_words()->table[1] == 0)
          {
            len = 1;
          }
          else
          {
            len = 2;
          }
          if (OB_SUCCESS == (ret = ob_write_decimal(allocator, od.get_words()->ToUInt_v2(),len,t2)))
          {
//          dst.set_decimal(t2,ob1->get_precision(),ob1->get_scale(),ob1->get_vscale(), len);
            dst.set_decimal(t2, od.get_precision(), od.get_scale(), od.get_vscale(), len);
          }
          /*char buf[MAX_PRINTABLE_SIZE];
                    memset(buf, 0, MAX_PRINTABLE_SIZE);
                    ObString os;
                    int64_t length=od.to_string(buf,MAX_PRINTABLE_SIZE);
                    os.assign_ptr(buf,(int)length);

                    if (OB_SUCCESS == (ret = ob_write_string(allocator, os, str_clone)))
                    {
                        dst.set_decimal(str_clone,ob1->get_precision(),ob1->get_scale(),ob1->get_scale());
                    }*/
        }
      }
    }

    if(OB_SUCCESS!=ret)
    {
      ret2=ob_write_obj(allocator,src,dst);
    }
  }
  return ret2;

}
//add e

int ObTransformer::gen_phy_table_for_update_v2(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan*& physical_plan,
    ErrStat& err_stat,
    ObStmt *stmt,
    uint64_t table_id,
    const ObRowkeyInfo &rowkey_info,
    const ObRowDesc &row_desc,
    const ObRowDescExt &row_desc_ext,
    ObPhyOperator*& table_op
    //add lijianqiang [sequence update] 20160316:b
    ,ObPhyOperator* sequence_op)
//add 20160316:e
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  TableItem* table_item = NULL;
  ObTableRpcScan *table_rpc_scan_op = NULL;
  ObFilter *filter_op = NULL;
  ObIncScan *inc_scan_op = NULL;
  ObMultipleGetMerge *fuse_op = NULL;
  ObMemSSTableScan *static_data = NULL;
  ObValues *tmp_table = NULL;
  ObRowDesc rowkey_col_map;
  ObExprValues* get_param_values = NULL;
  const ObTableSchema *table_schema = NULL;
  ObObj rowkey_objs[OB_MAX_ROWKEY_COLUMN_NUMBER]; // used for constructing GetParam
  ObPostfixExpression::ObPostExprNodeType type_objs[OB_MAX_ROWKEY_COLUMN_NUMBER];
  ModuleArena rowkey_alloc(OB_MAX_VARCHAR_LENGTH, ModulePageAllocator(ObModIds::OB_SQL_TRANSFORMER));
  ObCellInfo cell_info;
  cell_info.table_id_ = table_id;
  cell_info.row_key_.assign(rowkey_objs, rowkey_info.get_size());

  //add lijianqiang [sequence_fix] 20151030:b
  ObSequence * base_sequence_op = NULL;
  base_sequence_op = dynamic_cast<ObSequence *> (sequence_op);
  //add 20151030:e
  bool has_other_cond = false;
  ObRpcScanHint hint;
  hint.read_method_ = ObSqlReadStrategy::USE_GET;
  hint.read_consistency_ = FROZEN;
  hint.is_get_skip_empty_row_ = false;


  if (table_id == OB_INVALID_ID
      || (table_item = stmt->get_table_item_by_id(table_id)) == NULL
      || TableItem::BASE_TABLE != table_item->type_)
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("Wrong table id, tid=%lu", table_id);
  }
  else if (NULL == CREATE_PHY_OPERRATOR(table_rpc_scan_op, ObTableRpcScan, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else if ((ret = table_rpc_scan_op->set_table(table_item->table_id_, table_item->ref_id_)) != OB_SUCCESS)
  {
    TRANS_LOG("ObTableRpcScan set table failed");
  }
  else if (OB_SUCCESS != (ret = table_rpc_scan_op->init(sql_context_, &hint)))
  {
    TRANS_LOG("ObTableRpcScan init failed");
  }
  else if (NULL == CREATE_PHY_OPERRATOR(tmp_table, ObValues, physical_plan, err_stat))
  {
  }
  else if (OB_SUCCESS != (ret = tmp_table->set_child(0, *table_rpc_scan_op)))
  {
    YYSYS_LOG(WARN, "failed to set child op, err=%d", ret);
  }
  else if (OB_SUCCESS != (ret = physical_plan->add_phy_query(tmp_table)))
  {
    YYSYS_LOG(WARN, "failed to add sub query, err=%d", ret);
  }
  else if (NULL == CREATE_PHY_OPERRATOR(filter_op, ObFilter, physical_plan, err_stat))
  {
  }
  else if (NULL == CREATE_PHY_OPERRATOR(inc_scan_op, ObIncScan, physical_plan, err_stat))
  {
  }
  else if (NULL == CREATE_PHY_OPERRATOR(fuse_op, ObMultipleGetMerge, physical_plan, err_stat))
  {
  }
  else if (NULL == CREATE_PHY_OPERRATOR(static_data, ObMemSSTableScan, physical_plan, err_stat))
  {
  }
  else if (OB_SUCCESS != (ret = fuse_op->set_child(0, *static_data)))
  {
  }
  else if (OB_SUCCESS != (ret = fuse_op->set_child(1, *inc_scan_op)))
  {
  }
  else if (NULL == CREATE_PHY_OPERRATOR(get_param_values, ObExprValues, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else if (OB_SUCCESS != (ret = physical_plan->add_phy_query(get_param_values)))
  {
    YYSYS_LOG(WARN, "failed to add sub query, err=%d", ret);
  }
  else if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_id)))
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("Fail to get table schema for table[%ld]", table_id);
  }
  else if ((ret = physical_plan->add_base_table_version(
              table_id,
              table_schema->get_schema_version()
              )) != OB_SUCCESS)
  {
    TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d", table_id, ret);
  }
  else
  {
    fuse_op->set_is_ups_row(false);

    inc_scan_op->set_scan_type(ObIncScan::ST_MGET);
    inc_scan_op->set_write_lock_flag();
    inc_scan_op->set_hotspot(stmt->get_query_hint().hotspot_);
    inc_scan_op->set_values(get_param_values->get_id(), false);

    static_data->set_tmp_table(tmp_table->get_id());

    table_rpc_scan_op->set_rowkey_cell_count(row_desc.get_rowkey_cell_count());
    table_rpc_scan_op->set_need_cache_frozen_data(true);

    get_param_values->set_row_desc(row_desc, row_desc_ext);

    //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20151124:b
    physical_plan->set_expr_values_op_id(get_param_values->get_id());
    physical_plan->set_values_op_id(tmp_table->get_id());
    physical_plan->set_table_rpc_scan_op_id(table_rpc_scan_op->get_id());
    //add 20151124:e
    //add shili [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20150721:b
    //����table_id  stmt_type �������ƻ�ִ�е�ʱ��ʹ��
    physical_plan->set_table_id(table_id);
    physical_plan->set_stmt_type(ObBasicStmt::T_UPDATE);
    //add 20150721:e
    // set filters
    int32_t num = stmt->get_condition_size();
    uint64_t cid = OB_INVALID_ID;
    int64_t cond_op = T_INVALID;
    ObObj cond_val;
    ObPostfixExpression::ObPostExprNodeType val_type = ObPostfixExpression::BEGIN_TYPE;
    int64_t rowkey_idx = OB_INVALID_INDEX;
    ObRowkeyColumn rowkey_col;
    //add wenghaixing[decimal] for fix delete bug 2014/10/10
    uint64_t tid= table_schema->get_table_id();
    //add e
    for (int32_t i = 0; i < num; i++)
    {
      ObSqlRawExpr *cnd_expr = logical_plan->get_expr(stmt->get_condition_id(i));
      OB_ASSERT(cnd_expr);
      cnd_expr->set_applied(true);
      ObSqlExpression *filter = ObSqlExpression::alloc();
      if (NULL == filter)
      {
        TRANS_LOG("no memory");
        ret = OB_ALLOCATE_MEMORY_FAILED;
        break;
      }
      else if (OB_SUCCESS != (ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan)))
      {
        ObSqlExpression::free(filter);
        TRANS_LOG("Failed to fill expression, err=%d", ret);
        break;
      }
      //add lijianqiang [sequence update] 20151030:b
      else if (NULL != base_sequence_op
               && base_sequence_op->can_fill_sequence_info()
               && base_sequence_op->is_sequence_cond_id(stmt->get_condition_id(i))
               && OB_SUCCESS == ret
               && (OB_SUCCESS != (ret = base_sequence_op->fill_the_sequence_info_to_cond_expr(filter, OB_INVALID_ID))))
      {
        TRANS_LOG("Failed deal the sequence condition filter,err=%d",ret);
        break;
      }
      //add 20151030:e
      else if (filter->is_simple_condition(false, cid, cond_op, cond_val, &val_type)
               && (T_OP_EQ == cond_op || T_OP_IS == cond_op)
               && rowkey_info.is_rowkey_column(cid))
      {
        if(T_OP_EQ == cond_op && cond_val.is_null())
        {
          ObSqlExpression *primary_key_null_filter = ObSqlExpression::alloc();
          if(NULL == primary_key_null_filter)
          {
            TRANS_LOG("no memory");
            ret = OB_ALLOCATE_MEMORY_FAILED;
            break;
          }
          *primary_key_null_filter = *filter;
          has_other_cond = true;
          YYSYS_LOG(INFO, "where:primary key = NULL");
          if (OB_SUCCESS != (ret = filter_op->add_filter(primary_key_null_filter)))
          {
            ObSqlExpression::free(primary_key_null_filter);
            TRANS_LOG("Failed to add filter, err=%d", ret);
            break;
          }
        }
        if (
            OB_SUCCESS != (ret = table_rpc_scan_op->add_filter(filter)))
        {
          ObSqlExpression::free(filter);
          TRANS_LOG("Failed to add filter, err=%d", ret);
          break;
        }
        else if (OB_SUCCESS != (ret = rowkey_col_map.add_column_desc(OB_INVALID_ID, cid)))
        {
          TRANS_LOG("Failed to add column desc, err=%d", ret);
          break;
        }
        else if (OB_SUCCESS != (ret = rowkey_info.get_index(cid, rowkey_idx, rowkey_col)))
        {
          TRANS_LOG("Unexpected branch");
          ret = OB_ERR_UNEXPECTED;
          break;
        }
        //add wenghaixing[decimal] for fix delete bug 2014/10/10
        else
        {

          ObObjType cond_val_type;
          uint32_t cond_val_precision;
          uint32_t cond_val_scale;
          ObObj static_obj;
          if(OB_SUCCESS!=sql_context_->schema_manager_->get_cond_val_info(tid,cid,cond_val_type,cond_val_precision,cond_val_scale))
          {

          }
          else
          {
            tmp_table->add_rowkey_array(tid,cid,cond_val_type,cond_val_precision,cond_val_scale);
            if(ObDecimalType==cond_val_type)
            {
              static_obj.set_precision(cond_val_precision);
              static_obj.set_scale(cond_val_scale);
              static_obj.set_type(cond_val_type);
            }
          }

          //add e
          //modify wenghaixing[decimal] for fix delete bug 2014/10/10
          //else if (OB_SUCCESS != (ret = ob_write_obj(rowkey_alloc, cond_val, rowkey_objs[rowkey_idx]))) // deep copy
          if (OB_SUCCESS != (ret = ob_write_obj_for_delete(rowkey_alloc, cond_val, rowkey_objs[rowkey_idx],static_obj))) // deep copy
            //modify e
          {
            TRANS_LOG("failed to copy cell, err=%d", ret);
          }

          else
          {
            type_objs[rowkey_idx] = val_type;
            YYSYS_LOG(DEBUG, "rowkey obj, i=%ld val=%s", rowkey_idx, to_cstring(cond_val));
          }
        }
      }
      else
      {
        // other condition
        has_other_cond = true;
        if (OB_SUCCESS != (ret = filter_op->add_filter(filter)))
        {
          TRANS_LOG("Failed to add filter, err=%d", ret);
          break;
        }
      }

    } // end for
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      int64_t rowkey_col_num = rowkey_info.get_size();
      uint64_t cid = OB_INVALID_ID;
      for (int64_t i = 0; i < rowkey_col_num; ++i)
      {
        if (OB_SUCCESS != (ret = rowkey_info.get_column_id(i, cid)))
        {
          TRANS_LOG("Failed to get column id, err=%d", ret);
          break;
        }
        else if (OB_INVALID_INDEX == rowkey_col_map.get_idx(OB_INVALID_ID, cid))
        {
          TRANS_LOG("Primary key column %lu not specified in the WHERE clause", cid);
          ret = OB_ERR_LACK_OF_ROWKEY_COL;
          break;
        }
      } // end for
    }
  }
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    // add output columns
    for(int64_t key_col_num=0;key_col_num<rowkey_info.get_size();key_col_num++)
    {
      uint64_t key_cid=OB_INVALID_ID;
      if(OB_SUCCESS!=(rowkey_info.get_column_id(key_col_num,key_cid)))
      {
        YYSYS_LOG(WARN,"cannot get rowkey id for get param values,ret[%d]",ret);
        break;
      }
      else
      {
        ObBinaryRefRawExpr col_expr(table_id, key_cid, T_REF_COLUMN);
        ObSqlRawExpr col_raw_expr(
              common::OB_INVALID_ID,
              table_id,
              key_cid,
              &col_expr);
        ObSqlExpression output_expr;
        if ((ret = col_raw_expr.fill_sql_expression(
               output_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS
            || (ret = table_rpc_scan_op->add_output_column(output_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add table output columns faild");
          break;
        }
        // for IncScan
        ObConstRawExpr col_expr2;
        ObRowkeyColumn col;
        int64_t idx=0;
        if(OB_SUCCESS!=(ret=rowkey_info.get_index(key_cid,idx,col)))
        {
          YYSYS_LOG(WARN,"failed to find index for rowkey_column");
          break;
        }
        else if (OB_SUCCESS != (ret = col_expr2.set_value_and_type(rowkey_objs[idx])))
        {
          YYSYS_LOG(WARN, "failed to set value, err=%d", ret);
          break;
        }
        else
        {
          switch (type_objs[key_col_num])
          {
            case ObPostfixExpression::PARAM_IDX:
              col_expr2.set_expr_type(T_QUESTIONMARK);
              col_expr2.set_result_type(ObVarcharType);
              break;
            case ObPostfixExpression::SYSTEM_VAR:
              col_expr2.set_expr_type(T_SYSTEM_VARIABLE);
              col_expr2.set_result_type(ObVarcharType);
              break;
            case ObPostfixExpression::TEMP_VAR:
              col_expr2.set_expr_type(T_TEMP_VARIABLE);
              col_expr2.set_result_type(ObVarcharType);
              break;
            default:
              break;
          }
        }
        ObSqlRawExpr col_raw_expr2(
              common::OB_INVALID_ID,
              table_id,
              key_cid,
              &col_expr2);
        ObSqlExpression output_expr2;
        if ((ret = col_raw_expr2.fill_sql_expression(
               output_expr2,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS)
        {
          TRANS_LOG("Add table output columns failed");
          break;
        }
        else if (OB_SUCCESS != (ret = get_param_values->add_value(output_expr2)))
        {
          TRANS_LOG("Failed to add cell into get param, err=%d", ret);
          break;
        }
        //add wenghaixing[decimal] for fix delete bug 2014/10/10
        else
        {
          get_param_values->set_del_upd();
        }
      }
    }
    for (int32_t i = 0; ret == OB_SUCCESS && i < row_desc.get_column_num(); i++)
    {
      //const ColumnItem *col_item = stmt->get_column_item(i);
      uint64_t cid = OB_INVALID_ID;
      uint64_t tid = OB_INVALID_ID;
      if(OB_SUCCESS != (ret = row_desc.get_tid_cid(i, tid, cid)))
      {
        YYSYS_LOG(WARN, "get cid from row_desc failed,ret[%d]", ret);
        break;
      }
      else if(!rowkey_info.is_rowkey_column(cid))
      {
        //YYSYS_LOG(ERROR, "test::whx out put column[%ld]",i);
        if (table_schema->get_table_id() == table_item->table_id_)
        {
          ObBinaryRefRawExpr col_expr(table_id, cid, T_REF_COLUMN);
          ObSqlRawExpr col_raw_expr(
                common::OB_INVALID_ID,
                table_id,
                cid,
                &col_expr);
          ObSqlExpression output_expr;
          if ((ret = col_raw_expr.fill_sql_expression(
                 output_expr,
                 this,
                 logical_plan,
                 physical_plan)) != OB_SUCCESS
              || (ret = table_rpc_scan_op->add_output_column(output_expr)) != OB_SUCCESS)
          {
            TRANS_LOG("Add table output columns faild");
            break;
          }
          // for IncScan
          ObConstRawExpr col_expr2;
          {
            ObObj null_obj;
            col_expr2.set_value_and_type(null_obj);
          }
          ObSqlRawExpr col_raw_expr2(
                common::OB_INVALID_ID,
                table_id,
                cid,
                &col_expr2);
          ObSqlExpression output_expr2;
          if ((ret = col_raw_expr2.fill_sql_expression(
                 output_expr2,
                 this,
                 logical_plan,
                 physical_plan)) != OB_SUCCESS)
          {
            TRANS_LOG("Add table output columns failed");
            break;
          }
          else if (OB_SUCCESS != (ret = get_param_values->add_value(output_expr2)))
          {
            TRANS_LOG("Failed to add cell into get param, err=%d", ret);
            break;
          }
          //add wenghaixing[decimal] for fix delete bug 2014/10/10
          else
          {
            get_param_values->set_del_upd();
          }
          //add e
        }
      }
    } // end for
  }
  // add action flag column
  //mod peiouya [FIX_INDEX_BUG_WHEN_UPDATE_OR_REPLACE] 20160405:b
  //if (OB_LIKELY(OB_SUCCESS == ret) && ObBasicStmt::T_UPDATE == stmt->get_stmt_type())
  if (OB_LIKELY(OB_SUCCESS == ret) && ObBasicStmt::T_REPLACE != stmt->get_stmt_type())
  {
    ObSqlExpression column_ref;
    column_ref.set_tid_cid(OB_INVALID_ID, OB_ACTION_FLAG_COLUMN_ID);
    if (OB_SUCCESS != (ret = ObSqlExpressionUtil::make_column_expr(OB_INVALID_ID, OB_ACTION_FLAG_COLUMN_ID, column_ref)))
    {
      YYSYS_LOG(WARN, "fail to make column expr:ret[%d]", ret);
    }
    else if (OB_SUCCESS != (ret = table_rpc_scan_op->add_output_column(column_ref)))
    {
      YYSYS_LOG(WARN, "failed to add output column, err=%d", ret);
    }
  }
  //mod peiouya 20160405:e
  if (OB_SUCCESS == ret && NULL != sequence_op )
  {
    ObSequenceUpdate *sequence_update_op = dynamic_cast<ObSequenceUpdate *>(sequence_op);
    //add lijianqiang [sequence] 20150909:b
    /*Exp:hanlde the set clause of UPDATE stmt*/
    int row_num = 1;
    if ( sequence_update_op !=NULL &&OB_SUCCESS != (ret = sequence_update_op->handle_the_set_clause_of_seuqence(row_num)))
    {
      TRANS_LOG("handle the set clause of sequence failed,ret=%d",ret);
    }
    //add 2050909:e
  }
  if (ret == OB_SUCCESS)
  {
    if (has_other_cond)
    {

      if (OB_SUCCESS != (ret = filter_op->set_child(0, *fuse_op)))
      {
        TRANS_LOG("Failed to set child, err=%d", ret);
      }
      else
      {
        table_op = filter_op;
      }

    }
    else
    {

      table_op = fuse_op;

    }
    //add wenghaixing[decimal] for fix delete bug 2014/10/10
    tmp_table->set_fix_obvalues();
    //add e
  }
  return ret;
}
//add e

//add lijianqiang [sequence] 20150717:b
int ObTransformer::wrap_sequence(ObLogicalPlan *&logical_plan,
                                 ObPhysicalPlan *&physical_plan,
                                 ErrStat& err_stat,
                                 const ObSEArray<int64_t, 64> &row_desc_map,
                                 ObSequence *sequence_op,
                                 ObStmt *stmt,
                                 ObPhysicalPlan *inner_plan)
{
  int ret = OB_SUCCESS;
  ObSequenceStmt *sequence_stmt = NULL;
  if (NULL == logical_plan
      || NULL == physical_plan
      || NULL == sequence_op
      || NULL == stmt)
  {
    ret = OB_NOT_INIT;
    YYSYS_LOG(ERROR,"the sequence op is not init! ret::[%d]",ret);
  }
  if (OB_SUCCESS == ret)
  {
    //for select ,select has no inner plan(the plan send to ups)
    if (ObBasicStmt::T_SELECT == stmt->get_stmt_type())
    {
      inner_plan = physical_plan;
    }
    sequence_stmt = dynamic_cast<ObSequenceStmt*>(stmt);
    if (NULL == sequence_stmt)
    {
      ret = OB_INIT_FAIL;
      YYSYS_LOG(WARN, "dynamic cast failed!");
    }
  }
  if (OB_SUCCESS == ret)
  {
    ObRowDesc sequence_row_desc;
    const ObRowkeyInfo *sequence_rowkey_info = NULL;
    //1.do some nint, be careful the order
    sequence_op->set_sql_context(sql_context_);
    sequence_op->set_stmt(sequence_stmt);
    sequence_op->add_sequence_names_no_dup();
    sequence_op->set_result_set(result_);
    if (OB_SUCCESS != (ret = sequence_op->cons_sequence_row_desc(sequence_row_desc, sequence_rowkey_info)))
    {
      TRANS_LOG("Failed to cons sequence row desc!");
    }
    //2. sequence
    const ObTableSchema *sequence_table_schema = NULL;
    ObString sequence_sys_table_name = ObString::make_string(OB_ALL_SEQUENCE_TABLE_NAME);
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      if (NULL == (sequence_table_schema = sql_context_->schema_manager_->get_table_schema(sequence_sys_table_name)))
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Fail to get sequence table schema for table[%.*s]", sequence_sys_table_name.length(),sequence_sys_table_name.ptr());
      }
    }
    ObTableRpcScan *sequence_table_scan = NULL;//for sequence info
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      ObRpcScanHint sequence_hint;
      sequence_hint.read_method_ = ObSqlReadStrategy::USE_GET;
      sequence_hint.is_get_skip_empty_row_ = true;//no need of empty row
      sequence_hint.read_consistency_ = STRONG;//be careful! we must get the data you have created!
      int64_t sequence_table_id = OB_ALL_SEQUENCE_TID;
      CREATE_PHY_OPERRATOR(sequence_table_scan, ObTableRpcScan, inner_plan, err_stat);
      if (OB_UNLIKELY(OB_SUCCESS != ret))
      {
      }
      else if (OB_SUCCESS != (ret = sequence_table_scan->set_table(sequence_table_id, sequence_table_id)))
      {
        TRANS_LOG("failed to set table id, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = sequence_table_scan->init(sql_context_, &sequence_hint)))
      {
        TRANS_LOG("failed to init sequence table scan, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = gen_phy_static_data_scan(logical_plan, inner_plan, err_stat,
                                                             stmt, sequence_row_desc, row_desc_map,
                                                             OB_ALL_SEQUENCE_TID, *sequence_rowkey_info, *sequence_table_scan)))
      {
        TRANS_LOG("err=%d", ret);
      }
      else if ((ret = physical_plan->add_base_table_version(
                  sequence_table_id,
                  sequence_table_schema->get_schema_version()
                  )) != OB_SUCCESS)
      {
        TRANS_LOG("Add base sequence table version failed, sequence_table_id=%ld, ret=%d", sequence_table_id, ret);
      }
      else
      {
        sequence_table_scan->set_rowkey_cell_count(sequence_table_schema->get_rowkey_info().get_size());
        sequence_table_scan->set_cache_bloom_filter(false);
      }
    }
    ObValues *sequence_table = NULL;//for sequence info
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      CREATE_PHY_OPERRATOR(sequence_table, ObValues, inner_plan, err_stat);
      if (OB_UNLIKELY(OB_SUCCESS != ret))
      {
      }
      else if (OB_SUCCESS != (ret = sequence_table->set_child(0, *sequence_table_scan)))
      {
        YYSYS_LOG(WARN, "failed to set child, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = sequence_op->set_child(0, *sequence_table)))
      {
        YYSYS_LOG(WARN, "failed to set child, err=%d", ret);
      }
    }
  }
  return ret;
}
//add 20150717:e
//add dolphin [ROW_NUMBER-PARTITION_BY]@20150827:b
int ObTransformer::gen_phy_partition_by(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat& err_stat,
    ObSelectStmt *select_stmt,
    ObPhyOperator *in_op,
    ObPhyOperator *&out_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObMergeGroupBy *group_op = NULL;
  ObSort *sort_op = NULL;
  ObProject *project_op = NULL;
  if (ret == OB_SUCCESS)
    CREATE_PHY_OPERRATOR(sort_op, ObSort, physical_plan, err_stat);
  if (ret == OB_SUCCESS)
    CREATE_PHY_OPERRATOR(group_op, ObMergeGroupBy, physical_plan, err_stat);
  if (ret == OB_SUCCESS && (ret = group_op->set_child(0, *sort_op)) != OB_SUCCESS)
  {
    TRANS_LOG("Add child of group by plan faild");
  }
  if(OB_SUCCESS == ret)
  {
    group_op->set_analytic_func(true);
  }
  ObSqlRawExpr *partition_expr;
  int32_t num = select_stmt->get_partition_expr_size();
  for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
  {
    partition_expr = logical_plan->get_expr(select_stmt->get_partition_expr_id(i));
    OB_ASSERT(NULL != partition_expr);
    if (partition_expr->get_expr()->get_expr_type() == T_REF_COLUMN)
    {
      ObBinaryRefRawExpr *col_expr = dynamic_cast<ObBinaryRefRawExpr*>(partition_expr->get_expr());
      OB_ASSERT(NULL != col_expr);
      ret = sort_op->add_sort_column(col_expr->get_first_ref_id(), col_expr->get_second_ref_id(), true);
      if (ret != OB_SUCCESS)
      {
        TRANS_LOG("Add sort column faild, table_id=%lu, column_id=%lu",
                  col_expr->get_first_ref_id(), col_expr->get_second_ref_id());
        break;
      }
      ret = group_op->add_partition_column(col_expr->get_first_ref_id(), col_expr->get_second_ref_id());
      if (ret != OB_SUCCESS)
      {
        TRANS_LOG("Add group column faild, table_id=%lu, column_id=%lu",
                  col_expr->get_first_ref_id(), col_expr->get_second_ref_id());
        break;
      }
    }
    else if (partition_expr->get_expr()->is_const())
    {
      // do nothing, const column is of no usage for sorting
    }
    else
    {
      if (!project_op)
      {
        CREATE_PHY_OPERRATOR(project_op, ObAddProject, physical_plan, err_stat);
        if (ret != OB_SUCCESS)
          break;
        if ((ret = project_op->set_child(0, *in_op)) != OB_SUCCESS)
        {
          TRANS_LOG("Add child of project plan faild");
          break;
        }
      }
      ObSqlExpression col_expr;
      if ((ret = partition_expr->fill_sql_expression(
             col_expr,
             this,
             logical_plan,
             physical_plan)) != OB_SUCCESS
          || (ret = project_op->add_output_column(col_expr)) != OB_SUCCESS)
      {
        TRANS_LOG("Add output column to project plan faild");
        break;
      }
      if ((ret = sort_op->add_sort_column(
             partition_expr->get_table_id(),
             partition_expr->get_column_id(),
             true)) != OB_SUCCESS)
      {
        TRANS_LOG("Add sort column to sort plan faild");
        break;
      }
      if ((ret = group_op->add_partition_column(
             partition_expr->get_table_id(),
             partition_expr->get_column_id())) != OB_SUCCESS)
      {
        TRANS_LOG("Add group column to group plan faild");
        break;
      }
    }
  }
  //int64_t n = sort_op->get_sort_column_size();
  ObSqlRawExpr *order_expr;
  int32_t order_num = select_stmt->get_order_item_for_rownum_size();
  int64_t tid = OB_INVALID;
  int64_t cid = OB_INVALID;
  for (int32_t i = 0; ret == OB_SUCCESS && i < order_num; i++)
  {
    const OrderItem& order_item = select_stmt->get_order_item_for_rownum(i);
    order_expr = logical_plan->get_expr(order_item.expr_id_);
    if (order_expr->get_expr()->is_const())
    {
      // do nothing, const column is of no usage for sorting
    }
    else if (order_expr->get_expr()->get_expr_type() == T_REF_COLUMN)
    {
      ObBinaryRefRawExpr *col_expr = dynamic_cast<ObBinaryRefRawExpr*>(order_expr->get_expr());
      tid = col_expr->get_first_ref_id();
      cid = col_expr->get_second_ref_id();
    }
    else
    {
      if (!project_op)
      {
        CREATE_PHY_OPERRATOR(project_op, ObAddProject, physical_plan, err_stat);
        if (ret != OB_SUCCESS)
          break;
        if ((ret = project_op->set_child(0, *in_op)) != OB_SUCCESS)
        {
          TRANS_LOG("Add child of project plan failed");
          break;
        }
      }
      ObSqlExpression col_expr;
      if ((ret = order_expr->fill_sql_expression(
             col_expr,
             this,
             logical_plan,
             physical_plan)) != OB_SUCCESS
          || (ret = project_op->add_output_column(col_expr)) != OB_SUCCESS)
      {
        TRANS_LOG("Add output column to project plan failed");
        break;
      }
      tid = order_expr->get_table_id();
      cid = order_expr->get_column_id();
    }
    /* del liumz, [ROW_NUMBER bugfix: sort_column in partition_by_clause precede over that in order_by_clause]20160321
         * logical error exists in this code block
        if(n > 0)
        {
            bool exist = false;
            for(int32_t i = 0; i < n; ++i)
            {

                if(OB_SUCCESS != (ret = sort_op->exist_sort_column(tid,cid,exist)))
                {
                    YYSYS_LOG(WARN, "failed to judge exist_sort_column, err=%d", ret);
                    break;
                }
                else if(!exist)
                {
                    if(OB_SUCCESS != (ret = sort_op->add_sort_column(tid,cid,order_item.order_type_ == OrderItem::ASC ? true : false)))
                    {
                        TRANS_LOG("Add sort column to sort plan failed");
                        break;
                    }
                }
                else if(i != 0)
                {
                    if(OB_SUCCESS != (ret = sort_op->replace_sort_column_at(i,tid,cid,order_item.order_type_ == OrderItem::ASC ? true : false)))
                    {
                        TRANS_LOG("Add sort column to sort plan failed");
                        break;
                    }

                }
            }
        }
        else */
    if (OB_SUCCESS != (ret = sort_op->add_sort_column(tid,cid,order_item.order_type_ == OrderItem::ASC ? true : false)))
    {
      TRANS_LOG("Add sort column to sort plan failed");
      break;
    }
  }
  if (ret == OB_SUCCESS)
  {
    if (project_op)
      ret = sort_op->set_child(0, *project_op);
    else
      ret = sort_op->set_child(0, *in_op);
    if (ret != OB_SUCCESS)
    {
      TRANS_LOG("Add child to sort plan faild");
    }
  }

  num = select_stmt->get_anal_fun_size();
  ObSqlRawExpr *agg_expr = NULL;
  for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
  {
    agg_expr = logical_plan->get_expr(select_stmt->get_anal_expr_id(i));
    OB_ASSERT(NULL != agg_expr);
    if (agg_expr->get_expr()->is_aggr_fun())
    {
      ObSqlExpression new_agg_expr;
      if ((ret = agg_expr->fill_sql_expression(
             new_agg_expr,
             this,
             logical_plan,
             physical_plan)) != OB_SUCCESS
          || (ret = group_op->add_anal_column(new_agg_expr)) != OB_SUCCESS)
      {
        TRANS_LOG("Add aggregate function to group plan faild");
        break;
      }
    }
    else
    {
      TRANS_LOG("Wrong aggregate function, exp_id = %lu", agg_expr->get_expr_id());
      break;
    }
    agg_expr->set_columnlized(true);
  }
  if (ret == OB_SUCCESS)
    out_op = group_op;

  return ret;
}
//add:e
//add lijianqiang [set_row_key_ignore] 20151019:b
bool ObTransformer::can_ignore_current_key(ObLogicalPlan *logical_plan,
                                           ObPhysicalPlan*& physical_plan,
                                           int64_t column_idx,
                                           uint64_t table_id,
                                           uint64_t column_id,
                                           ObUpdateStmt *update_stmt)
{
  int ret = OB_SUCCESS;
  bool err = false;
  uint64_t expr_id = OB_INVALID_ID;
  uint64_t where_cid = OB_INVALID_ID;
  int32_t condition_size = update_stmt->get_condition_size();
  for (int32_t i = 0; i < condition_size; i++)
  {
    ObSqlExpression where_expr;
    int64_t cond_op = OB_INVALID_INDEX;
    ObObj where_obj_value;
    ObPostfixExpression::ObPostExprNodeType val_type = ObPostfixExpression::BEGIN_TYPE;
    ObSqlRawExpr *cnd_expr = logical_plan->get_expr(update_stmt->get_condition_id(i));
    OB_ASSERT(cnd_expr);
    //fill where expr
    if (OB_SUCCESS != (ret = cnd_expr->fill_sql_expression(where_expr, this, logical_plan, physical_plan)))
    {
      YYSYS_LOG(WARN, "Failed to fill expression");
      break;
    }
    else if (!(where_expr.is_simple_condition(false, where_cid, cond_op, where_obj_value, &val_type)))
    {
      //not simple condition
      break;
    }
    if ((OB_SUCCESS == ret) && (column_id == where_cid))//find in where clause
    {
      ObSqlRawExpr * set_raw_expr = NULL;
      ObSqlExpression set_expr;
      ObObj set_obj_value;
      //get current set_expr
      if (OB_SUCCESS != (ret = update_stmt->get_update_expr_id(column_idx, expr_id)))
      {
        YYSYS_LOG(WARN, "fail to get update expr for table %lu column %lu. column_idx=%ld", table_id, column_id, column_idx);
        break;
      }
      else if (NULL == (set_raw_expr = logical_plan->get_expr(expr_id)))
      {
        YYSYS_LOG(WARN, "fail to get expr from logical plan for table %lu column %lu. column_idx=%ld", table_id, column_id, column_idx);
        break;
      }
      //fill set expr
      else if (OB_SUCCESS != (ret = set_raw_expr->fill_sql_expression(set_expr, this, logical_plan, physical_plan)))
      {
        YYSYS_LOG(WARN, "Failed to fill expression");
        break;
      }
      else
      {
        bool is_const_expr = false;
        set_expr.set_tid_cid(table_id, column_id);
        if (OB_SUCCESS != (ret = set_expr.is_const_expr(is_const_expr)))
        {
          YYSYS_LOG(WARN,"judge is const failed");
          break;
        }
        else//we got one
        {
          if (is_const_expr)
          {
            ObPostfixExpression::ExprArray &post_expr_array = set_expr.get_expr_array();
            set_obj_value = post_expr_array[1];
            if((where_obj_value == set_obj_value) && (T_OP_EQ == cond_op))
            {
              err = true;
              break;
            }
            else
            {
              //do nothing
            }
          }
        }
      }//end else
    }//end if
  }//end for
  return err;
}
//add 20151019:e


//add wanglei [second index fix] 20160425:b
bool ObTransformer::is_expr_has_more_than_two_columns(ObSqlExpression * expr)
{
  return expr->is_expr_has_more_than_two_columns ();
}
int64_t ObTransformer::get_type_num(int64_t idx,int64_t type,ObSEArray<ObObj, 64> &expr_)
{
  int64_t num = 0;
  int ret = OB_SUCCESS;
  if(type == ObPostfixExpression::BEGIN_TYPE)
  {
    num = 1;
  }
  else if (type == ObPostfixExpression::OP)
  {
    num = 3;
    int64_t op_type = 0;
    if (OB_SUCCESS != (ret = expr_[idx+1].get_int(op_type)))
    {
      YYSYS_LOG(WARN, "Fail to get op type. unexpected! ret=%d", ret);
    }
    else if (T_FUN_SYS == op_type)
    {
      ++num;
    }
  }
  else if (type == ObPostfixExpression::COLUMN_IDX || type == T_OP_ROW)
  {
    num = 3;
  }
  else if (type == ObPostfixExpression::CONST_OBJ ||type == ObPostfixExpression::QUERY_ID||type == ObPostfixExpression::PARAM_IDX
           ||type==ObPostfixExpression::TEMP_VAR)//add wanglei TEMP_VAR [second index fix] 20160513
  {
    num = 2;
  }
  else if (type == ObPostfixExpression::END || type == ObPostfixExpression::UPS_TIME_OP||ObPostfixExpression::CUR_TIME_OP
           ||ObPostfixExpression::CUR_TIME_HMS_OP
           ||ObPostfixExpression::CUR_DATE_OP
           ||ObPostfixExpression::UPS_TIME_OP)
  {
    num = 1;
  }
  else
  {
    YYSYS_LOG(WARN, "Unkown type %ld", type);
    return -1;
  }
  return num;
}
//add wanglei [second index fix] 20160425:e

//add duyr [Delete_Update_Function_isolation] [JHOBv0.1] 20160531:b
int ObTransformer::get_table_max_used_cid(ObSqlContext *context,
                                          const uint64_t table_id,
                                          uint64_t &max_used_cid)
{
  int ret = OB_SUCCESS;
  int32_t column_size = 0;
  const ObColumnSchemaV2 *col       = NULL;
  max_used_cid = OB_INVALID_ID;

  if (NULL == context
      || NULL == context->schema_manager_
      || OB_INVALID_ID == table_id)
  {
    ret = OB_INVALID_ARGUMENT;
    YYSYS_LOG(ERROR,"invalid argument!"
              "context=%p,table_id=%ld,ret=%d",
              context,table_id,ret);
  }
  else if (NULL == (col = context->schema_manager_->get_table_schema(table_id,column_size)))
  {
    ret = OB_ERROR;
    YYSYS_LOG(ERROR,"fail to get column schema!tid=%ld,ret=%d",table_id,ret);
  }
  else
  {
    max_used_cid  = 0;
    for (int32_t i=0;NULL!=col&&i<column_size;i++)
    {
      uint64_t cid = col[i].get_id();
      max_used_cid = (max_used_cid > cid) ? max_used_cid : cid;
    }
  }
  return ret;
}

//add duyr 20160531:e

//add dragon [Bugfix 1224] 2016-8-29 16:00:49:b
int ObTransformer::get_filter_array (
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan* physical_plan,
    uint64_t table_id,
    ObSelectStmt *select_stmt,
    Expr_Array &filter_array,
    common::ObArray<ObSqlExpression*> &fp_array)
{
  int ret = OB_SUCCESS;
  OB_ASSERT(select_stmt); //select stmt should not be empty!
  ObBitSet<> table_bitset;
  int32_t num = 0;

  //����table_bitset����sql�������ñ��йص�filter������ж��浽��Ӧ����������
  int32_t bit_index = select_stmt->get_table_bit_index(table_id);
  table_bitset.add_member(bit_index);
  if (bit_index < 0)
  {
    YYSYS_LOG(ERROR, "negative bitmap values[%d],table_id=%ld" , bit_index, table_id);
  }

  num = select_stmt->get_condition_size();
  for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
  {
    ObSqlRawExpr *cnd_expr = logical_plan->get_expr(select_stmt->get_condition_id(i));
    if (cnd_expr && table_bitset.is_superset(cnd_expr->get_tables_set()))
    {
      ObSqlExpression *filter = ObSqlExpression::alloc(); //����ռ�
      if (NULL == filter)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        YYSYS_LOG(ERROR, "no memory");
        break;
      }
      else if ((ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan))
               != OB_SUCCESS)
      {
        YYSYS_LOG(ERROR, "Add table filter condition faild");
        ObSqlExpression::free(filter);
        break;
      }
      else if(OB_SUCCESS != (ret = filter_array.push_back(*filter)))
      {
        YYSYS_LOG(ERROR, "push back to filter array failed");
        ObSqlExpression::free(filter);
        break;
      }
      else if(OB_SUCCESS != (ret = fp_array.push_back(filter)))
      {
        ObSqlExpression::free(filter);
        YYSYS_LOG(ERROR, "push back to filter array ptr failed");
        break;
      }
    }
  }
  return ret;
}

int ObTransformer::get_project_array (
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    uint64_t table_id,
    ObSelectStmt *select_stmt,
    Expr_Array &project_array,
    ObArray<uint64_t> &alias_exprs)
{
  int ret = OB_SUCCESS;
  UNUSED(alias_exprs);
  OB_ASSERT(select_stmt); //select stmt should not be empty!
  int32_t num = 0;
  num = select_stmt->get_column_size();
  for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
  {
    const ColumnItem *col_item = select_stmt->get_column_item(i);
    if (col_item && col_item->table_id_ == table_id)
    {
      ObBinaryRefRawExpr col_expr(col_item->table_id_, col_item->column_id_, T_REF_COLUMN);
      ObSqlRawExpr col_raw_expr(
            common::OB_INVALID_ID,
            col_item->table_id_,
            col_item->column_id_,
            &col_expr);
      ObSqlExpression output_expr;
      if ((ret = col_raw_expr.fill_sql_expression(
             output_expr,
             this,
             logical_plan,
             physical_plan)) != OB_SUCCESS)
      {
        YYSYS_LOG(ERROR, "Add table output columns faild");
        break;
      }
      else
      {
        project_array.push_back(output_expr);
      }
    }
  }

  ObBitSet<> table_bitset;
  int32_t bit_index = select_stmt->get_table_bit_index(table_id);
  table_bitset.add_member(bit_index);
  if (bit_index < 0)
  {
    YYSYS_LOG(ERROR, "negative bitmap values[%d],table_id=%ld" , bit_index, table_id);
  }
  if (ret == OB_SUCCESS && select_stmt)
  {
    num = select_stmt->get_select_item_size();
    for (int32_t i = 0; ret == OB_SUCCESS && i < num; i++)
    {
      const SelectItem& select_item = select_stmt->get_select_item(i);
      if (select_item.is_real_alias_)
      {
        ObSqlRawExpr *alias_expr = logical_plan->get_expr(select_item.expr_id_);
        if (alias_expr && alias_expr->is_columnlized() == false
            && table_bitset.is_superset(alias_expr->get_tables_set()))
        {
          ObSqlExpression output_expr;
          if ((ret = alias_expr->fill_sql_expression(
                 output_expr,
                 this,
                 logical_plan,
                 physical_plan)) != OB_SUCCESS)
          {
            YYSYS_LOG(ERROR, "Add table output columns faild");
            break;
          }
          else
          {
            project_array.push_back(output_expr);
          }
          //alias_exprs.push_back(select_item.expr_id_);
          //alias_expr->set_columnlized(true);
        }
      }
    }
  }
  return ret;
}
//add 2016-8-29 16:00:57e

int ObTransformer::semi_join_add_filter( const uint64_t right_main_cid, const uint64_t &right_table_id,
                                         const uint64_t index_table_id, ObSort &sort,
                                         ObSqlExpression *&expr_temp, const bool is_left, bool &add_suc)
{
  int ret = OB_SUCCESS;
  add_suc = true;
  ObTableRpcScan *t_r_operator = NULL;
  ObTableMemScan *t_m_operator = NULL;
  if (NULL == sort.get_child(0) || NULL == expr_temp
      || NULL == sql_context_ || NULL == sql_context_->schema_manager_)
  {
    ret = OB_INVALID_ARGUMENT;
    YYSYS_LOG(WARN, "[semi join] one of the input arguments is null!");
  }
  else if (PHY_TABLE_MEM_SCAN != sort.get_child(0)->get_type()
           && PHY_TABLE_RPC_SCAN != sort.get_child(0)->get_type())
  {
    add_suc = false;
    YYSYS_LOG(INFO, "Not supported feature or function,the child of sort is not scan operation, phy type=[%d]",
              sort.get_child(0)->get_type());
  }
  else if (PHY_TABLE_MEM_SCAN == sort.get_child(0)->get_type())
  {
    if (NULL == (t_m_operator = dynamic_cast<ObTableMemScan *>(sort.get_child(0))))
    {
      ret = OB_ERR_POINTER_IS_NULL;
      YYSYS_LOG(WARN, "[semi join] %s table memory scan op is null!", is_left ? "left" : "right");
    }
    else if (OB_SUCCESS != (ret = t_m_operator->add_filter(expr_temp)))
    {
      YYSYS_LOG(WARN, "[semi join] %s sort phy's mem scan add filter failed!", is_left ? "left" : "right");
    }
  }
  else if (PHY_TABLE_RPC_SCAN == sort.get_child(0)->get_type())
  {
    if (NULL == (t_r_operator = dynamic_cast<ObTableRpcScan *>(sort.get_child(0))))
    {
      ret = OB_ERR_POINTER_IS_NULL;
      YYSYS_LOG(WARN, "[semi join] %s table rpc scan op is null!", is_left ? "left" : "right");
    }
    //1.�����������������ֱ����ѹ
    else if (false == t_r_operator->get_rpc_scan().get_is_use_index())
    {
      if (OB_SUCCESS != (ret = t_r_operator->add_filter(expr_temp)))
      {
        YYSYS_LOG(ERROR, "[semi join] sort phy's rpc scan add filter failed!ret=%d", ret);
      }
    }
    //2. ʹ������ //2.1���
    else if(is_left)
    {
      add_suc = false;
    }
    //2.2�ұ�
    else
    {
      bool need_to_add_main_filter = false;
      uint64_t expr_temp_cid = OB_INVALID_ID;
      uint64_t expr_temp_tid = OB_INVALID_ID;
      uint64_t index_of_expr_array = OB_INVALID_ID;
      //1.1 get cid from expr
      //[742]
      if (OB_SUCCESS != (ret = expr_temp->get_cid(expr_temp_cid)))
      {
        YYSYS_LOG(ERROR, "try to find cid from expr failed,ret=%d",ret);
      }
      //1.2 check if is rowkey col
      else if (right_main_cid == expr_temp_cid)
      {
        need_to_add_main_filter = true;
      }
      //1.3 if can use index
      else if (false == is_this_expr_can_use_index_for_join(expr_temp_cid, expr_temp_tid,
                                                            right_table_id, sql_context_->schema_manager_))
      {
        need_to_add_main_filter = true;
      }
      //1.4 check index table id
      else if (index_table_id != expr_temp_tid)
      {
        need_to_add_main_filter = true;
      }
      //1.5
      else if (OB_SUCCESS != (ret = t_r_operator->add_main_filter(expr_temp)))
      {
        YYSYS_LOG(WARN, "[semi join] add expr to right table faild! ret=%d",ret);
      }
      //1.6 �ı�expr��table idΪ��������table id
      else if(OB_SUCCESS != (ret = expr_temp->change_tid(index_of_expr_array)))
      {
        YYSYS_LOG(ERROR, "[semi join] faild to change tid,filter=%s",to_cstring(*expr_temp));
      }
      else
      {
        ObObj &obj = expr_temp->get_decoded_expression_v2().get_expr_by_index(index_of_expr_array);
        if (ObIntType != obj.get_type())
        {
          ret = OB_ERR_UNEXPECTED;
          YYSYS_LOG(ERROR, "get tid obj from expr failed! ret = %d",ret);
        }
        else obj.set_int(index_table_id);
        if (OB_SUCCESS == ret)
        {
          if (OB_SUCCESS != (ret = t_r_operator->add_filter(expr_temp)))//���
          {
            YYSYS_LOG(WARN, "[semi join] add filter to right table faild! ret=%d",ret);
          }
          else if (OB_SUCCESS != (ret = t_r_operator->add_index_filter_ll((expr_temp))))
          {
            YYSYS_LOG(WARN, "[semi join] add index filter to right table faild! ret=%d",ret);
          }
        }
      }
      if (need_to_add_main_filter && OB_SUCCESS == ret)
      {
        if (OB_SUCCESS != (ret = t_r_operator->add_main_filter(expr_temp)))
        {
          YYSYS_LOG(WARN, "[semi join] faild to change tid,filter=%s", to_cstring(*expr_temp));
        }
        add_suc = false;
      }
    }
  }
  return ret;
}

int ObTransformer::get_project_and_filter_array(ObLogicalPlan *logical_plan, ObPhysicalPlan *physical_plan,
                                                const uint64_t table_id, ObSelectStmt *select_stmt,
                                                Expr_Array &project_array, Expr_Array &filter_array)
{
  int ret = OB_SUCCESS;
  ObBitSet<> table_bitset;
  if (NULL == logical_plan || NULL == physical_plan || NULL == select_stmt)
  {
    ret = OB_INVALID_ARGUMENT;
    YYSYS_LOG(ERROR, "logical_plan or physical_plan or select_stmt is null,ret = %d",ret);
  }
  else
  {
    if (false == table_bitset.add_member(select_stmt->get_table_bit_index(table_id)))
    {
      ret = OB_ERR_UNEXPECTED;
      YYSYS_LOG(ERROR, "add member into bitset failed,ret=%d",ret);
    }
    //1.get filter array
    for (int32_t i = 0; ret == OB_SUCCESS && i < select_stmt->get_condition_size(); i++)
    {
      ObSqlRawExpr *cnd_expr = logical_plan->get_expr(select_stmt->get_condition_id(i));
      if (cnd_expr && table_bitset.is_superset(cnd_expr->get_tables_set()))
      {
        ObSqlExpression filter;
        if (OB_SUCCESS != (ret = cnd_expr->fill_sql_expression(filter, this, logical_plan, physical_plan)))
        {
          YYSYS_LOG(ERROR, "Add table filter condition faild");
          break;
        }
        else if (OB_SUCCESS != (ret = filter_array.push_back(filter)))
        {
          YYSYS_LOG(ERROR, "push back to filter array failed");
          break;
        }
      }
    }//end for
    //2.get alias array and push into project array
    for (int32_t i=0; ret == OB_SUCCESS && i < select_stmt->get_select_item_size(); i++)
    {
      const SelectItem &select_item = select_stmt->get_select_item(i);
      if (select_item.is_real_alias_)
      {
        ObSqlRawExpr *alias_expr = logical_plan->get_expr(select_item.expr_id_);
        if (alias_expr && alias_expr->is_columnlized() == false
            && table_bitset.is_superset(alias_expr->get_tables_set()))
        {
          ObSqlExpression output_expr;
          if (OB_SUCCESS != (ret = alias_expr->fill_sql_expression(output_expr, this, logical_plan, physical_plan)))
          {
            YYSYS_LOG(ERROR, "Add table output columns faild");
            break;
          }
          else if (OB_SUCCESS != (ret = project_array.push_back(output_expr)))
          {
            YYSYS_LOG(ERROR, "push back to project array failed");
            break;
          }
        }
      }
    }
    //3. get project array
    for (int32_t i=0; ret == OB_SUCCESS && i < select_stmt->get_column_size(); i++)
    {
      const ColumnItem *col_item = select_stmt->get_column_item(i);
      if (col_item && col_item->table_id_ == table_id)
      {
        ObBinaryRefRawExpr col_expr(col_item->table_id_, col_item->column_id_, T_REF_COLUMN);
        ObSqlRawExpr col_raw_expr(OB_INVALID_ID, col_item->table_id_, col_item->column_id_, &col_expr);
        ObSqlExpression output_expr;
        if (OB_SUCCESS != (ret = col_raw_expr.fill_sql_expression(output_expr, this, logical_plan, physical_plan)))
        {
          YYSYS_LOG(ERROR, "Add table output columns faild");
          break;
        }
        else if (OB_SUCCESS != (ret = project_array.push_back(output_expr)))
        {
          YYSYS_LOG(ERROR, "push back to project array failed");
          break;
        }
      }
    }
  }
  return ret;
}

//add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
int ObTransformer::gen_physical_index_trigger_for_update(ObPhysicalPlan *&physical_plan,
                                                         ErrStat &err_stat,
                                                         ObIndexTriggerUpd *&index_trigger_upd, ObProject *&project_op,
                                                         uint64_t table_id, ObRowDesc &row_desc, ObRowDescExt &row_desc_ext, const ObRowkeyInfo *rowkey_info,
                                                         ObUpdateStmt *update_stmt, IndexList &out)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  //    UNUSED(project_op);
  ObArray<uint64_t> exists_columns ;
  int64_t size = project_op->get_output_column_size();
  for(int i =0 ; i < size ; i++)
  {
    exists_columns.push_back(project_op->get_output_columns().at(i).get_column_id());
    //        YYSYS_LOG(INFO,"TEST= %ld",project_op->get_output_columns().at(i).get_column_id());
  }
  if (NULL == CREATE_PHY_OPERRATOR(index_trigger_upd, ObIndexTriggerUpd, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator index_trigger_upd");
  }
  if(OB_LIKELY(OB_SUCCESS == ret)&&NULL != index_trigger_upd)
  {
    index_trigger_upd->set_update_index_num(out.get_count());
    index_trigger_upd->set_data_max_cid(sql_context_->schema_manager_->get_table_schema(table_id)->get_max_column_id());
    for(int64_t i = 0;i<out.get_count();i++)
    {
      const ObTableSchema* index_schema = NULL;
      uint64_t index_tid = OB_INVALID_ID;
      uint64_t index_cid = OB_INVALID_ID;
      out.get_idx_id(i,index_tid);
      if(index_tid != OB_INVALID_ID)
      {
        index_schema = sql_context_->schema_manager_->get_table_schema(index_tid);
        if(NULL == index_schema)
        {
          YYSYS_LOG(WARN,"get index schema failed!");
          ret = OB_SCHEMA_ERROR;
          break;
        }
        else
        {
          const ObRowkeyInfo ori = index_schema->get_rowkey_info();
          ObRowDesc ord_del,ord_upd;
          ord_del.reset();
          ord_upd.reset();
          ord_del.set_rowkey_cell_count(ori.get_size());
          ord_upd.set_rowkey_cell_count(ori.get_size());
          for(int64_t rowkey_index = 0;rowkey_index < ori.get_size();rowkey_index++)
          {
            if(OB_SUCCESS != (ret = ori.get_column_id(rowkey_index,index_cid)))
            {
              YYSYS_LOG(WARN,"get_column_id for rowkey failed!");
              ret = OB_ERROR;
              break;
            }
            else
            {
              if(OB_SUCCESS != (ret = ord_del.add_column_desc(index_tid,index_cid)))
              {
                YYSYS_LOG(WARN,"ord_del.add_column_desc occur an error,ret[%d]",ret);
              }
              else if(OB_SUCCESS != (ret = ord_upd.add_column_desc(index_tid,index_cid)))
              {
                YYSYS_LOG(WARN,"ord_upd.add_column_desc occur an error,ret[%d]",ret);
              }
            }
          }
          if(OB_SUCCESS == ret&&OB_SUCCESS != (ret = ord_del.add_column_desc(index_tid,OB_ACTION_FLAG_COLUMN_ID)))
          {
            YYSYS_LOG(WARN,"ord_upd.add_column_desc occur an error,ret[%d]",ret);
          }
          else
          {
            uint64_t max_column_id = index_schema->get_max_column_id();
            for (int64_t j = OB_APP_MIN_COLUMN_ID; j <= (int64_t)max_column_id;  j++)
            {
              const ObColumnSchemaV2* ocs=sql_context_->schema_manager_->get_column_schema(index_tid,j);
              if(ori.is_rowkey_column(j) || NULL == ocs)
              {}
              else
              {
                index_cid = ocs->get_id();
                if(OB_SUCCESS != (ret = ord_upd.add_column_desc(index_tid,index_cid)))
                {
                  YYSYS_LOG(ERROR,"error in add_column_desc");
                  break;
                }
              }
            }
            if(OB_SUCCESS == ret && sql_context_->schema_manager_->is_index_has_storing(index_tid))
            {
              ret = ord_upd.add_column_desc(index_tid, OB_INDEX_VIRTUAL_COLUMN_ID);
            }
          }
          if(OB_SUCCESS == ret&&(OB_SUCCESS != (ret = index_trigger_upd->add_row_desc_del(i,ord_del))||OB_SUCCESS != (ret = index_trigger_upd->add_row_desc_upd(i,ord_upd))))
          {
            YYSYS_LOG(ERROR,"construct row desc error");
            ret = OB_ERROR;
          }
        }
      }
    }
    if(OB_SUCCESS == ret)
    {
      row_desc.reset();
      row_desc_ext.reset();
      if(OB_SUCCESS != (ret = cons_del_upd_row_desc(update_stmt, table_id,row_desc,row_desc_ext)))
      {
        YYSYS_LOG(ERROR,"cons whole row desc error!");
        ret = OB_INVALID_ARGUMENT;
      }
    }
    if(OB_SUCCESS ==ret )
    {
      //������������������
      sql::ObSqlExpression sql_expression;
      sql::ExprItem item;
      int64_t column_size = row_desc.get_column_num();
      for(int64_t index = 0;index < column_size;index++)
      {
        uint64_t table_id  = OB_INVALID_ID ;
        uint64_t column_id  = OB_INVALID_ID ;
        if(OB_SUCCESS !=(ret = row_desc.get_tid_cid( index ,table_id,column_id)))
        {}
        else if(rowkey_info->is_rowkey_column(column_id))
        {
          continue;
        }
        else
        {
          size = exists_columns.count();
          bool found = false;
          for(int j = 0 ; j < size ;j++)
          {
            if(column_id == exists_columns.at(j))
            {
              //mod hongchen [ARRAY_SIZE_BUGFIX] 20170813:b
              //exists_columns.remove(j);
              found = true;
              break;
              //mod hongchen [ARRAY_SIZE_BUGFIX] 20170813:e
            }
          }
          if(found)
          {
            continue;
          }
          sql_expression.reset();
          item.value_.cell_.tid = table_id;
          item.value_.cell_.cid = column_id;
          item.type_ = T_REF_COLUMN;
          sql_expression.set_tid_cid(table_id, column_id);
          if (OB_SUCCESS != (ret = sql_expression.add_expr_item(item)))
          {
            YYSYS_LOG(WARN, "add_expr_item ret=%d, tid=%ld, cid=%ld", ret, table_id, column_id);
          }
          else if (OB_SUCCESS != (ret = sql_expression.add_expr_item_end()))
          {
            YYSYS_LOG(WARN, "add_expr_item_end ret=%d, tid=%ld, cid=%ld", ret, table_id, column_id);
          }
          else if (OB_SUCCESS != (ret = project_op->add_output_column(sql_expression)))
          {
            YYSYS_LOG(WARN, "add_output_column ret=%d, tid=%ld, cid=%ld", ret, table_id, column_id);
          }
        }
      }
    }
    if(OB_SUCCESS == ret)
    {
      int64_t index_num = 0;
      if(OB_SUCCESS != (ret = sql_context_->schema_manager_->get_all_modifiable_index_num(table_id, index_num)))
      {
        YYSYS_LOG(ERROR,"failed get all modifiable index num,table id=%ld  ret=[%d]",table_id ,ret);
      }
      else
      {
        index_trigger_upd->set_index_num(index_num);
        YYSYS_LOG(DEBUG,"TEST = %s",to_cstring(row_desc));
        index_trigger_upd->set_data_row_desc(row_desc);
      }
    }
  }
  return ret ;
}

int ObTransformer::gen_physical_index_trigger_for_replace(ObLogicalPlan *logical_plan, ObPhysicalPlan *&physical_plan,
                                                          ErrStat &err_stat,
                                                          ObIndexTriggerRep *&index_trigger_rep, ObRowDesc &row_desc,
                                                          ObRowDescExt &row_desc_ext, ObInsertStmt *insert_stmt,
                                                          const ObSEArray<int64_t, 64> &row_desc_map,
                                                          ObRowDesc row_desc_for_static_data,
                                                          ObRowDescExt row_desc_ext_for_static_data,
                                                          ObRowDesc &main_desc, const ObRowkeyInfo *rowkey_info)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  const ObTableSchema *data_table_schema = NULL;
  if (NULL == (data_table_schema = sql_context_->schema_manager_->get_table_schema(insert_stmt->get_table_id())))
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("fail to get table schema for table, table id=%ld", insert_stmt->get_table_id());
  }
  bool need_static_data = is_need_static_data_for_index(insert_stmt->get_table_id());

  ObIncScan *inc_scan = NULL;
  ObMultipleGetMerge *fuse_op = NULL;
  if (OB_SUCCESS == ret && need_static_data)
  {
    //add:e
    // construct table scan to get static data
    ObTableRpcScan *table_scan = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      ObRpcScanHint hint;
      hint.read_method_ = ObSqlReadStrategy::USE_GET;
      hint.is_get_skip_empty_row_ = false;
      hint.read_consistency_ = FROZEN;
      int64_t table_id = insert_stmt->get_table_id();
      CREATE_PHY_OPERRATOR(table_scan, ObTableRpcScan, physical_plan, err_stat);
      if (OB_UNLIKELY(OB_SUCCESS != ret))
      {
      }
      else if(OB_SUCCESS != (ret = cons_row_desc_with_index(insert_stmt->get_table_id(), insert_stmt, row_desc_ext_for_static_data, row_desc_for_static_data,rowkey_info, err_stat)))
      {
        TRANS_LOG("fail to cons row desc for static data, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = table_scan->set_table(table_id, table_id)))
      {
        TRANS_LOG("fail to set table id, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = table_scan->init(sql_context_, &hint)))
      {
        TRANS_LOG("fail to init table scan, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = gen_phy_static_data_scan_for_replace(logical_plan, physical_plan, err_stat,
                                                                         insert_stmt, row_desc_for_static_data, row_desc_map,
                                                                         table_id, *rowkey_info, *table_scan)))
      {
        TRANS_LOG("err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = physical_plan->add_base_table_version(
                                table_id,
                                data_table_schema->get_schema_version())))
      {
        TRANS_LOG("add base table version failed, table_id=%ld, err=%d", table_id, ret);
      }
      else
      {
        table_scan->set_rowkey_cell_count(row_desc.get_rowkey_cell_count());
        table_scan->set_cache_bloom_filter(true);
      }
    }
    // static data store into tmp table
    ObValues *tmp_table = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      CREATE_PHY_OPERRATOR(tmp_table, ObValues, physical_plan, err_stat);
      if (OB_UNLIKELY(OB_SUCCESS != ret))
      {
      }
      else if (OB_SUCCESS != (ret = tmp_table->set_child(0, *table_scan)))
      {
        YYSYS_LOG(WARN, "fail to set child, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = physical_plan->add_phy_query(tmp_table)))
      {
        YYSYS_LOG(WARN, "fail to add phy query, err=%d", ret);
      }
      //add by maosy [MultiUps 1.0] [secondary index optimize] 20170622 b:
      else
      {
        physical_plan->set_values_op_id(tmp_table->get_id());
      }
      //add by maosy
    }

    ObMemSSTableScan *static_data = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      CREATE_PHY_OPERRATOR(static_data, ObMemSSTableScan, physical_plan, err_stat);
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        static_data->set_tmp_table(tmp_table->get_id());
      }
    }
    // construct inc scan to get increased data
    //ObIncScan *inc_scan = NULL; //del liumz, [optimize replace index]20161110
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      CREATE_PHY_OPERRATOR(inc_scan, ObIncScan, physical_plan, err_stat);
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        inc_scan->set_scan_type(ObIncScan::ST_MGET);
        inc_scan->set_write_lock_flag();
      }
    }
    // merge static data and inc data
    //ObMultipleGetMerge *fuse_op = NULL; //del liumz, [optimize replace index]20161110
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      CREATE_PHY_OPERRATOR(fuse_op, ObMultipleGetMerge, physical_plan, err_stat);
      if (OB_UNLIKELY(OB_SUCCESS != ret))
      {
      }
      else if (OB_SUCCESS != (ret = fuse_op->set_child(0, *static_data)))
      {
        TRANS_LOG("fail to set child of fuse_op operator, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = fuse_op->set_child(1, *inc_scan)))
      {
        TRANS_LOG("fail to set child of fuse_op operator, err=%d", ret);
      }
      else
      {
        fuse_op->set_is_ups_row(false);
      }
    }
    if(OB_SUCCESS == ret)
    {
      for (int64_t key_col_num = 0; OB_SUCCESS == ret && key_col_num < rowkey_info->get_size(); key_col_num++)
      {
        uint64_t key_cid = OB_INVALID_ID;
        if (OB_SUCCESS != (ret = rowkey_info->get_column_id(key_col_num, key_cid)))
        {
          TRANS_LOG("cannot get rowkey id for get param values");
          break;
        }
        else
        {
          ObObjType cond_val_type;
          uint32_t cond_val_precision;
          uint32_t cond_val_scale;
          if (OB_SUCCESS != (ret = sql_context_->schema_manager_->get_cond_val_info(insert_stmt->get_table_id(), key_cid, cond_val_type, cond_val_precision, cond_val_scale)))
          {
            TRANS_LOG("get rowkey schema failed!");
            break;
          }
          else
          {
            tmp_table->add_rowkey_array(insert_stmt->get_table_id(), key_cid, cond_val_type, cond_val_precision, cond_val_scale);
          }
        }
      }
      tmp_table->set_fix_obvalues();
    }
  }
  // construct replace values from logical plan
  ObExprValues *input_values = NULL;
  ObExprValues *input_index_values = NULL;
  //ObRowDesc main_desc = row_desc;
  main_desc = row_desc;
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    CREATE_PHY_OPERRATOR(input_values, ObExprValues, physical_plan, err_stat);
    if (OB_UNLIKELY(OB_SUCCESS != ret))
    {
    }
    else if (OB_SUCCESS != (ret = physical_plan->add_phy_query(input_values)))
    {
      YYSYS_LOG(WARN, "fail to add phy query, err=%d", ret);
    }
    else if (OB_SUCCESS != (ret = input_values->set_row_desc(row_desc, row_desc_ext)))
    {
      TRANS_LOG("fail to set descriptor of values operator, err=%d", ret);
    }
    else if (OB_SUCCESS != (ret = gen_phy_values(logical_plan, physical_plan, err_stat, insert_stmt,
                                                 row_desc, row_desc_ext,&row_desc_map, *input_values)))
    {
      TRANS_LOG("fail to generate values, err=%d", ret);
    }
    else
    {
      //add shili [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20150721:b
      //����table_id  stmt_type �������ƻ�ִ�е�ʱ��ʹ��
      physical_plan->set_table_id(insert_stmt->get_table_id());
      physical_plan->set_stmt_type(ObBasicStmt::T_REPLACE);
      //add 20150721:e
      //modify by hushuang [Secondary Index] for replace bug:20161108
      //input_values->set_check_rowkey_duplicate(true);
      input_values->set_check_rowkey_duplicate_rep(true);
    }
  }

  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    CREATE_PHY_OPERRATOR(input_index_values, ObExprValues, physical_plan, err_stat);
    if (OB_UNLIKELY(OB_SUCCESS != ret))
    {
    }
    else if (OB_SUCCESS != (ret = physical_plan->add_phy_query(input_index_values)))
    {
      YYSYS_LOG(WARN, "fail to add phy query, err=%d", ret);
    }
    else if (OB_SUCCESS != (ret = gen_phy_values_idx(logical_plan, physical_plan, err_stat, insert_stmt,
                                                     row_desc, row_desc_ext, row_desc_for_static_data, row_desc_ext_for_static_data, &row_desc_map, *input_index_values)))
    {
      TRANS_LOG("fail to generate values, err=%d", ret);
    }
    else
    {
      //modify by hushuang [Secondary Index] for replace bug:20161108
      //input_index_values->set_check_rowkey_duplicate(true);
      input_index_values->set_check_rowkey_duplicate_rep(true);
      //add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20151124:b
      //            physical_plan->set_expr_values_op_id(input_values->get_id());
      physical_plan->set_expr_values_op_id(input_index_values->get_id());
      //add 20151124:e
    }
  }
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    CREATE_PHY_OPERRATOR(index_trigger_rep, ObIndexTriggerRep, physical_plan, err_stat);
    //add liumz, [optimize replace index]20161110:b
    if (need_static_data)
    {
      //add:e
      if (OB_UNLIKELY(OB_SUCCESS != ret))
      {
      }
      else if (OB_SUCCESS != (ret = index_trigger_rep->set_child(0, *fuse_op)))
      {
        TRANS_LOG("fail to set child of index_trigger_rep operator, err=%d", ret);
      }
      else
      {
        inc_scan->set_values(input_index_values->get_id(), false);
        //add hongchen [REPLACE_INDEX_OPT] 20170804:b
        index_trigger_rep->set_input_values(input_index_values->get_id());
        //for distribute
        physical_plan->set_expr_values_op_id(input_index_values->get_id());
        //save real replace values for index and data table
        const ObRowDesc* input_row_desc = NULL;
        input_values->get_row_desc(input_row_desc);
        index_trigger_rep->set_real_replace_column_desc(const_cast<ObRowDesc*>(input_row_desc));
        //
        index_trigger_rep->set_data_max_cid(data_table_schema->get_max_column_id());
        //for index_trigger_rep return correct column for upper operator
        index_trigger_rep->set_main_desc(main_desc);
        //add hongchen [REPLACE_INDEX_OPT] 20170804:e
      }
      //add liumz, [optimize replace index]20161110:b
    }
    else
    {
      if (OB_UNLIKELY(OB_SUCCESS != ret))
      {
      }
      else if (OB_SUCCESS != (ret = index_trigger_rep->set_child(0, *input_index_values)))
      {
        TRANS_LOG("fail to set child of index_trigger_rep operator, err=%d", ret);
      }
      else
      {
        //add hongchen [REPLACE_INDEX_OPT] 20170804:b
        index_trigger_rep->set_input_values(input_values->get_id());
        //for_fistribute
        physical_plan->set_expr_values_op_id(input_values->get_id());
        physical_plan->set_index_expr_values_op_id(input_index_values->get_id());
        //save real replace values for index and data table
        const ObRowDesc* input_row_desc = NULL;
        input_values->get_row_desc(input_row_desc);
        index_trigger_rep->set_real_replace_column_desc(const_cast<ObRowDesc*>(input_row_desc));
        //
        index_trigger_rep->set_data_max_cid(data_table_schema->get_max_column_id());
        index_trigger_rep->set_main_desc(main_desc);
        //add hongchen [REPLACE_INDEX_OPT] 20170804:e
      }
    }
    //add:e
  }

  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    uint64_t index_tid_array[OB_MAX_INDEX_NUMS];
    uint64_t index_num = 0;

    const ObTableSchema *index_schema = NULL;
    const ObRowkeyInfo *rowkey_info = NULL;
    //del hongchen [REPLACE_INDEX_OPT] 20170804:b
    //const ObColumnSchemaV2 *index_column_schema = NULL;
    //del hongchen [REPLACE_INDEX_OPT] 20170804:e

    uint64_t main_tid = insert_stmt->get_table_id();

    if (OB_SUCCESS != (ret = sql_context_->schema_manager_->get_all_modifiable_index_tid(main_tid, index_tid_array, index_num)))
    {
      YYSYS_LOG(WARN, "fail to get index array for table[%ld], err=%d", main_tid, ret);
    }
    else if (index_num > 0 && index_num <= static_cast<uint64_t>(OB_MAX_INDEX_NUMS))
    {
      index_trigger_rep->set_index_num(index_num);
      index_trigger_rep->set_main_tid(insert_stmt->get_table_id());
      for (uint64_t idx = 0; idx < index_num; idx++)
      {
        if (NULL == (index_schema = sql_context_->schema_manager_->get_table_schema(index_tid_array[idx])))
        {
          ret = OB_ERR_ILLEGAL_ID;
          YYSYS_LOG(ERROR, "fail to get index schema, index tid=%ld", index_tid_array[idx]);
          break;
        }
        else if (NULL == (rowkey_info = &index_schema->get_rowkey_info()))
        {
          ret = OB_ERROR;
          YYSYS_LOG(WARN, "fail to get index rowkey info");
          break;
        }
        else
        {
          uint64_t index_cid = OB_INVALID_ID;
          int64_t rowkey_col_num = rowkey_info->get_size();
          //del hongchen [REPLACE_INDEX_OPT] 20170804:b
          //uint64_t max_column_id = index_schema->get_max_column_id();
          //del hongchen [REPLACE_INDEX_OPT] 20170804:e

          ObRowDesc index_del_row_desc;
          ObRowDesc index_ins_row_desc;
          index_del_row_desc.reset();
          index_ins_row_desc.reset();
          index_del_row_desc.set_rowkey_cell_count(rowkey_col_num);
          index_ins_row_desc.set_rowkey_cell_count(rowkey_col_num);
          for (int64_t i = 0; i < rowkey_col_num; i++)// rowkey columns ==> row desc
          {
            if (OB_SUCCESS != (ret = rowkey_info->get_column_id(i, index_cid)))
            {
              YYSYS_LOG(WARN, "fail to get column id");
              ret = OB_ERROR;
              break;
            }
            else if (OB_SUCCESS != (ret = index_del_row_desc.add_column_desc(index_tid_array[idx], index_cid))) // rowkey column ==> index delete row desc
            {
              YYSYS_LOG(WARN, "fail to add column desc, err=%d", ret);
            }
            else if (OB_SUCCESS != (ret = index_ins_row_desc.add_column_desc(index_tid_array[idx], index_cid))) // rowkey column ==> index insert row desc
            {
              YYSYS_LOG(WARN, "fail to add column desc, err=%d", ret);
            }
          }//end for
          //del hongchen [REPLACE_INDEX_OPT] 20170804:b
          /*
                    for (index_cid = OB_APP_MIN_COLUMN_ID; OB_SUCCESS == ret && index_cid <= max_column_id; index_cid++)// other columns ==> row desc
                    {
                        if (NULL == (index_column_schema = sql_context_->schema_manager_->get_column_schema(index_tid_array[idx], index_cid)))
                        {
                            YYSYS_LOG(DEBUG, "fail to get column schema, index tid=%lu, cid=%lu", index_tid_array[idx], index_cid);
                        }
                        else if (rowkey_info->is_rowkey_column(index_cid))
                        {
                            YYSYS_LOG(DEBUG, "column in index is rowkey column, cid=%lu", index_cid);
                        }
                        else if (OB_SUCCESS != (ret = index_ins_row_desc.add_column_desc(index_tid_array[idx], index_cid))) // other column ==> index insert row desc
                        {
                            YYSYS_LOG(WARN, "fail to add column desc, err=%d", ret);
                            break;
                        }
                    }//end for
                    //add wenghaixing [secondary index alter_table_debug]20150611
                    if(OB_SUCCESS == ret && sql_context_->schema_manager_->is_index_has_storing(index_tid_array[idx]))
                    {
                        ret = index_ins_row_desc.add_column_desc(index_tid_array[idx], OB_INDEX_VIRTUAL_COLUMN_ID);
                    }
                    //add e
                    */
          //del hongchen [REPLACE_INDEX_OPT] 20170804:e
          if (OB_SUCCESS ==ret)
          {
            if (OB_SUCCESS != (ret = index_del_row_desc.add_column_desc(index_tid_array[idx], OB_ACTION_FLAG_COLUMN_ID)))// OB_ACTION_FLAG_COLUMN_ID ==> index delete row desc
            {
              YYSYS_LOG(WARN, "fail to add column desc, err=%d", ret);
            }
            else if (OB_SUCCESS != (ret = index_trigger_rep->add_index_del_row_desc(idx, index_del_row_desc)))
            {
              YYSYS_LOG(WARN, "fail to add index del row desc, err=%d", ret);
            }
            else if (OB_SUCCESS != (ret = index_trigger_rep->add_index_ins_row_desc(idx, index_ins_row_desc)))
            {
              YYSYS_LOG(WARN, "fail to add index ins row desc, err=%d", ret);
            }
          }
        }
      }
    }
    else
    {
      YYSYS_LOG(WARN, "illegal index num[%ld]", index_num);
      ret = OB_INVALID_ARGUMENT;
    }
  }
  return ret ;
}

//add by maosy 20170415 e
//add lijianqiang [MultiUPS] [PHYSICAL_PLAN_TRANSFORM] 20160408:b
int ObTransformer::wrap_new_physical_plan(ObPhysicalPlan *& new_plan, ErrStat &err_stat)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  new_plan = NULL;
  new_plan = (ObPhysicalPlan*)trans_malloc(sizeof(ObPhysicalPlan));
  if (NULL == new_plan)
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("no memory,ret=%d",ret);
  }
  else
  {
    new_plan = new(new_plan) ObPhysicalPlan();
    YYSYS_LOG(DEBUG, "new physical plan, addr=%p", new_plan);
  }
  return ret;
}

int ObTransformer::cons_full_row_desc(
    const uint64_t table_id,
    const ObRowDesc& raw_row_desc,
    const ObRowDescExt& raw_row_desc_ext,
    const ObSEArray<int64_t, 64> &raw_row_desc_map,
    ObRowDesc& cur_row_desc,
    ObRowDescExt& cur_row_desc_ext,
    ObSEArray<int64_t, 64> &cur_row_desc_map,
    ErrStat& err_stat)
{
  OB_ASSERT(sql_context_);
  OB_ASSERT(sql_context_->schema_manager_);
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  int32_t column_size = 0;
  const ObColumnSchemaV2* column = NULL;

  /**
   * In MultiUps,for UPDATE and REPLACE,we build three plans for each of both stmt,
   * this interface is used for cons the full_row_desc according the raw_row_desc,
   * we keep the raw_row_desc U input,and add remain columns which U not update according
   * the column_schema
   */
  if (NULL == (column = sql_context_->schema_manager_->get_table_schema(table_id, column_size)))
  {
    ret = OB_SCHEMA_ERROR;
    TRANS_LOG("get columns schema failed,table_id=%ld,ret=%d",table_id, ret);
  }
  else
  {
    //copy the raw row desc info
    cur_row_desc = raw_row_desc;
    cur_row_desc_ext = raw_row_desc_ext;
    cur_row_desc_map = raw_row_desc_map;
    //add the remain column
    ObObj data_type;
    uint64_t table_id = OB_INVALID_ID;
    uint64_t column_id = OB_INVALID_ID;
    int64_t schema_column_size = column_size;
    int64_t raw_column_size = raw_row_desc.get_column_num();

    for (int32_t i=0; OB_SUCCESS == ret && i<schema_column_size; i++)
    {
      int32_t local_count = 0;
      for (int32_t j=0; OB_SUCCESS == ret && j<raw_column_size; j++)
      {
        if (OB_SUCCESS != (ret = raw_row_desc.get_tid_cid(j, table_id, column_id)))
        {
          TRANS_LOG("get tid cid failed,ret=%d",ret);
          break;
        }
        else
        {
          if (column_id != column[i].get_id())
          {
            local_count ++;
          }
          else
          {
            break;
          }
          if (local_count == raw_column_size&&
              ObCreateTimeType != column[i].get_type() &&
              ObModifyTimeType != column[i].get_type()
              )
          {
            if (OB_SUCCESS != (ret = cur_row_desc.add_column_desc(table_id, column[i].get_id())))
            {
              TRANS_LOG("failed to add row desc, ret=%d",ret);
              break;
            }
            else if (OB_SUCCESS != (ret = cur_row_desc_map.push_back(cur_row_desc.get_column_num() - 1)))
            {
              TRANS_LOG("failed to push row desc map,ret=%d",ret);
              break;
            }
            else
            {
              data_type.set_type(column[i].get_type());
              data_type.set_precision(column[i].get_precision());
              data_type.set_scale(column[i].get_scale());
              if (OB_SUCCESS != (ret = cur_row_desc_ext.add_column_desc(table_id, column[i].get_id(), data_type)))
              {
                TRANS_LOG("failed to add row desc, ret=%d", ret);
                break;
              }
            }
          }
        }
      } //end for
    }//end for
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      YYSYS_LOG(DEBUG, "row_desc=%s ", to_cstring(cur_row_desc));
    }
  }

  return ret;
}

int ObTransformer::gen_physical_update_new_pre_execution_plan(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ObUpdateStmt * update_stmt,
    uint64_t table_id,
    const ObRowDesc& raw_row_desc,
    const ObRowDescExt& raw_row_desc_ext,
    const ObSEArray<int64_t, 64>& raw_row_desc_map,
    const ObRowkeyInfo *rowkey_info,
    ErrStat& err_stat,
    const uint64_t& query_id
    //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
    , IndexList &out)
// add by maosy e
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  int32_t *index = NULL;
  ObUpsModifyWithDmlType *ups_modify = NULL;
  ObProject *project_op = NULL;
  ObRowDesc cur_row_desc;
  ObRowDescExt cur_row_desc_ext;
  ObSEArray<int64_t, 64> cur_row_desc_map;
  ObPhysicalPlan *pre_execution_plan = NULL;
  ObUpsExecutor *ups_executor = NULL;

  YYSYS_LOG(DEBUG, "gen physical update pre execution plan");
  if (NULL == (ups_executor = dynamic_cast<ObUpsExecutor *> (physical_plan->get_phy_op_by_id_from_operator_store(physical_plan->get_ups_executor_op_id()))))
  {
    ret = OB_NOT_INIT;
    YYSYS_LOG(ERROR, "ups executor is not init,ret=%d", ret);
  }
  else if (OB_SUCCESS != (ret = wrap_new_physical_plan(pre_execution_plan, err_stat)))
  {
    TRANS_LOG("wrap pre execution physical plan failed,ret=%d",ret);
  }

  /* generate root operator */
  else if (NULL == CREATE_PHY_OPERRATOR(ups_modify, ObUpsModifyWithDmlType, pre_execution_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator,ret=%d",ret);
  }
  else if (OB_SUCCESS != (ret = pre_execution_plan->add_phy_query(
                            ups_modify,
                            index,/*NULL*/
                            physical_plan != pre_execution_plan)))
  {
    TRANS_LOG("Add ups_modify operator failed");
  }
  else if (NULL == CREATE_PHY_OPERRATOR(project_op, ObProject, pre_execution_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator");
  }
  else if (OB_SUCCESS != (ret = cons_full_row_desc(table_id,
                                                   raw_row_desc,
                                                   raw_row_desc_ext,
                                                   raw_row_desc_map,
                                                   cur_row_desc,
                                                   cur_row_desc_ext,
                                                   cur_row_desc_map,
                                                   err_stat)))
  {
    TRANS_LOG("cos full row desc failed, err=%d", ret);
  }
  else
  {
    ups_modify->set_dml_type(OB_DML_UPDATE);
    ups_executor->set_pre_execution_plan(pre_execution_plan);
    pre_execution_plan->set_table_id(table_id);
    pre_execution_plan->set_stmt_type(ObBasicStmt::T_UPDATE);
  }

  ObWhenFilter *when_filter_op = NULL;
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    if (update_stmt->get_when_expr_size() > 0)
    {
      if ((ret = gen_phy_when(logical_plan,
                              pre_execution_plan,
                              err_stat,
                              query_id,
                              *project_op,
                              when_filter_op
                              )) != OB_SUCCESS)
      {
      }
      else if ((ret = ups_modify->set_child(0, *when_filter_op)) != OB_SUCCESS)
      {
        TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
      }
    }
    //del by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
    //    else if (OB_SUCCESS != (ret = ups_modify->set_child(0, *project_op)))
    //    {
    //      TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
    //    }
    //del by maosy 20170415 e
  }

  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    if (OB_SUCCESS != (ret = add_set_clause_for_update_to_project(logical_plan, pre_execution_plan,
                                                                  project_op, raw_row_desc,
                                                                  rowkey_info, update_stmt,
                                                                  table_id, err_stat)))
    {
      TRANS_LOG("add setoperator failed, err=%d", ret);
    }
  }
  //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
  ObIndexTriggerUpd *index_trigger_upd = NULL;
  bool is_column_hint_index = false;
  if( out.get_count() >0)
  {
    is_column_hint_index =true ;
  }
  if(OB_SUCCESS == ret && is_column_hint_index)
  {
    if(OB_SUCCESS !=(ret = gen_physical_index_trigger_for_update(pre_execution_plan,err_stat,index_trigger_upd,
                                                                 project_op,table_id,cur_row_desc,
                                                                 cur_row_desc_ext,rowkey_info,update_stmt,out)))
    {
      YYSYS_LOG(WARN, "failed to gen index trigger,ret = %d", ret);
    }
    else if (OB_SUCCESS!=(ret = index_trigger_upd->set_child(0, *project_op)))
    {
      TRANS_LOG("Failed to set child, err=%d", ret);
    }
    //add by maosy [MultiUps 1.0] [sequence and secondary index ] 20170615 b
    // else if(OB_SUCCESS != (ret = gen_expr_array(update_stmt, index_trigger_upd, cur_row_desc, logical_plan, pre_execution_plan, err_stat)))
    else if(OB_SUCCESS != (ret = gen_expr_array(index_trigger_upd, project_op, err_stat)))
      // add by maosy e
    {
      YYSYS_LOG(WARN, "failed to gen expr_array,ret = %d", ret);
    }
  }
  if(OB_LIKELY(OB_SUCCESS == ret)&&update_stmt->get_when_expr_size()<=0)
  {
    if(!is_column_hint_index)
    {
      int64_t index_num = 0;
      if(OB_SUCCESS != (ret = sql_context_->schema_manager_->get_all_modifiable_index_num(table_id, index_num)))
      {
        TRANS_LOG("get all modifiable index_num failed, err=%d", ret);
      }
      else
      {
        project_op->set_index_num(index_num);
        if (OB_SUCCESS != (ret = ups_modify->set_child(0, *project_op)))
        {
          TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
        }
      }
    }
    else
    {
      if (OB_SUCCESS != (ret = ups_modify->set_child(0, *index_trigger_upd)))
      {
        TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
      }
    }
  }
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    if (OB_SUCCESS != (ret = cons_full_row_desc(table_id,
                                                raw_row_desc,
                                                raw_row_desc_ext,
                                                raw_row_desc_map,
                                                cur_row_desc,
                                                cur_row_desc_ext,
                                                cur_row_desc_map,
                                                err_stat)))
    {
      TRANS_LOG("const full row desc failed,ret=%d",ret);
    }
    //add hongchen [HOT_UPDATE_BUG_FIX] 20170724:b
    else if (is_column_hint_index && NULL != index_trigger_upd)
    {
      index_trigger_upd->set_data_row_desc(cur_row_desc);
    }
    //add hongchen [HOT_UPDATE_BUG_FIX] 20170724:e
  }
  //add by maosy 20170415 e
  ObPhyOperator* table_op = NULL;
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    if (OB_SUCCESS != (ret = gen_phy_table_for_pre_execution_plan(logical_plan, pre_execution_plan, err_stat,
                                                                  update_stmt, table_id, *rowkey_info,
                                                                  cur_row_desc, cur_row_desc_ext, table_op)))
    {
      TRANS_LOG("Failed to gen physical table for pre execution plna, err=%d", ret);
    }
  }
  //add wenghaixing [secondary index upd.bugfix]20150127
  if(OB_SUCCESS == ret && is_column_hint_index )
  {
    if( PHY_FILTER == table_op->get_type())
      index_trigger_upd->set_cond_bool(true);
    //      if(OB_SUCCESS !=(ret = cur_row_desc.add_column_desc(OB_INVALID_ID,OB_ACTION_FLAG_COLUMN_ID) ))
    //      {
    //          YYSYS_LOG(WARN,"failed to add column desc ,ret = %d,row desc = %s",ret ,to_cstring(cur_row_desc));
    //      }
    //      else
    //      {
    //          index_trigger_upd->set_data_row_desc(cur_row_desc);
    //      }
  }
  //add e
  ObIncompleteRowFilter * incomplete_row_filter = NULL;
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    if (NULL == CREATE_PHY_OPERRATOR(incomplete_row_filter, ObIncompleteRowFilter, pre_execution_plan, err_stat))
    {
      ret = OB_ALLOCATE_MEMORY_FAILED;
      TRANS_LOG("Failed to create phy operator,ret=%d",ret);
    }
  }

  //the ops for getting complete row info, just read,have no lock for inc scan
  ObPhyOperator * judge_complete_row_op = NULL;
  ObFilter * filter_op = NULL;
  ObIncScan * inc_scan_without_lock = NULL;
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    if (NULL == CREATE_PHY_OPERRATOR(inc_scan_without_lock, ObIncScan, pre_execution_plan, err_stat))
    {
      ret = OB_ALLOCATE_MEMORY_FAILED;
      TRANS_LOG("Failed to create phy operator,ret=%d",ret);
    }
    else if (PHY_FILTER == table_op->get_type())
    {
      // del by maosy [MultiUps 1.0] [#20] 20170324 b
      // judge_complete_row_op = filter_op;
      //del by maosy 20170324 e
      if (NULL == CREATE_PHY_OPERRATOR(filter_op, ObFilter, pre_execution_plan, err_stat))
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        TRANS_LOG("Failed to create phy operator,ret=%d",ret);
      }
      //clone the filter
      else if (OB_SUCCESS != (ret = filter_op->assign(table_op)))
      {
        TRANS_LOG("assign filter op failed,ret=%d",ret);
      }
      else if (OB_SUCCESS != (ret = filter_op->set_child(0, *inc_scan_without_lock)))
      {
        TRANS_LOG("Failed to set child, err=%d", ret);
      }
      // add by maosy [MultiUps 1.0] [#20] 20170324 b
      judge_complete_row_op = filter_op;
      //add by maosy 20170324 e
    }
    else
    {
      judge_complete_row_op = inc_scan_without_lock;
    }

    if (OB_SUCCESS == ret)
    {
      inc_scan_without_lock->set_scan_type(ObIncScan::ST_MGET);
      inc_scan_without_lock->set_values(pre_execution_plan->get_expr_values_op_id(), false);
      // add by maosy [MultiUps 1.0] [#20] 20170324 b
      inc_scan_without_lock->set_is_hot_update(true);
      //add by maosy 20170324 e
      if (OB_SUCCESS != (ret = incomplete_row_filter->set_child(0, *judge_complete_row_op)))
      {
        TRANS_LOG("Failed to set child of incomplete row filter, err=%d", ret);
      }
    }
  }

  ObUpdateSemanticFilter *update_sem_filter = NULL;
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    if (NULL == CREATE_PHY_OPERRATOR(update_sem_filter, ObUpdateSemanticFilter, pre_execution_plan, err_stat))
    {
      ret = OB_ALLOCATE_MEMORY_FAILED;
      TRANS_LOG("Failed to create phy operator,ret=%d",ret);
    }
    else if (OB_SUCCESS != (ret = project_op->set_child(0, *update_sem_filter)))
    {
      TRANS_LOG("Set child of project operator failed, err=%d", ret);
    }
    else if (OB_SUCCESS != (ret = update_sem_filter->set_child(0, *incomplete_row_filter)))
    {
      TRANS_LOG("Set child of project operator failed, err=%d", ret);
    }
    else if (OB_SUCCESS != (ret = update_sem_filter->set_child(1, *table_op)))
    {
      TRANS_LOG("Set child of project operator failed, err=%d", ret);
    }
  }
  return ret;
}

int ObTransformer::gen_phy_table_for_pre_execution_plan(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan*& physical_plan,
    ErrStat& err_stat,
    ObStmt *stmt,
    uint64_t table_id,
    const ObRowkeyInfo &rowkey_info,
    const ObRowDesc &row_desc,
    const ObRowDescExt &row_desc_ext,
    ObPhyOperator*& table_op)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  TableItem* table_item = NULL;
  ObFilter *filter_op = NULL;
  ObIncScan *inc_scan_op = NULL;

  ObExprValues* get_param_values = NULL;
  const ObTableSchema *table_schema = NULL;
  ObObj rowkey_objs[OB_MAX_ROWKEY_COLUMN_NUMBER]; // used for constructing GetParam
  ObPostfixExpression::ObPostExprNodeType type_objs[OB_MAX_ROWKEY_COLUMN_NUMBER];
  ModuleArena rowkey_alloc(OB_MAX_VARCHAR_LENGTH, ModulePageAllocator(ObModIds::OB_SQL_TRANSFORMER));
  ObCellInfo cell_info;
  cell_info.table_id_ = table_id;
  cell_info.row_key_.assign(rowkey_objs, rowkey_info.get_size());
  bool has_other_cond = false;

  if (OB_INVALID_ID == table_id
      || NULL == (table_item = stmt->get_table_item_by_id(table_id))
      || TableItem::BASE_TABLE != table_item->type_)
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("Wrong table id, tid=%lu", table_id);
  }
  else if (NULL == CREATE_PHY_OPERRATOR(filter_op, ObFilter, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator,ret=%d",ret);
  }
  else if (NULL == CREATE_PHY_OPERRATOR(inc_scan_op, ObIncScan, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator,ret=%d",ret);
  }
  else if (NULL == CREATE_PHY_OPERRATOR(get_param_values, ObExprValues, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator,ret=%d",ret);
  }
  else if (OB_SUCCESS != (ret = physical_plan->add_phy_query(get_param_values)))
  {
    YYSYS_LOG(WARN, "failed to add sub query, err=%d", ret);
  }
  else if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_id)))
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("Fail to get table schema for table[%ld]", table_id);
  }
  else if ((ret = physical_plan->add_base_table_version(
              table_id,
              table_schema->get_schema_version()
              )) != OB_SUCCESS)
  {
    TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d", table_id, ret);
  }
  /// @note wrap the add filter process to a function
  else if (OB_SUCCESS != (ret = add_condition_to_filter(logical_plan, physical_plan, stmt,
                                                        rowkey_info, filter_op, rowkey_alloc,
                                                        rowkey_objs, type_objs, has_other_cond ,err_stat)))
  {
    TRANS_LOG("add condition to filter failed,ret=%d",ret);
  }
  else
  {
    inc_scan_op->set_scan_type(ObIncScan::ST_MGET);
    inc_scan_op->set_write_lock_flag();
    // mod by maosy [MultiUps 1.0] [#20] 20170324 b
    //inc_scan_op->set_hotspot(stmt->get_query_hint().hotspot_);
    inc_scan_op->set_is_hot_update(true);
    //add by maosy 20170324 e
    inc_scan_op->set_values(get_param_values->get_id(), false);
    get_param_values->set_row_desc(row_desc, row_desc_ext);
    physical_plan->set_expr_values_op_id(get_param_values->get_id());
  }

  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    /// @note wrap add out put info to ObExprvalues for inc scan to a function
    // add output columns
    if (OB_SUCCESS != (ret = add_out_put_column_for_inc_scan(logical_plan, physical_plan, err_stat,
                                                             row_desc, rowkey_info, rowkey_objs,
                                                             type_objs, get_param_values)))
    {
      TRANS_LOG("Failed to add out put column for inc scan to exprvalus, err=%d", ret);
    }
  }

  if (ret == OB_SUCCESS)
  {
    if (has_other_cond)
    {
      if (OB_SUCCESS != (ret = filter_op->set_child(0, *inc_scan_op)))
      {
        TRANS_LOG("Failed to set child, err=%d", ret);
      }
      else
      {
        table_op = filter_op;
      }
    }
    else
    {
      table_op = inc_scan_op;
    }
  }
  return ret;
}


int ObTransformer::add_condition_to_filter(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ObStmt *stmt,
    const ObRowkeyInfo &rowkey_info,
    ObFilter * filter_op,
    ModuleArena& rowkey_alloc,
    ObObj * rowkey_objs,
    ObPostfixExpression::ObPostExprNodeType * type_objs,
    bool& has_other_cond,
    ErrStat& err_stat)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObRowDesc rowkey_col_map;
  int32_t num = stmt->get_condition_size();
  uint64_t cid = OB_INVALID_ID;
  int64_t cond_op = T_INVALID;
  ObObj cond_val;
  ObPostfixExpression::ObPostExprNodeType val_type = ObPostfixExpression::BEGIN_TYPE;
  int64_t rowkey_idx = OB_INVALID_INDEX;
  ObRowkeyColumn rowkey_col;
  for (int32_t i = 0; i < num; i++)
  {
    ObSqlRawExpr *cnd_expr = logical_plan->get_expr(stmt->get_condition_id(i));
    OB_ASSERT(cnd_expr);
    cnd_expr->set_applied(true);
    ObSqlExpression *filter = ObSqlExpression::alloc();
    if (NULL == filter)
    {
      TRANS_LOG("no memory");
      ret = OB_ALLOCATE_MEMORY_FAILED;
      break;
    }
    else if (OB_SUCCESS != (ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan)))
    {
      ObSqlExpression::free(filter);
      TRANS_LOG("Failed to fill expression, err=%d", ret);
      break;
    }
    else if (filter->is_simple_condition(false, cid, cond_op, cond_val, &val_type)
             && (T_OP_EQ == cond_op || T_OP_IS == cond_op)
             && rowkey_info.is_rowkey_column(cid))
    {
      if(T_OP_EQ == cond_op && cond_val.is_null())
      {
        ObSqlExpression *primary_key_null_filter = ObSqlExpression::alloc();
        if(NULL == primary_key_null_filter)
        {
          TRANS_LOG("no memory");
          ret = OB_ALLOCATE_MEMORY_FAILED;
          break;
        }
        *primary_key_null_filter = *filter;
        has_other_cond = true;
        YYSYS_LOG(INFO, "where:primary key = NULL");
        if (OB_SUCCESS != (ret = filter_op->add_filter(primary_key_null_filter)))
        {
          ObSqlExpression::free(primary_key_null_filter);
          TRANS_LOG("Failed to add filter, err=%d", ret);
          break;
        }
      }
      //mod hongchen [SQL_EXPR_MEM_LEAK_FIX] 20170811:b
      if (OB_SUCCESS != (ret = rowkey_col_map.add_column_desc(OB_INVALID_ID, cid)))
      {
        TRANS_LOG("Failed to add column desc, err=%d", ret);
        //break;
      }
      else if (OB_SUCCESS != (ret = rowkey_info.get_index(cid, rowkey_idx, rowkey_col)))
      {
        TRANS_LOG("Unexpected branch");
        ret = OB_ERR_UNEXPECTED;
        //break;
      }
      else if (OB_SUCCESS != (ret = ob_write_obj(rowkey_alloc, cond_val, rowkey_objs[rowkey_idx]))) // deep copy
      {
        TRANS_LOG("failed to copy cell, err=%d", ret);
      }
      else
      {
        type_objs[rowkey_idx] = val_type;
        YYSYS_LOG(DEBUG, "rowkey obj, i=%ld val=%s", rowkey_idx, to_cstring(cond_val));
      }
      ObSqlExpression::free(filter);
      if (OB_SUCCESS != ret)
      {
        break;
      }
      //mod hongchen [SQL_EXPR_MEM_LEAK_FIX] 20170811:e
    }
    else
    {
      // other condition
      has_other_cond = true;
      if (OB_SUCCESS != (ret = filter_op->add_filter(filter)))
      {
        ObSqlExpression::free(filter);  //add hongchen [SQL_EXPR_MEM_LEAK_FIX] 20170811
        TRANS_LOG("Failed to add filter, err=%d", ret);
        break;
      }
    }
  } // end for

  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    int64_t rowkey_col_num = rowkey_info.get_size();
    uint64_t cid = OB_INVALID_ID;
    for (int64_t i = 0; i < rowkey_col_num; ++i)
    {
      if (OB_SUCCESS != (ret = rowkey_info.get_column_id(i, cid)))
      {
        TRANS_LOG("Failed to get column id, err=%d", ret);
        break;
      }
      else if (OB_INVALID_INDEX == rowkey_col_map.get_idx(OB_INVALID_ID, cid))
      {
        TRANS_LOG("Primary key column %lu not specified in the WHERE clause", cid);
        ret = OB_ERR_LACK_OF_ROWKEY_COL;
        break;
      }
    } // end for
  }
  return ret;
}

int ObTransformer::add_out_put_column_for_inc_scan(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan*& physical_plan,
    ErrStat& err_stat,
    const ObRowDesc& row_desc,
    const ObRowkeyInfo &rowkey_info,
    ObObj *rowkey_objs,
    ObPostfixExpression::ObPostExprNodeType * type_objs,
    ObExprValues * get_param_values)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  int64_t num = row_desc.get_column_num();
  uint64_t tid = OB_INVALID_ID;
  uint64_t cid = OB_INVALID_ID;
  OB_ASSERT(rowkey_objs);
  OB_ASSERT(type_objs);
  OB_ASSERT(get_param_values);
  for (int64_t i = 0; ret == OB_SUCCESS && i < num; i++)
  {
    if (OB_SUCCESS != (ret = row_desc.get_tid_cid(i, tid, cid)))
    {
      TRANS_LOG("get tid cid failed,ret=%d",ret);
    }
    else
    {
      // for IncScan
      ObConstRawExpr col_expr2;
      if (i < rowkey_info.get_size()) // rowkey column
      {
        if (OB_SUCCESS != (ret = col_expr2.set_value_and_type(rowkey_objs[i])))
        {
          YYSYS_LOG(WARN, "failed to set value, err=%d", ret);
          break;
        }
        else
        {
          switch (type_objs[i])
          {
            case ObPostfixExpression::PARAM_IDX:
              col_expr2.set_expr_type(T_QUESTIONMARK);
              col_expr2.set_result_type(ObVarcharType);
              break;
            case ObPostfixExpression::SYSTEM_VAR:
              col_expr2.set_expr_type(T_SYSTEM_VARIABLE);
              col_expr2.set_result_type(ObVarcharType);
              break;
            case ObPostfixExpression::TEMP_VAR:
              col_expr2.set_expr_type(T_TEMP_VARIABLE);
              col_expr2.set_result_type(ObVarcharType);
              break;
            default:
              break;
          }
        }
      }
      else
      {
        ObObj null_obj;
        col_expr2.set_value_and_type(null_obj);
      }
      ObSqlRawExpr col_raw_expr2(
            common::OB_INVALID_ID,
            tid,
            cid,
            &col_expr2);
      ObSqlExpression output_expr2;
      if ((ret = col_raw_expr2.fill_sql_expression(
             output_expr2,
             this,
             logical_plan,
             physical_plan)) != OB_SUCCESS)
      {
        TRANS_LOG("Add table output columns failed");
        break;
      }
      else if (OB_SUCCESS != (ret = get_param_values->add_value(output_expr2)))
      {
        TRANS_LOG("Failed to add cell into get param, err=%d", ret);
        break;
      }
    }
  }// end for
  return ret;
}

int ObTransformer::gen_physical_update_new_full_row_execution_plan(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ObUpdateStmt * update_stmt,
    uint64_t table_id,
    const ObRowDesc& raw_row_desc,
    const ObRowDescExt& raw_row_desc_ext,
    const ObSEArray<int64_t, 64>& raw_row_desc_map,
    const ObRowkeyInfo *rowkey_info,
    ErrStat& err_stat,
    const uint64_t& query_id
    //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
    , IndexList &out)
// add by maosy e
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  int32_t *index = NULL;
  ObUpsModifyWithDmlType *ups_modify = NULL;
  ObProject *project_op = NULL;
  ObRowDesc cur_row_desc;
  ObRowDescExt cur_row_desc_ext;
  ObSEArray<int64_t, 64> cur_row_desc_map;
  ObPhysicalPlan *full_row_execution_plan = NULL;
  ObUpsExecutor *ups_executor = NULL;

  YYSYS_LOG(DEBUG, "gen physical update full row execution plan");
  if (NULL == (ups_executor = dynamic_cast<ObUpsExecutor *> (physical_plan->get_phy_op_by_id_from_operator_store(physical_plan->get_ups_executor_op_id()))))
  {
    ret = OB_NOT_INIT;
    YYSYS_LOG(ERROR, "ups executor is not init,ret=%d", ret);
  }
  else if (OB_SUCCESS != (ret = wrap_new_physical_plan(full_row_execution_plan, err_stat)))
  {
    TRANS_LOG("wrap full execution physical plan failed,ret=%d",ret);
  }

  /* generate root operator */
  else if (NULL == CREATE_PHY_OPERRATOR(ups_modify, ObUpsModifyWithDmlType, full_row_execution_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator,ret=%d",ret);
  }
  else if (OB_SUCCESS != (ret = full_row_execution_plan->add_phy_query(
                            ups_modify,
                            index,/*NULL*/
                            physical_plan != full_row_execution_plan)))
  {
    TRANS_LOG("Add ups_modify operator failed");
  }
  else if (NULL == CREATE_PHY_OPERRATOR(project_op, ObProject, full_row_execution_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator");
  }
  //del by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
  //  else if (OB_SUCCESS != (ret = cons_full_row_desc(table_id,
  //                                                   raw_row_desc,
  //                                                   raw_row_desc_ext,
  //                                                   raw_row_desc_map,
  //                                                   cur_row_desc,
  //                                                   cur_row_desc_ext,
  //                                                   cur_row_desc_map,
  //                                                   err_stat)))
  //  {
  //    TRANS_LOG("const full row desc failed,ret=%d",ret);
  //  }
  //del e
  else
  {
    ups_modify->set_dml_type(OB_DML_UPDATE);
    ups_executor->set_full_row_execution_plan(full_row_execution_plan);
    full_row_execution_plan->set_table_id(table_id);
    full_row_execution_plan->set_stmt_type(ObBasicStmt::T_UPDATE);
  }


  ObWhenFilter *when_filter_op = NULL;
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    if (update_stmt->get_when_expr_size() > 0)
    {
      if ((ret = gen_phy_when(logical_plan,
                              full_row_execution_plan,
                              err_stat,
                              query_id,
                              *project_op,
                              when_filter_op
                              )) != OB_SUCCESS)
      {
      }
      else if ((ret = ups_modify->set_child(0, *when_filter_op)) != OB_SUCCESS)
      {
        TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
      }
    }
    //del by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
    //    else if (OB_SUCCESS != (ret = ups_modify->set_child(0, *project_op)))
    //    {
    //      TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
    //    }
    //del by maosy 20170415 e
  }

  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    //wrap add set clause of update stmt to project as a function
    if (OB_SUCCESS != (ret = add_set_clause_for_update_to_project(logical_plan,
                                                                  full_row_execution_plan,
                                                                  project_op,
                                                                  raw_row_desc,
                                                                  rowkey_info,
                                                                  update_stmt,
                                                                  table_id,
                                                                  err_stat)))
    {
      TRANS_LOG("add set clause for update to project failed, err=%d", ret);
    }
  }
  //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
  ObIndexTriggerUpd *index_trigger_upd = NULL;
  bool is_column_hint_index = false;
  if(out.get_count() >0)
  {
    is_column_hint_index =true;
  }
  if(OB_SUCCESS == ret && is_column_hint_index)
  {
    if(OB_SUCCESS !=(ret = gen_physical_index_trigger_for_update(full_row_execution_plan,err_stat,
                                                                 index_trigger_upd,project_op,table_id,
                                                                 cur_row_desc,cur_row_desc_ext,rowkey_info,update_stmt,out)))
    {
      YYSYS_LOG(WARN, "failed to gen index trigger,ret = %d", ret);
    }
    else if (OB_SUCCESS!=(ret = index_trigger_upd->set_child(0, *project_op)))
    {
      TRANS_LOG("Failed to set child, err=%d", ret);
    }
    //add by maosy [MultiUps 1.0] [sequence and secondary index ] 20170615 b
    //else if(OB_SUCCESS != (ret = gen_expr_array(update_stmt, index_trigger_upd, raw_row_desc, logical_plan, full_row_execution_plan, err_stat)))
    else if(OB_SUCCESS != (ret = gen_expr_array(index_trigger_upd, project_op, err_stat)))
      // add by maosy e
    {
      YYSYS_LOG(WARN, "failed to gen expr_array,ret = %d", ret);
    }
  }
  if(OB_LIKELY(OB_SUCCESS == ret)&&update_stmt->get_when_expr_size()<=0)
  {
    if(!is_column_hint_index)
    {
      int64_t index_num = 0;
      if(OB_SUCCESS != (ret = sql_context_->schema_manager_->get_all_modifiable_index_num(table_id, index_num)))
      {
        TRANS_LOG("get all modifiable index_num failed, err=%d", ret);
      }
      else
      {
        project_op->set_index_num(index_num);
        if (OB_SUCCESS != (ret = ups_modify->set_child(0, *project_op)))
        {
          TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
        }
      }
    }
    else
    {
      if (OB_SUCCESS != (ret = ups_modify->set_child(0, *index_trigger_upd)))
      {
        TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
      }
    }
  }
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    if (OB_SUCCESS != (ret = cons_full_row_desc(table_id,
                                                raw_row_desc,
                                                raw_row_desc_ext,
                                                raw_row_desc_map,
                                                cur_row_desc,
                                                cur_row_desc_ext,
                                                cur_row_desc_map,
                                                err_stat)))
    {
      TRANS_LOG("const full row desc failed,ret=%d",ret);
    }
  }
  //add by maosy  20170415 e
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    ObPhyOperator* table_op = NULL;
    //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
    if(is_column_hint_index )
    {
      if (OB_SUCCESS != (ret = gen_phy_table_for_update_v2(logical_plan, full_row_execution_plan, err_stat,
                                                           update_stmt, table_id, *rowkey_info,
                                                           raw_row_desc, raw_row_desc_ext, table_op)))
      {
        TRANS_LOG("gen phy table for update in full row execution failed,ret=%d",ret);
      }
      //add wenghaixing [secondary index upd.bugfix]20150127
      if(OB_SUCCESS == ret  )
      {
        if( PHY_FILTER == table_op->get_type())
          index_trigger_upd->set_cond_bool(true);
      }
      //add e
    }
    //add by maosy  20170415 e
    else if (OB_SUCCESS != (ret = gen_phy_table_for_update(logical_plan, full_row_execution_plan, err_stat,
                                                           update_stmt, table_id, *rowkey_info,
                                                           raw_row_desc, raw_row_desc_ext, table_op)))
    {
      TRANS_LOG("gen phy table for update in full row execution failed,ret=%d",ret);
    }
    // fill unchanged column(s) of update to relevant op
    if(OB_SUCCESS !=ret )
    {}
    else if (OB_SUCCESS != (ret = fill_unchanged_column_info_for_update(full_row_execution_plan,
                                                                        project_op,
                                                                        cur_row_desc,
                                                                        cur_row_desc_ext,
                                                                        raw_row_desc.get_column_num(),
                                                                        err_stat)))
    {
      TRANS_LOG("Failed to fill unchanged columns for full row update, err=%d", ret);
    }
    else if (OB_SUCCESS != (ret = project_op->set_child(0, *table_op)))
    {
      TRANS_LOG("Failed to set child, err=%d", ret);
    }
    //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
    else if(is_column_hint_index)
    {
      index_trigger_upd->set_data_row_desc(cur_row_desc);
    }
  }
  //add by maosy 20170415 e
  return ret;
}

//replace pre plan
int ObTransformer::gen_physical_replace_pre_execution_plan(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ObInsertStmt *insert_stmt,
    uint64_t table_id,
    const ObRowDesc& raw_row_desc,
    const ObRowDescExt& raw_row_desc_ext,
    const ObSEArray<int64_t, 64>& raw_row_desc_map,
    ErrStat&err_stat,
    const uint64_t& query_id
    //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
    , bool is_column_hint_index)
//add by maosy e
{
  /**
   * PRE_EXECUTION_PLAN for replace stmt,only when the table is hot table or rule changed table,
   * meanwhile the replacing rows is not complete, we execute the pre plan,first the plan will
   * cons complete row info for each row U want update in UPS,if can't cons complete rows,just
   * return and execute the full row execution plan for the complete rows U want replace(update).
   */
  //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
  UNUSED(is_column_hint_index);
  // add by maosy e
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  int32_t *index = NULL;
  ObUpsModify *ups_modify = NULL;
  ObRowDesc cur_row_desc;
  ObRowDescExt cur_row_desc_ext;
  ObSEArray<int64_t, 64> cur_row_desc_map;
  ObPhysicalPlan *pre_execution_plan = NULL;
  ObUpsExecutor *ups_executor = NULL;

  YYSYS_LOG(DEBUG, "gen physical replace pre execution plan");
  if (NULL == (ups_executor = dynamic_cast<ObUpsExecutor *> (physical_plan->get_phy_op_by_id_from_operator_store(physical_plan->get_ups_executor_op_id()))))
  {
    ret = OB_NOT_INIT;
    YYSYS_LOG(ERROR, "ups executor is not init,ret=%d", ret);
  }
  else if (OB_SUCCESS != (ret = wrap_new_physical_plan(pre_execution_plan, err_stat)))
  {
    TRANS_LOG("wrap pre execution physical plan failed,ret=%d",ret);
  }

  /* generate root operator */
  else if (NULL == CREATE_PHY_OPERRATOR(ups_modify, ObUpsModify, pre_execution_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator,ret=%d",ret);
  }
  else if (OB_SUCCESS != (ret = pre_execution_plan->add_phy_query(
                            ups_modify,
                            index,/*NULL*/
                            physical_plan != pre_execution_plan)))
  {
    TRANS_LOG("Add ups_modify operator failed");
  }
  else if (OB_SUCCESS != (ret = cons_full_row_desc(table_id,
                                                   raw_row_desc,
                                                   raw_row_desc_ext,
                                                   raw_row_desc_map,
                                                   cur_row_desc,
                                                   cur_row_desc_ext,
                                                   cur_row_desc_map,
                                                   err_stat)))
  {
    TRANS_LOG("cos full row desc failed, err=%d", ret);
  }
  else
  {
    ups_executor->set_pre_execution_plan(pre_execution_plan);
    pre_execution_plan->set_table_id(table_id);
    pre_execution_plan->set_stmt_type(ObBasicStmt::T_REPLACE);
  }


  ObReplaceSemanticFilter *replace_semantic_filter = NULL;
  if (ret == OB_SUCCESS)
  {
    ObExprValues *value_op = NULL;
    if (OB_LIKELY(insert_stmt->get_insert_query_id() == OB_INVALID_ID))
    {
      if (NULL == CREATE_PHY_OPERRATOR(value_op, ObExprValues, pre_execution_plan, err_stat))
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        TRANS_LOG("Failed to create phy operator,ret=%d",ret);
      }
      else if (OB_SUCCESS != (ret = value_op->set_row_desc(raw_row_desc, raw_row_desc_ext)))
      {
        TRANS_LOG("Set descriptor of value operator failed");
      }
      else if (OB_SUCCESS != (ret = gen_phy_values(logical_plan, pre_execution_plan, err_stat, insert_stmt,
                                                   raw_row_desc, raw_row_desc_ext, &raw_row_desc_map, *value_op)))
      {
        TRANS_LOG("Failed to gen expr values, err=%d", ret);
      }
      else if (OB_SUCCESS != (add_unchanged_column_to_expr_values(*value_op, cur_row_desc, raw_row_desc.get_column_num(), err_stat)))
      {
        TRANS_LOG("add unchanged column to get param values failed");
      }
      else if (OB_SUCCESS != (ret = value_op->set_row_desc(cur_row_desc, cur_row_desc_ext)))
      {
        TRANS_LOG("Set the new descriptor of value operator failed");
      }
      else if (OB_SUCCESS != (ret = pre_execution_plan->add_phy_query(value_op)))
      {
        TRANS_LOG("add to phy query failed,ret=%d",ret);
      }
      else
      {
        pre_execution_plan->set_expr_values_op_id(value_op->get_id());
      }

      //judge the rows is complete rows or not,only read data,do not need write lock
      ObIncScan *inc_scan_without_write_lock = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        if (NULL == CREATE_PHY_OPERRATOR(inc_scan_without_write_lock, ObIncScan, pre_execution_plan, err_stat))
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
          TRANS_LOG("Failed to create phy operator,ret=%d",ret);
        }
        else if (OB_LIKELY(OB_SUCCESS == ret))
        {
          inc_scan_without_write_lock->set_scan_type(ObIncScan::ST_MGET);
          inc_scan_without_write_lock->set_values(value_op->get_id(), false);//need the whole row
        }
      }

      ObIncompleteRowFilter * incomplete_row_filter = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        if (NULL == CREATE_PHY_OPERRATOR(incomplete_row_filter, ObIncompleteRowFilter, pre_execution_plan, err_stat))
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
          TRANS_LOG("Failed to create phy operator,ret=%d",ret);
        }
        else if ((ret = incomplete_row_filter->set_child(0, *inc_scan_without_write_lock)) != OB_SUCCESS)
        {
          TRANS_LOG("Set child of ObIncompleteRowFilter operator failed, err=%d", ret);
        }
      }

      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        if (NULL == CREATE_PHY_OPERRATOR(replace_semantic_filter, ObReplaceSemanticFilter, pre_execution_plan, err_stat))
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
          TRANS_LOG("Failed to create phy operator,ret=%d",ret);
        }
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          if (OB_SUCCESS != (ret = replace_semantic_filter->set_child(0, *incomplete_row_filter)))
          {
            TRANS_LOG("Set first child of ObReplaceSemanticFilter operator failed, err=%d", ret);
          }
          else
          {
            replace_semantic_filter->set_input_values(value_op->get_id());
            //need the raw row desc to cut the null cell we just added which gets full row info in ups
            replace_semantic_filter->set_raw_row_desc(raw_row_desc);
          }
        }
      }
    }
    else
    {
      // replace ... select
      TRANS_LOG("REPLACE INTO ... SELECT is not supported yet");
      ret = OB_NOT_SUPPORTED;
    }
  }

  if (OB_SUCCESS == ret)
  {
    ObWhenFilter *when_filter_op = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      if (insert_stmt->get_when_expr_size() > 0)
      {
        if ((ret = gen_phy_when(logical_plan,
                                pre_execution_plan,
                                err_stat,
                                query_id,
                                *replace_semantic_filter,
                                when_filter_op
                                )) != OB_SUCCESS)
        {
        }
        else if ((ret = ups_modify->set_child(0, *when_filter_op)) != OB_SUCCESS)
        {
          TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
        }
      }
      else if ((ret = ups_modify->set_child(0, *replace_semantic_filter)) != OB_SUCCESS)
      {
        TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
      }
    }
  }
  return ret;
}

//replace full row plan
int ObTransformer::gen_physical_replace_full_row_execution_plan(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ObInsertStmt *insert_stmt,
    uint64_t table_id,
    const ObRowDesc& raw_row_desc,
    const ObRowDescExt& raw_row_desc_ext,
    const ObSEArray<int64_t, 64>& raw_row_desc_map,
    const ObRowkeyInfo *rowkey_info,
    ErrStat& err_stat,
    const uint64_t& query_id
    //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
    , bool is_column_hint_index)
//add by maosy e
{
  /**
   * IN MultiUPs REPALCE,for hot table and rule change table: if repalce the complete row,
   * there is no difference,execute the raw process, if replace the incomplete row(some
   * columns of the row),the new stategy is execute the pre execution plan first, if the pre
   * execution plan can't cons complete rows in UPS,just return and execute the full row
   * execution plan, which like insert stmt,the plan will get existing data from  CS(CS may
   * get data from ups),then merge the inc data in UPS,construct the complete rows,final, do
   * replace with new values and unchanged values with complete row.
   */
  //add by maosy [MultiUps 1.0] [hot update and secondary index] 20170415 b
  UNUSED(is_column_hint_index);
  // add by maosy e
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  int32_t *index = NULL;
  ObUpsModify *ups_modify = NULL;
  ObRowDesc cur_row_desc;
  ObRowDescExt cur_row_desc_ext;
  ObSEArray<int64_t, 64> cur_row_desc_map;
  ObPhysicalPlan *full_execution_plan = NULL;
  ObUpsExecutor *ups_executor = NULL;

  YYSYS_LOG(DEBUG, "gen physical replace full row execution plan");
  if (NULL == (ups_executor = dynamic_cast<ObUpsExecutor *> (physical_plan->get_phy_op_by_id_from_operator_store(physical_plan->get_ups_executor_op_id()))))
  {
    ret = OB_NOT_INIT;
    YYSYS_LOG(ERROR, "ups executor is not init,ret=%d", ret);
  }
  else if (OB_SUCCESS != (ret = wrap_new_physical_plan(full_execution_plan, err_stat)))
  {
    TRANS_LOG("wrap full execution physical plan failed,ret=%d",ret);
  }

  /* generate root operator */
  else if (NULL == CREATE_PHY_OPERRATOR(ups_modify, ObUpsModify, full_execution_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else if (OB_SUCCESS != (ret = full_execution_plan->add_phy_query(
                            ups_modify,
                            index,/*NULL*/
                            physical_plan != full_execution_plan)))
  {
    TRANS_LOG("Add ups_modify operator failed");
  }
  else if (OB_SUCCESS != (ret = cons_full_row_desc(table_id,
                                                   raw_row_desc,
                                                   raw_row_desc_ext,
                                                   raw_row_desc_map,
                                                   cur_row_desc,
                                                   cur_row_desc_ext,
                                                   cur_row_desc_map,
                                                   err_stat)))
  {
    TRANS_LOG("cos full row desc failed, err=%d", ret);
  }
  else
  {
    ups_executor->set_full_row_execution_plan(full_execution_plan);
    full_execution_plan->set_table_id(table_id);
    full_execution_plan->set_stmt_type(ObBasicStmt::T_REPLACE);
  }

  ObReplaceCompleteRowFuse *complete_row_fuse = NULL;
  if (ret == OB_SUCCESS)
  {
    if (OB_LIKELY(insert_stmt->get_insert_query_id() == OB_INVALID_ID))
    {
      ObExprValues *value_op = NULL;
      if (NULL == CREATE_PHY_OPERRATOR(value_op, ObExprValues, full_execution_plan, err_stat))
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        TRANS_LOG("Failed to create phy operator,ret=%d",ret);
      }
      else if (OB_SUCCESS != (ret = value_op->set_row_desc(raw_row_desc, raw_row_desc_ext)))
      {
        TRANS_LOG("Set descriptor of value operator failed");
      }
      else if (OB_SUCCESS != (ret = gen_phy_values(logical_plan, full_execution_plan, err_stat, insert_stmt,
                                                   raw_row_desc, raw_row_desc_ext, &raw_row_desc_map, *value_op)))
      {
        TRANS_LOG("Failed to gen expr values, err=%d", ret);
      }
      else if (OB_SUCCESS != (ret = add_unchanged_column_to_expr_values(*value_op, cur_row_desc,
                                                                        raw_row_desc.get_column_num(),
                                                                        err_stat)))
      {
        TRANS_LOG("add unchanged column for expr values failed,ret=%d",ret);
      }
      else if (OB_SUCCESS != (ret = value_op->set_row_desc(cur_row_desc, cur_row_desc_ext)))
      {
        TRANS_LOG("set new row desc to value op falied, ret=%d",ret);
      }
      else if (OB_SUCCESS != (ret = full_execution_plan->add_phy_query(value_op)))
      {
        TRANS_LOG("add to phy query failed,ret=%d",ret);
      }
      else
      {
        full_execution_plan->set_expr_values_op_id(value_op->get_id());
      }


      YYSYS_LOG(DEBUG, "cons complete row ops");
      ObTableRpcScan *table_scan = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        ObRpcScanHint hint;
        hint.read_method_ = ObSqlReadStrategy::USE_GET;
        hint.is_get_skip_empty_row_ = false;
        hint.read_consistency_ = FROZEN;
        if (NULL == CREATE_PHY_OPERRATOR(table_scan, ObTableRpcScan, full_execution_plan, err_stat))
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
          TRANS_LOG("Failed to create phy operator,ret=%d",ret);
        }
        else if (OB_SUCCESS != (ret = table_scan->set_table(table_id, table_id)))
        {
          TRANS_LOG("failed to set table id, err=%d", ret);
        }
        else if (OB_SUCCESS != (ret = table_scan->init(sql_context_, &hint)))
        {
          TRANS_LOG("failed to init table scan, err=%d", ret);
        }
        else if (OB_SUCCESS != (ret = gen_phy_static_data_scan(logical_plan, full_execution_plan, err_stat,
                                                               insert_stmt, raw_row_desc, raw_row_desc_map,
                                                               table_id, *rowkey_info, *table_scan)))
        {
          TRANS_LOG("gen phy static data scan failed,err=%d", ret);
        }
        else if (OB_SUCCESS != (ret = add_out_put_column_for_table_rpc_scan(*table_scan,
                                                                            cur_row_desc,
                                                                            raw_row_desc.get_column_num(),
                                                                            OB_DML_REPLACE,
                                                                            err_stat)))
        {
          TRANS_LOG("add out put column for table rpc scan failed, ret=%d",ret);
        }
        else
        {
          table_scan->set_rowkey_cell_count(raw_row_desc.get_rowkey_cell_count());
          table_scan->set_cache_bloom_filter(true);
        }
      }

      ObValues *tmp_table = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        if (NULL == CREATE_PHY_OPERRATOR(tmp_table, ObValues, full_execution_plan, err_stat))
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
          TRANS_LOG("Failed to create phy operator,ret=%d",ret);
        }
        else if (OB_SUCCESS != (ret = tmp_table->set_child(0, *table_scan)))
        {
          TRANS_LOG("failed to set child, err=%d", ret);
        }
        else if (OB_SUCCESS != (ret = full_execution_plan->add_phy_query(tmp_table)))
        {
          TRANS_LOG("add to phy query failed,ret=%d",ret);
        }
        else
        {
          full_execution_plan->set_values_op_id(tmp_table->get_id());
        }
      }

      ObMemSSTableScan *static_data = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        if (NULL == CREATE_PHY_OPERRATOR(static_data, ObMemSSTableScan, full_execution_plan, err_stat))
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
          TRANS_LOG("Failed to create phy operator,ret=%d",ret);
        }
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          static_data->set_tmp_table(tmp_table->get_id());
        }
      }

      ObIncScan *inc_scan = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        if (NULL == CREATE_PHY_OPERRATOR(inc_scan, ObIncScan, full_execution_plan, err_stat))
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
          TRANS_LOG("Failed to create phy operator,ret=%d",ret);
        }
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          inc_scan->set_scan_type(ObIncScan::ST_MGET);
          inc_scan->set_write_lock_flag();
          inc_scan->set_values(value_op->get_id(), false);//need the whole row
        }
      }

      ObMultipleGetMerge *fuse_op = NULL;
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        if (NULL == CREATE_PHY_OPERRATOR(fuse_op, ObMultipleGetMerge, full_execution_plan, err_stat))
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
          TRANS_LOG("Failed to create phy operator,ret=%d",ret);
        }
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          if ((ret = fuse_op->set_child(0, *static_data)) != OB_SUCCESS)
          {
            TRANS_LOG("Set child of fuse_op operator failed, err=%d", ret);
          }
          else if ((ret = fuse_op->set_child(1, *inc_scan)) != OB_SUCCESS)
          {
            TRANS_LOG("Set child of fuse_op operator failed, err=%d", ret);
          }
          else
          {
            fuse_op->set_is_ups_row(false);
            fuse_op->set_is_return_current_fused_row(true);//fuse one row,must return,different from insert stmt
          }
        }
      }


      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        if (NULL == CREATE_PHY_OPERRATOR(complete_row_fuse, ObReplaceCompleteRowFuse, full_execution_plan, err_stat))
        {
          ret = OB_ALLOCATE_MEMORY_FAILED;
          TRANS_LOG("Failed to create phy operator,ret=%d",ret);
        }
        if (OB_LIKELY(OB_SUCCESS == ret))
        {
          if ((ret = complete_row_fuse->set_child(0, *fuse_op)) != OB_SUCCESS)
          {
            TRANS_LOG("Set child of complete_row_fuse operator failed, err=%d", ret);
          }
          else
          {
            complete_row_fuse->set_input_values(value_op->get_id());
            complete_row_fuse->set_ignore_cell_index(insert_stmt->get_value_row(0).count());
          }
        }
      }
    }
    else
    {
      // replace ... select
      TRANS_LOG("REPLACE INTO ... SELECT is not supported yet");
      ret = OB_NOT_SUPPORTED;
    }
  }

  if (OB_SUCCESS == ret)
  {
    ObWhenFilter *when_filter_op = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      if (insert_stmt->get_when_expr_size() > 0)
      {
        if ((ret = gen_phy_when(logical_plan,
                                full_execution_plan,
                                err_stat,
                                query_id,
                                *complete_row_fuse,
                                when_filter_op
                                )) != OB_SUCCESS)
        {
        }
        else if ((ret = ups_modify->set_child(0, *when_filter_op)) != OB_SUCCESS)
        {
          TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
        }
      }
      else if ((ret = ups_modify->set_child(0, *complete_row_fuse)) != OB_SUCCESS)
        //mod 20160118:e
      {
        TRANS_LOG("Set child of ups_modify operator failed, err=%d", ret);
      }
    }
  }
  return ret;
}


int ObTransformer::add_set_clause_for_update_to_project(
    ObLogicalPlan *& logical_plan,
    ObPhysicalPlan *& inner_plan,
    ObProject *& project_op,
    const ObRowDesc& row_desc,
    const ObRowkeyInfo *rowkey_info,
    ObUpdateStmt * update_stmt,
    uint64_t table_id,
    ErrStat& err_stat)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;

  ObSqlExpression expr;
  // fill rowkey columns into the Project op
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    uint64_t tid = OB_INVALID_ID;
    uint64_t cid = OB_INVALID_ID;
    for (int64_t i = 0; i < row_desc.get_rowkey_cell_count(); ++i)
    {
      if (OB_SUCCESS != (ret = row_desc.get_tid_cid(i, tid, cid)))
      {
        TRANS_LOG("Failed to get tid cid");
        break;
      }
      else
      {
        ObBinaryRefRawExpr col_raw_ref(tid, cid, T_REF_COLUMN);
        expr.reset();
        expr.set_tid_cid(tid, cid);
        ObSqlRawExpr col_ref(0, tid, cid, &col_raw_ref);
        if (OB_SUCCESS != (ret = col_ref.fill_sql_expression(expr, this, logical_plan, inner_plan)))
        {
          TRANS_LOG("Failed to fill expression, err=%d", ret);
          break;
        }
        else if (OB_SUCCESS != (ret = project_op->add_output_column(expr)))
        {
          TRANS_LOG("Failed to add output column");
          break;
        }
      }
    }
  }

  /* check and fill set column=expr pairs */
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    ObSqlRawExpr *raw_expr = NULL;
    uint64_t column_id = OB_INVALID_ID;
    uint64_t expr_id = OB_INVALID_ID;
    const ObColumnSchemaV2* column_schema = NULL;
    //add peiouya [NotNULL_check] [JHOBv0.1] 20131222:b
    int64_t para_count = 0;
    //add 20131222:e
    if (ObBasicStmt::T_PREPARE == logical_plan->get_main_stmt()->get_stmt_type())
    {
      expr.set_is_update(true);
    }
    for (int64_t column_idx = 0; column_idx < update_stmt->get_update_column_count(); column_idx++)
    {
      expr.reset();
      // valid check
      // 1. rowkey can't be updated
      // 2. joined column can't be updated
      if (OB_SUCCESS != (ret = update_stmt->get_update_column_id(column_idx, column_id)))
      {
        TRANS_LOG("fail to get update column id for table %lu column_idx=%lu", table_id, column_idx);
        break;
      }
      else if (NULL == (column_schema = sql_context_->schema_manager_->get_column_schema(table_id, column_id)))
      {
        ret = OB_ERR_COLUMN_NOT_FOUND;
        TRANS_LOG("Get column item failed");
        break;
      }
      else if (true == column_schema->is_join_column())
      {
        ret = OB_ERR_UPDATE_JOIN_COLUMN;
        TRANS_LOG("join column '%s' can not be updated", column_schema->get_name());
        break;
      }
      else if (rowkey_info->is_rowkey_column(column_id))
      {
        ret = OB_ERR_UPDATE_ROWKEY_COLUMN;
        TRANS_LOG("rowkey column '%s' can not be updated", column_schema->get_name());
        break;
      }
      else if (column_schema->get_type() == ObCreateTimeType || column_schema->get_type() == ObModifyTimeType)
      {
        ret = OB_ERR_CREAT_MODIFY_TIME_COLUMN;
        TRANS_LOG("Column '%s' of type ObCreateTimeType/ObModifyTimeType can not be updated", column_schema->get_name());
        break;
      }
      // get expression
      else if (OB_SUCCESS != (ret = update_stmt->get_update_expr_id(column_idx, expr_id)))
      {
        YYSYS_LOG(WARN, "fail to get update expr for table %lu column %lu. column_idx=%ld", table_id, column_id, column_idx);
        break;
      }
      else if (NULL == (raw_expr = logical_plan->get_expr(expr_id)))
      {
        YYSYS_LOG(WARN, "fail to get expr from logical plan for table %lu column %lu. column_idx=%ld", table_id, column_id, column_idx);
        ret = OB_ERR_UNEXPECTED;
        break;
      }
      //add peiouya [NotNULL_check] [JHOBv0.1] 20131222:b
      else if (!column_schema->is_nullable() && (ObNullType == raw_expr->get_expr()->get_result_type()))
      {
        TRANS_LOG("column: %s can not be set NULL", column_schema->get_name());
        ret = OB_ERR_UPDATE_NULL_COLUMN;
        break;
      }
      //add 20131222:e
      else if (OB_SUCCESS != (ret = raw_expr->fill_sql_expression(expr, this, logical_plan, inner_plan)))
      {
        YYSYS_LOG(WARN, "fail to fill sql expression. ret=%d", ret);
        break;
      }
      else
      {
        expr.set_tid_cid(table_id, column_id);
        // add <column_id, expression> to project operator
        if (OB_SUCCESS != (ret = project_op->add_output_column(expr)))
        {
          TRANS_LOG("fail to add update expr to update operator");
          break;
        }
        //add peiouya [NotNULL_check] [JHOBv0.1] 20131222:b
        else if((OB_SUCCESS == ret) && (T_QUESTIONMARK == raw_expr->get_expr()->get_expr_type()))
        {
          if (para_count >= result_->get_params().count())
          {
            para_count -= para_count;
          }
          bool is_null = column_schema->is_nullable();
          if (OB_SUCCESS != (ret = result_->set_params_constraint(para_count, is_null)))
          {
            TRANS_LOG("Fail to save the constraint of  column %s!", column_schema->get_name());
            break;
          }

          para_count++;
        }
        //add 20131222:e
      }
      //      if(OB_SUCCESS == ret)
      //      {
      //        questionmark_num_in_update_assign_list_ += expr.get_question_num();
      //        YYSYS_LOG(DEBUG,"questionmark_num_in_update_assign_list_=%ld",questionmark_num_in_update_assign_list_);
      //        expr.reset_question_num();
      //      }
    } // end for
    if (ObBasicStmt::T_PREPARE == logical_plan->get_main_stmt()->get_stmt_type())
    {
      expr.set_is_update(false);
    }
  }

  return ret;
}

int ObTransformer::fill_unchanged_column_info_for_update(
    ObPhysicalPlan *physical_plan,
    ObProject * project_op,
    const ObRowDesc& cur_row_desc,
    const ObRowDescExt& cur_row_desc_ext,
    const int64_t& raw_row_column_num,
    ErrStat& err_stat)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObTableRpcScan * table_rpc_scan = NULL;
  ObExprValues * expr_values = NULL;

  if (NULL == project_op)
  {
    ret = OB_NOT_INIT;
    TRANS_LOG("project op is not set,ret=%d",ret);
  }
  else if (NULL == (table_rpc_scan = dynamic_cast<ObTableRpcScan *>(physical_plan->get_phy_op_by_id_from_operator_store(physical_plan->get_table_rpc_scan_op_id()))))
  {
    ret = OB_NOT_INIT;
    TRANS_LOG( "tableRpcScan op is not set,ret=%d",ret);
  }
  else if (NULL == (expr_values = dynamic_cast<ObExprValues *>(physical_plan->get_phy_op_by_id_from_operator_store(physical_plan->get_expr_values_op_id()))))
  {
    ret = OB_NOT_INIT;
    TRANS_LOG( "ObExprValues op is not set,ret=%d",ret);
  }
  //add unchanged columns to ObExprValues
  else if (OB_SUCCESS != (ret = add_unchanged_column_to_expr_values(*expr_values, cur_row_desc, raw_row_column_num, err_stat)))
  {
    TRANS_LOG("add unchanged column for exprValues failed,ret=%d",ret);
  }
  //add unchanged coulumns to ObTbaleRpcScan
  else if(OB_SUCCESS != (ret = add_out_put_column_for_table_rpc_scan(*table_rpc_scan, cur_row_desc, raw_row_column_num, OB_DML_UPDATE, err_stat)))
  {
    TRANS_LOG("add remain column to ObTableRpcScan failed,ret=%d",ret);
  }
  else
  {
    expr_values->set_row_desc(cur_row_desc, cur_row_desc_ext);//do not forget
    //add unchanged update columns to project op
    ObSqlExpression column_ref;
    uint64_t table_id = OB_INVALID_ID;
    uint64_t column_id = OB_INVALID_ID;
    int64_t column_num = cur_row_desc.get_column_num();
    for (int64_t i=raw_row_column_num; OB_SUCCESS == ret && i<column_num; i++)
    {
      if (OB_SUCCESS != (ret = cur_row_desc.get_tid_cid(i, table_id, column_id)))
      {
        TRANS_LOG("get tid cid failed,ret=%d",ret);
        break;
      }
      else
      {
        column_ref.reset();
        column_ref.set_tid_cid(table_id, column_id);
        if (OB_SUCCESS != (ret = ObSqlExpressionUtil::make_column_expr(table_id, column_id, column_ref)))
        {
          TRANS_LOG("fail to make column expr:ret=%d", ret);
          break;
        }
        else if (OB_SUCCESS != (ret = project_op->add_output_column(column_ref)))
        {
          TRANS_LOG("add remain out put column for project op failed,ret=%d",ret);
          break;
        }
      }
    }//end for
  }
  return ret;
}


int ObTransformer::add_unchanged_column_to_expr_values(ObExprValues& expr_values_op,
                                                       const ObRowDesc& new_row_desc,
                                                       const int64_t& raw_column_num,
                                                       ErrStat& err_stat)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  ObExpressionArray &values = expr_values_op.get_values();
  ObExpressionArray copy_values = values;//copy
  expr_values_op.clear_values();

  int64_t new_column_num = new_row_desc.get_column_num();
  int64_t num = copy_values.count();
  OB_ASSERT(new_column_num >= raw_column_num);
  YYSYS_LOG(DEBUG,"new column num is[%ld],raw column num is[%ld],raw row num[%ld]",new_column_num,raw_column_num,copy_values.count()/raw_column_num);

  uint64_t table_id = OB_INVALID_ID;
  uint64_t column_id = OB_INVALID_ID;
  for (int64_t i=0; OB_SUCCESS == ret && i<num; i+=raw_column_num)//for each row
  {
    //add the raw values first
    int64_t j = 0;
    for (; OB_SUCCESS == ret && j<raw_column_num; j++)
    {
      if (OB_SUCCESS != (ret = expr_values_op.add_value(copy_values.at(i+j))))
      {
        TRANS_LOG("add new value to exprvalues op failed, ret=%d",ret);
        break;
      }
    }
    //add one raw row succeed,add the remain columns for current row
    if (j == raw_column_num)
    {
      for (int64_t k=raw_column_num; OB_SUCCESS == ret && k<new_column_num; k++)
      {
        if (OB_SUCCESS != (ret = new_row_desc.get_tid_cid(k, table_id, column_id)))
        {
          TRANS_LOG("get tid cid failed,ret=%d",ret);
          break;
        }
        else
        {
          ExprItem item;
          item.type_ = T_NULL;
          ObSqlExpression null_val_expr;
          null_val_expr.set_tid_cid(table_id, column_id);
          if (OB_SUCCESS != (ret = null_val_expr.add_expr_item(item)))
          {
            TRANS_LOG("add expr item failed,ret=%d",ret);
            break;
          }
          else if (OB_SUCCESS != (ret = null_val_expr.add_expr_item_end()))
          {
            TRANS_LOG("add expr item end failed,ret=%d",ret);
            break;
          }
          else if (OB_SUCCESS != (ret = expr_values_op.add_value(null_val_expr)))
          {
            TRANS_LOG("Failed to add cell into expr values,ret=%d", ret);
            break;
          }
        }
      }//end for
    }//end if
  }//end for
  if (OB_SUCCESS == ret)
  {
    if (expr_values_op.get_values().count() /new_row_desc.get_column_num() !=
        copy_values.count() / raw_column_num)
    {
      ret = OB_ERROR;
      TRANS_LOG("the new row num[%ld] is not equal raw row num[%ld],ret=%d",expr_values_op.get_values().count()/new_row_desc.get_column_num(),copy_values.count() / raw_column_num, ret);
    }
  }
  return ret;
}

int ObTransformer::add_out_put_column_for_table_rpc_scan(ObTableRpcScan& table_rpc_scan,
                                                         const ObRowDesc& cur_row_desc,
                                                         const int64_t& raw_column_num,
                                                         ObDmlType dml_type,
                                                         ErrStat& err_stat)
{
  int& ret = err_stat.err_code_ = OB_SUCCESS;
  int64_t rowkey_cell_count = cur_row_desc.get_rowkey_cell_count();
  int64_t column_num = cur_row_desc.get_column_num();
  OB_ASSERT(raw_column_num > 0);
  OB_ASSERT(rowkey_cell_count > 0);
  OB_ASSERT(column_num > 0);
  int64_t start_column_pos = OB_INVALID_ID;
  switch (dml_type)
  {
    case OB_DML_UPDATE:
      start_column_pos = raw_column_num;
      break;
    case OB_DML_REPLACE:
      start_column_pos = rowkey_cell_count;
      break;
    default:
      ret = OB_ERR_UNEXPECTED;
      TRANS_LOG("unexpect dml type:[%d]",dml_type);
      break;
  }
  if (OB_SUCCESS == ret)
  {
    ObSqlExpression column_ref;
    ExprItem expr_item;
    for (int64_t i = start_column_pos; OB_SUCCESS == ret && i<column_num; i++)
    {
      expr_item.type_ = T_REF_COLUMN;
      if (OB_UNLIKELY(OB_SUCCESS != (ret = cur_row_desc.get_tid_cid(i, expr_item.value_.cell_.tid, expr_item.value_.cell_.cid))))
      {
        TRANS_LOG("get tid cid failed,ret=%d",ret);
        break;
      }
      column_ref.reset();
      column_ref.set_tid_cid(expr_item.value_.cell_.tid, expr_item.value_.cell_.cid);
      if (OB_SUCCESS != (ret = column_ref.add_expr_item(expr_item)))
      {
        TRANS_LOG("failed to add expr item, ret=%d", ret);
        break;
      }
      else if (OB_SUCCESS != (ret = column_ref.add_expr_item_end()))
      {
        TRANS_LOG("failed to add expr end item, ret=%d", ret);
        break;
      }
      else if (OB_SUCCESS != (ret = table_rpc_scan.add_output_column(column_ref)))
      {
        TRANS_LOG("failed to add output column, ret=%d", ret);
        break;
      }
    }
  }
  return ret;
}

//add 20160408:e

int ObTransformer::is_hit_update_rowkey(const uint64_t table_id, const ObRowkeyInfo *&rowkey_info, ObUpdateStmt *update_stmt, bool &is_update_rowkey)
{
  OB_ASSERT(sql_context_);
  OB_ASSERT(sql_context_->schema_manager_);
  int ret = OB_SUCCESS;
  hash::ObHashSet<int64_t> rowkey_set;
  rowkey_set.create(OB_MAX_ROWKEY_COLUMN_NUMBER + 1);
  const ObTableSchema *table_schema = NULL;
  uint64_t column_id = OB_INVALID_ID;
  if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_id)))
  {
    ret = OB_ERR_ILLEGAL_ID;
    YYSYS_LOG(WARN, "fail to get table schema for table[%ld]", table_id);
  }
  else
  {
    rowkey_info = &table_schema->get_rowkey_info();
  }
  for (int64_t column_idx = 0; OB_SUCCESS == ret && column_idx < update_stmt->get_update_column_count(); column_idx++)
  {
    if (OB_SUCCESS != (ret = update_stmt->get_update_column_id(column_idx, column_id)))
    {
      YYSYS_LOG(WARN, "fail to get update column id for table %lu column_idx=%lu",table_id, column_idx);
      break;
    }
    else if (rowkey_info->is_rowkey_column(column_id))
    {
      if (common::hash::HASH_EXIST == rowkey_set.exist(column_id))
      {
        ret = OB_DUPLICATE_COLUMN;
        YYSYS_LOG(WARN, "insert encounters duplicated key");
      }
      else if (common::hash::HASH_INSERT_SUCC != rowkey_set.set(column_id))
      {
        ret = OB_ERR_UNEXPECTED;
        YYSYS_LOG(WARN, "fail to insert column_id to rowkey_set, column_id=%ld", column_id);
      }
      else
      {
        is_update_rowkey = true;
        ret = OB_SUCCESS;
      }
    }
  }
  rowkey_set.destroy();
  return ret;
}

int ObTransformer::set_update_rowkey(
    ObPhysicalPlan *physical_plan,
    const uint64_t query_id,
    ObUpdateRowkey *&op_update_rowkey,
    int32_t *index,
    ErrStat &err_stat)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  OB_ASSERT(physical_plan);
  if (query_id == OB_INVALID_ID || !physical_plan->in_ups_executor())
  {
    if (NULL == CREATE_PHY_OPERRATOR(op_update_rowkey, ObUpdateRowkey, physical_plan, err_stat))
    {
      ret = OB_ALLOCATE_MEMORY_FAILED;
    }
    else if (OB_SUCCESS != (ret = physical_plan->add_phy_query(
                              op_update_rowkey,
                              index,
                              query_id == OB_INVALID_ID)))
    {
      YYSYS_LOG(WARN, "faild to add query,err =%d",ret);
    }
    else
    {
      op_update_rowkey->set_sql_context(*sql_context_);
    }
  }
  return ret;
}

int ObTransformer::wrap_update_rowkey_ups_executor(
    ObPhysicalPlan *physical_plan,
    const uint64_t query_id,
    ObPhysicalPlan *&new_plan,
    ObUpdateRowkey *&op_update_rowkey,
    UpsExecutorType &ups_executor_type,
    ErrStat &err_stat)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  OB_ASSERT(physical_plan);
  if (query_id == OB_INVALID_ID || !physical_plan->in_ups_executor())
  {
    ObUpsExecutor *ups_executor = NULL;
    new_plan = (ObPhysicalPlan *) trans_malloc(sizeof(ObPhysicalPlan));
    if (NULL == new_plan)
    {
      TRANS_LOG("no memory");
      ret = OB_ALLOCATE_MEMORY_FAILED;
    }
    else
    {
      new_plan = new(new_plan) ObPhysicalPlan();
      if (NULL == CREATE_PHY_OPERRATOR(ups_executor, ObUpsExecutor, physical_plan, err_stat))
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
      }
      else if (NULL == sql_context_->merge_service_)
      {
        ret = OB_NOT_INIT;
        YYSYS_LOG(WARN, "merge_service_ is null");
      }
      else
      {
        switch (ups_executor_type)
        {
          case common::SELECT_OLD_VALUES:
          {
            op_update_rowkey->set_select_plan(ups_executor);
            new_plan->set_in_ups_executor(true);
            ups_executor->set_rpc_stub(sql_context_->merger_rpc_proxy_);
            ups_executor->set_inner_plan(new_plan);
            ups_executor->set_sql_context(sql_context_);
            physical_plan->set_ups_executor_op_id(ups_executor->get_id());
            break;
          }
          case common::DELETE_OLD_ROWS:
          {
            op_update_rowkey->set_delete_plan(ups_executor);
            new_plan->set_in_ups_executor(true);
            ups_executor->set_rpc_stub(sql_context_->merger_rpc_proxy_);
            ups_executor->set_inner_plan(new_plan);
            ups_executor->set_sql_context(sql_context_);
            physical_plan->set_ups_executor_op_id(ups_executor->get_id());
            break;
          }
          case common::INSERT_NEW_ROWS:
          {
            op_update_rowkey->set_insert_plan(ups_executor);
            new_plan->set_in_ups_executor(true);
            ups_executor->set_rpc_stub(sql_context_->merger_rpc_proxy_);
            ups_executor->set_inner_plan(new_plan);
            ups_executor->set_sql_context(sql_context_);
            physical_plan->set_ups_executor_op_id(ups_executor->get_id());
            break;
          }
          default:
            ret = OB_NOT_SUPPORTED;
            YYSYS_LOG(WARN, "unknown update rowkey ups executor type,ups_executor_type=%d",ups_executor_type);
            break;
        }
      }
      if (OB_SUCCESS != ret)
      {
        new_plan->~ObPhysicalPlan();
      }
    }
  }
  else
  {
    new_plan = physical_plan;
  }
  return ret;
}

int ObTransformer::cons_row_desc_for_select_all(
    const uint64_t table_id,
    const ObStmt *stmt,
    ObRowDescExt &row_desc_ext,
    ObRowDesc &row_desc,
    const ObRowkeyInfo *&rowkey_info,
    ErrStat &err_stat
    )
{
  OB_ASSERT(sql_context_);
  OB_ASSERT(sql_context_->schema_manager_);
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  const ObTableSchema *table_schema = NULL;
  if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_id)))
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("fail to get table schema for table[%ld]",table_id);
  }
  else
  {
    rowkey_info = &table_schema->get_rowkey_info();
    int64_t rowkey_col_num = rowkey_info->get_size();
    row_desc.set_rowkey_cell_count(rowkey_col_num);
    int32_t column_num = stmt->get_column_size();
    uint64_t max_column_id = table_schema->get_max_column_id();
    const ColumnItem *column_item = NULL;
    ObObj data_type;
    const ObColumnSchemaV2 *column_schema_for_rowkey = NULL;
    for (int64_t i = 0; OB_SUCCESS == ret && i < rowkey_col_num; ++i)
    {
      const ObRowkeyColumn *rowkey_column = rowkey_info->get_column(i);
      OB_ASSERT(rowkey_column);
      for (int32_t j = 0; ret == OB_SUCCESS && j < column_num; ++j)
      {
        column_item = stmt->get_column_item(j);
        OB_ASSERT(column_item);
        OB_ASSERT(table_id == column_item->table_id_);
        if (rowkey_column->column_id_ == column_item->column_id_)
        {
          if (OB_SUCCESS != (ret = row_desc.add_column_desc(column_item->table_id_,
                                                            column_item->column_id_)))
          {
            TRANS_LOG("failed to add row desc, err=%d",ret);
          }
          else
          {
            if (NULL == (column_schema_for_rowkey = sql_context_->schema_manager_->get_column_schema(
                           column_item->table_id_, column_item->column_id_)))
            {
              ret = OB_ERR_COLUMN_NOT_FOUND;
              TRANS_LOG("Get column item failed");
              break;
            }
            data_type.set_precision(column_schema_for_rowkey->get_precision());
            data_type.set_scale(column_schema_for_rowkey->get_scale());
            data_type.set_type(rowkey_column->type_);
            if (OB_SUCCESS != (ret = row_desc_ext.add_column_desc(column_item->table_id_,
                                                                  column_item->column_id_, data_type)))
            {
              TRANS_LOG("failed to add row desc, err=%d",ret);
            }
          }
          break;
        }
      }
    }
    const ObColumnSchemaV2 *column_schema = NULL;
    for (uint64_t cid = OB_APP_MIN_COLUMN_ID; ret == OB_SUCCESS && cid <= max_column_id; ++cid)
    {
      if (!rowkey_info->is_rowkey_column(cid))
      {
        if (NULL == (column_schema = sql_context_->schema_manager_->get_column_schema(
                       table_id, cid)))
        {
          TRANS_LOG("Get column item failed,column_id=[%ld]",cid);
        }
        else if (OB_SUCCESS != (ret = row_desc.add_column_desc(table_id, cid)))
        {
          TRANS_LOG("failed to add row desc, err=%d",ret);
        }
        else
        {
          data_type.set_type(column_schema->get_type());
          data_type.set_precision(column_schema->get_precision());
          data_type.set_scale(column_schema->get_scale());
          if (OB_SUCCESS != (ret = row_desc_ext.add_column_desc(table_id, cid, data_type)))
          {
            TRANS_LOG("failed to add row desc, err=%d",ret);
          }
        }
      }
    }
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      YYSYS_LOG(DEBUG, "row_desc=%s", to_cstring(row_desc));
    }
  }
  return ret;
}

int ObTransformer::gen_phy_table_for_update_for_select(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *&physical_plan,
    ErrStat &err_stat,
    ObStmt *stmt,
    uint64_t table_id,
    const ObRowkeyInfo &rowkey_info,
    const ObRowDesc &row_desc,
    const ObRowDescExt &row_desc_ext,
    ObPhyOperator *&table_op,
    ObPhyOperator *sequence_op)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  UNUSED(sequence_op);
  TableItem *table_item = NULL;
  ObTableRpcScan *table_rpc_scan_op = NULL;
  ObFilter *filter_op = NULL;
  ObIncScan *inc_scan_op = NULL;
  ObMultipleGetMerge *fuse_op = NULL;
  ObMemSSTableScan *static_data = NULL;
  ObValues *tmp_table = NULL;
  ObRowDesc rowkey_col_map;
  ObExprValues *get_param_values = NULL;
  const ObTableSchema *table_schema = NULL;
  ObObj rowkey_objs[OB_MAX_ROWKEY_COLUMN_NUMBER];
  ObPostfixExpression::ObPostExprNodeType type_objs[OB_MAX_ROWKEY_COLUMN_NUMBER];
  ModuleArena rowkey_alloc(OB_MAX_VARCHAR_LENGTH, ModulePageAllocator(ObModIds::OB_SQL_TRANSFORMER));
  ObCellInfo cell_info;
  cell_info.table_id_ = table_id;
  cell_info.row_key_.assign(rowkey_objs, rowkey_info.get_size());

  bool has_other_cond = false;
  ObRpcScanHint hint;
  hint.read_method_ = ObSqlReadStrategy::USE_GET;
  hint.read_consistency_ = FROZEN;
  hint.is_get_skip_empty_row_ = false;

  if (table_id == OB_INVALID_ID
      || (table_item = stmt->get_table_item_by_id(table_id)) == NULL
      || TableItem::BASE_TABLE != table_item->type_)
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("Wrong table id, tid=%lu",table_id);
  }
  else if (NULL == CREATE_PHY_OPERRATOR(table_rpc_scan_op, ObTableRpcScan, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else if ((ret = table_rpc_scan_op->set_table(table_item->table_id_, table_item->ref_id_)) != OB_SUCCESS)
  {
    TRANS_LOG("ObTableRpcScan set table failed");
  }
  else if (OB_SUCCESS != (ret = table_rpc_scan_op->init(sql_context_, &hint)))
  {
    TRANS_LOG("ObTableRpcScan init failed");
  }
  else if (NULL == CREATE_PHY_OPERRATOR(tmp_table, ObValues, physical_plan, err_stat))
  {
  }
  else if (OB_SUCCESS != (ret = tmp_table->set_child(0, *table_rpc_scan_op)))
  {
    YYSYS_LOG(WARN, "failed to set child op, err=%d",ret);
  }
  else if(OB_SUCCESS != (ret = physical_plan->add_phy_query(tmp_table)))
  {
    YYSYS_LOG(WARN, "failed to add sub query, err=%d",ret);
  }
  else if (NULL == CREATE_PHY_OPERRATOR(filter_op, ObFilter, physical_plan, err_stat))
  {
  }
  else if (NULL == CREATE_PHY_OPERRATOR(inc_scan_op, ObIncScan, physical_plan, err_stat))
  {
  }
  else if (NULL == CREATE_PHY_OPERRATOR(fuse_op, ObMultipleGetMerge, physical_plan, err_stat))
  {
  }
  else if (NULL == CREATE_PHY_OPERRATOR(static_data, ObMemSSTableScan, physical_plan, err_stat))
  {
  }
  else if (OB_SUCCESS != (ret = fuse_op->set_child(0, *static_data)))
  {
  }
  else if (OB_SUCCESS != (ret = fuse_op->set_child(1, *inc_scan_op)))
  {
  }
  else if (NULL == CREATE_PHY_OPERRATOR(get_param_values, ObExprValues, physical_plan, err_stat))
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
  }
  else if (OB_SUCCESS != (ret = physical_plan->add_phy_query(get_param_values)))
  {
    YYSYS_LOG(WARN, "failed to add sub query, err=%d",ret);
  }
  else if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_id)))
  {
    ret = OB_ERR_ILLEGAL_ID;
    TRANS_LOG("Fail to get table schema for table[%ld]",table_id);
  }
  else if ((ret = physical_plan->add_base_table_version(
              table_id,
              table_schema->get_schema_version()
              )) != OB_SUCCESS)
  {
    TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d",table_id,ret);
  }
  else
  {
    physical_plan->set_table_id(table_id);
    physical_plan->set_stmt_type(ObBasicStmt::T_UPDATE);
    fuse_op->set_is_ups_row(false);

    inc_scan_op->set_scan_type(ObIncScan::ST_MGET);
    inc_scan_op->set_write_lock_flag();
    inc_scan_op->set_hotspot(stmt->get_query_hint().hotspot_);
    inc_scan_op->set_values(get_param_values->get_id(), false);

    static_data->set_tmp_table(tmp_table->get_id());
    table_rpc_scan_op->set_rowkey_cell_count(row_desc.get_rowkey_cell_count());
    table_rpc_scan_op->set_need_cache_frozen_data(true);

    get_param_values->set_row_desc(row_desc, row_desc_ext);
    physical_plan->set_expr_values_op_id(get_param_values->get_id());
    physical_plan->set_values_op_id(tmp_table->get_id());
    physical_plan->set_table_rpc_scan_op_id(table_rpc_scan_op->get_id());
    int32_t num = stmt->get_condition_size();
    uint64_t cid = OB_INVALID_ID;
    int64_t cond_op = T_INVALID;
    ObObj cond_val;
    ObPostfixExpression::ObPostExprNodeType val_type = ObPostfixExpression::BEGIN_TYPE;
    int64_t rowkey_idx = OB_INVALID_INDEX;
    ObRowkeyColumn rowkey_col;
    uint64_t tid = table_schema->get_table_id();

    for (int32_t i = 0; i < num; i++)
    {
      ObSqlRawExpr *cnd_expr = logical_plan->get_expr(stmt->get_condition_id(i));
      OB_ASSERT(cnd_expr);
      cnd_expr->set_applied(true);
      ObSqlExpression *filter = ObSqlExpression::alloc();
      if (NULL == filter)
      {
        TRANS_LOG("no memory");
        ret = OB_ALLOCATE_MEMORY_FAILED;
        break;
      }
      else if (OB_SUCCESS != (ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan)))
      {
        ObSqlExpression::free(filter);
        TRANS_LOG("Failed to fill expression, err=%d",ret);
        break;
      }
      else if (filter->is_simple_condition(false, cid, cond_op, cond_val, &val_type)
               && (T_OP_EQ == cond_op || T_OP_IS == cond_op)
               && rowkey_info.is_rowkey_column(cid))
      {
        if(T_OP_EQ == cond_op && cond_val.is_null())
        {
          ObSqlExpression *primary_key_null_filter = ObSqlExpression::alloc();
          if(NULL == primary_key_null_filter)
          {
            TRANS_LOG("no memory");
            ret = OB_ALLOCATE_MEMORY_FAILED;
            break;
          }
          *primary_key_null_filter = *filter;
          has_other_cond = true;
          YYSYS_LOG(INFO, "where:primary key = NULL");
          if (OB_SUCCESS != (ret = filter_op->add_filter(primary_key_null_filter)))
          {
            ObSqlExpression::free(primary_key_null_filter);
            TRANS_LOG("Failed to add filter, err=%d", ret);
            break;
          }
        }
        if (OB_SUCCESS != (ret = table_rpc_scan_op->add_filter(filter)))
        {
          ObSqlExpression::free(filter);
          TRANS_LOG("Failed to add filter, err=%d",ret);
          break;
        }
        else if (OB_SUCCESS != (ret = rowkey_col_map.add_column_desc(OB_INVALID_ID, cid)))
        {
          TRANS_LOG("Failed to add column desc, err=%d",ret);
          break;
        }
        else if (OB_SUCCESS != (ret = rowkey_info.get_index(cid, rowkey_idx, rowkey_col)))
        {
          TRANS_LOG("Unexpected branch");
          ret = OB_ERR_UNEXPECTED;
          break;
        }
        else
        {
          ObObjType cond_val_type;
          uint32_t cond_val_precision;
          uint32_t cond_val_scale;
          ObObj static_obj;
          if (OB_SUCCESS != sql_context_->schema_manager_->get_cond_val_info(tid, cid, cond_val_type, cond_val_precision,cond_val_scale))
          {

          }
          else
          {
            tmp_table->add_rowkey_array(tid, cid, cond_val_type, cond_val_precision, cond_val_scale);
            if (ObDecimalType == cond_val_type)
            {
              static_obj.set_precision(cond_val_precision);
              static_obj.set_scale(cond_val_scale);
              static_obj.set_type(cond_val_type);
            }
          }

          if (OB_SUCCESS != (ret = ob_write_obj_for_delete(rowkey_alloc, cond_val, rowkey_objs[rowkey_idx],static_obj)))
          {
            TRANS_LOG("failed to copy cell, err=%d",ret);
          }
          else
          {
            type_objs[rowkey_idx] = val_type;
          }
        }
      }
      else
      {
        //other condition
        has_other_cond = true;
        if (OB_SUCCESS != (ret = filter_op->add_filter(filter)))
        {
          TRANS_LOG("Failed to add filter, err=%d",ret);
          break;
        }
      }
    }//end for
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      int64_t rowkey_col_num = rowkey_info.get_size();
      uint64_t cid = OB_INVALID_ID;
      for (int64_t i = 0; i < rowkey_col_num; ++i)
      {
        if (OB_SUCCESS != (ret = rowkey_info.get_column_id(i, cid)))
        {
          TRANS_LOG("Failed to get column id, err=%d",ret);
          break;
        }
        else if(OB_INVALID_INDEX == rowkey_col_map.get_idx(OB_INVALID_ID, cid))
        {
          TRANS_LOG("Primary key column %lu not specified in the WHERE clause",cid);
          ret = OB_ERR_LACK_OF_ROWKEY_COL;
          break;
        }
      }
    }
  }
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    int64_t num = row_desc.get_column_num();
    uint64_t tid = OB_INVALID_ID;
    uint64_t cid = OB_INVALID_ID;
    for (int32_t i=0; ret == OB_SUCCESS && i < num; i++)
    {
      row_desc.get_tid_cid(i, tid, cid);
      if (tid == table_id)
      {
        ObBinaryRefRawExpr col_expr(tid, cid, T_REF_COLUMN);
        ObSqlRawExpr col_raw_expr(
              common::OB_INVALID_ID,
              tid,
              cid,
              &col_expr);
        ObSqlExpression output_expr;
        if ((ret = col_raw_expr.fill_sql_expression(
               output_expr,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS
            || (ret = table_rpc_scan_op->add_output_column(output_expr)) != OB_SUCCESS)
        {
          TRANS_LOG("Add table output columns faild");
          break;
        }
        ObConstRawExpr col_expr2;
        if (i < rowkey_info.get_size())
        {
          if (OB_SUCCESS != (ret = col_expr2.set_value_and_type(rowkey_objs[i])))
          {
            YYSYS_LOG(WARN, "failed to set value, err=%d",ret);
            break;
          }
          else
          {
            switch (type_objs[i])
            {
              case ObPostfixExpression::PARAM_IDX:
                col_expr2.set_expr_type(T_QUESTIONMARK);
                col_expr2.set_result_type(ObVarcharType);
                break;
              case ObPostfixExpression::SYSTEM_VAR:
                col_expr2.set_expr_type(T_SYSTEM_VARIABLE);
                col_expr2.set_result_type(ObVarcharType);
                break;
              case ObPostfixExpression::TEMP_VAR:
                col_expr2.set_expr_type(T_TEMP_VARIABLE);
                col_expr2.set_result_type(ObVarcharType);
                break;
              default:
                break;
            }
          }
        }
        else
        {
          ObObj null_obj;
          col_expr2.set_value_and_type(null_obj);
        }
        ObSqlRawExpr col_raw_expr2(
              common::OB_INVALID_ID,
              tid,
              cid,
              &col_expr2);
        ObSqlExpression output_expr2;
        if ((ret = col_raw_expr2.fill_sql_expression(
               output_expr2,
               this,
               logical_plan,
               physical_plan)) != OB_SUCCESS)
        {
          TRANS_LOG("Add table output columns failed");
          break;
        }
        else if (OB_SUCCESS != (ret = get_param_values->add_value(output_expr2)))
        {
          TRANS_LOG("Failed to add cell into get param, err=%d",ret);
          break;
        }
        else
        {
          get_param_values->set_del_upd();
        }
      }
    }
  }
  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    ObSqlExpression column_ref;
    column_ref.set_tid_cid(OB_INVALID_ID, OB_ACTION_FLAG_COLUMN_ID);
    if (OB_SUCCESS != (ret = ObSqlExpressionUtil::make_column_expr(OB_INVALID_ID, OB_ACTION_FLAG_COLUMN_ID, column_ref)))
    {
      YYSYS_LOG(WARN, "fail to make column expr:ret[%d]",ret);
    }
    else if (OB_SUCCESS != (ret = table_rpc_scan_op->add_output_column(column_ref)))
    {
      YYSYS_LOG(WARN, "failed to add output column, err=%d",ret);
    }
  }
  if (ret == OB_SUCCESS)
  {
    if (has_other_cond)
    {
      if (OB_SUCCESS != (ret = filter_op->set_child(0, *fuse_op)))
      {
        TRANS_LOG("Failed to set child, err=%d",ret);
      }
      else
      {
        table_op = filter_op;
      }
    }
    else
    {
      table_op = fuse_op;
    }
    tmp_table->set_fix_obvalues();
  }
  return ret;
}

int ObTransformer::gen_phy_update_rowkey_for_select_rows(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ObUpdateRowkey *&op_update_rowkey,
    ErrStat &err_stat,
    const uint64_t &query_id,
    int32_t *index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObUpdateStmt *update_stmt = NULL;
  ObPhyOperator *result_op = NULL;
  ObProject *project_op = NULL;
  uint64_t table_id = OB_INVALID_ID;
  const ObRowkeyInfo *rowkey_info = NULL;
  ObPhysicalPlan *inner_plan = NULL;
  ObRowDesc row_desc;
  ObRowDescExt row_desc_ext;
  UpsExecutorType ups_executor_type = SELECT_OLD_VALUES;
  ObSequenceSelect *sequence_select_op = NULL;

  if ((ret = get_stmt(logical_plan, err_stat, query_id, update_stmt)) != OB_SUCCESS)
  {
  }
  else if ((ret = wrap_update_rowkey_ups_executor(physical_plan, query_id, inner_plan, op_update_rowkey, ups_executor_type, err_stat)) != OB_SUCCESS)
  {
    YYSYS_LOG(WARN, "failed to wrap_update_rowkey_ups_executor, err=%d",ret);
  }
  else
  {
    physical_plan->set_result_set(result_);
    inner_plan->set_result_set(result_);
  }

  if (OB_SUCCESS != ret)
  {    }
  else if (CREATE_PHY_OPERRATOR(project_op, ObProject, inner_plan, err_stat) == NULL)
  {
    ret = OB_ALLOCATE_MEMORY_FAILED;
    TRANS_LOG("Failed to create phy operator");
  }
  else if ((ret = inner_plan->add_phy_query(
              project_op,
              physical_plan == inner_plan ? index : NULL,
              physical_plan != inner_plan)))
  {
    TRANS_LOG("Add top operator failed");
  }
  else
  {
    table_id = update_stmt->get_update_table_id();
    if ((ret = cons_row_desc_for_select_all(table_id,
                                            update_stmt,
                                            row_desc_ext,
                                            row_desc,
                                            rowkey_info,
                                            err_stat)) != OB_SUCCESS)
    {
    }
    else
    {
      if (OB_SUCCESS != (ret = op_update_rowkey->set_row_desc(row_desc)))
      {
      }
      else if (OB_SUCCESS != (ret = op_update_rowkey->set_row_desc_ext(row_desc_ext)))
      {
      }
      op_update_rowkey->set_rowkey_info(rowkey_info);
    }
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      if ((ret = gen_phy_table_for_update_for_select(logical_plan, inner_plan, err_stat,
                                                     update_stmt, table_id, *rowkey_info,
                                                     row_desc, row_desc_ext, result_op, sequence_select_op
                                                     ))!= OB_SUCCESS)
      {
      }
      else
      {
        inner_plan->set_table_id(table_id);
        inner_plan->set_stmt_type(ObBasicStmt::T_SELECT);
      }
    }
  }
  ObSqlExpression expr;
  for (int32_t i = 0; ret == OB_SUCCESS && i < row_desc.get_column_num(); i++)
  {
    uint64_t tid = OB_INVALID_ID;
    uint64_t cid = OB_INVALID_ID;
    expr.reset();
    if (OB_SUCCESS != (ret = row_desc.get_tid_cid(i, tid, cid)))
    {
      TRANS_LOG("Faild to get tid cid, err=%d",ret);
      break;
    }
    else
    {
      ObBinaryRefRawExpr col_raw_ref(tid, cid, T_REF_COLUMN);
      expr.reset();;
      ObSqlRawExpr col_ref(OB_INVALID_ID, tid, cid, &col_raw_ref);
      if (OB_SUCCESS != (ret = col_ref.fill_sql_expression(expr, this, logical_plan, inner_plan)))
      {
        TRANS_LOG("Faild to fill expression, err=%d",ret);
        break;
      }
      else if (OB_SUCCESS != (ret = project_op->add_output_column(expr)))
      {
        TRANS_LOG("Faild to add output column, err=%d",ret);
        break;
      }
    }
  }
  ObSqlRawExpr *raw_expr = NULL;
  uint64_t expr_id = OB_INVALID_ID;
  uint64_t column_id = OB_INVALID_ID;
  for( int64_t column_idx = 0; column_idx < update_stmt->get_update_column_count(); column_idx++)
  {
    expr.reset();
    const ObColumnSchemaV2 *column_schema = NULL;
    if (OB_SUCCESS != (ret = update_stmt->get_update_column_id(column_idx, column_id)))
    {
      TRANS_LOG("Faild to get_update_column_id for table[%ld] column idx[%ld], err=%d",table_id, column_idx, ret);
      break;
    }
    else if (OB_SUCCESS != (ret = update_stmt->get_update_expr_id(column_idx, expr_id)))
    {
      TRANS_LOG("Faild to get_update_expr_id for table[%ld] column [%ld], err=%d",table_id, column_id, ret);
      break;
    }
    else if (NULL == (raw_expr = logical_plan->get_expr(expr_id)))
    {
      TRANS_LOG("Faild to get_expr from logical_plan for table[%ld] column [%ld] column idx[%ld]",table_id, column_id, column_idx);
      ret = OB_ERR_UNEXPECTED;
      break;
    }
    else if (OB_SUCCESS != (ret = raw_expr->fill_sql_expression(expr, this, logical_plan, inner_plan)))
    {
      TRANS_LOG("Faild to fill expression, err=%d",ret);
      break;
    }
    else
    {
      expr.set_tid_cid(table_id, column_id);
      op_update_rowkey->add_sql_expression(expr);
    }
    column_schema = sql_context_->schema_manager_->get_column_schema(table_id, column_id);
    const ObObjType type = column_schema->get_type();
    op_update_rowkey->add_value_type(type);
  }
  if (OB_LIKELY(OB_SUCCESS ==ret))
  {
    ObWhenFilter *when_filter_op = NULL;
    if (update_stmt->get_when_expr_size() > 0)
    {
      if ((ret = gen_phy_when(logical_plan,
                              inner_plan,
                              err_stat,
                              query_id,
                              *result_op,
                              when_filter_op
                              )) != OB_SUCCESS)
      {
      }
      else if ((ret = project_op->set_child(0, *when_filter_op)) != OB_SUCCESS)
      {
        TRANS_LOG("Set child of project_op operator failed, err=%d",ret);
      }
    }
    else if ((ret = project_op->set_child(0, *result_op)) != OB_SUCCESS)
    {
      TRANS_LOG("Set child of project_op operator failed, err=%d",ret);
    }
  }
  if (ret == OB_SUCCESS)
  {
    if ((ret = merge_tables_version(*physical_plan, *inner_plan)) != OB_SUCCESS)
    {
      TRANS_LOG("Failed to add base tables version, err=%d",ret);
    }
  }
  return ret;
}

int ObTransformer::gen_phy_update_rowkey_insert_new_rows(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ObUpdateRowkey *&op_update_rowkey,
    ErrStat &err_stat,
    const uint64_t &query_id,
    int32_t *index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObUpdateStmt *update_stmt = NULL;
  ObUpsModifyWithDmlType *ups_modify = NULL;
  ObRowDesc row_desc;
  ObRowDescExt row_desc_ext;
  ObSEArray<int64_t, 64> row_desc_map;
  const ObRowkeyInfo *rowkey_info = NULL;
  ObPhysicalPlan *inner_plan = NULL;
  UpsExecutorType ups_executor_type = INSERT_NEW_ROWS;
  ObSqlReadStrategy sql_read_strategy;
  bool is_need_modify_index = false;
  int64_t index_num = 0;

//YYSYS_LOG(INFO, "fo into gen_phy_update_rowkey_insert_new_rows!!!");
  if (OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, update_stmt)))
  {
  }
  else if (update_stmt->get_is_update_multi_batch())
  {
    is_multi_batch_ = true;
  }

  if (OB_SUCCESS == ret)
  {
    if (OB_SUCCESS != (ret = wrap_update_rowkey_ups_executor(physical_plan, query_id, inner_plan, op_update_rowkey, ups_executor_type,err_stat)))
    {
      YYSYS_LOG(WARN, "failed to wrap_update_rowkey_ups_executor, err=%d",ret);
    }
    else if (NULL == CREATE_PHY_OPERRATOR(ups_modify, ObUpsModifyWithDmlType, inner_plan, err_stat))
    {
      ret = OB_ALLOCATE_MEMORY_FAILED;
    }
    else if (OB_SUCCESS != (ret = inner_plan->add_phy_query(
                              ups_modify,
                              physical_plan == inner_plan ? index : NULL,
                              physical_plan != inner_plan)))
    {
      TRANS_LOG("Failed to add main phy query, err=%d",ret);
    }
    else if (OB_SUCCESS != (ret = cons_row_desc_for_select_all(update_stmt->get_update_table_id(),
                                                               update_stmt, row_desc_ext, row_desc,
                                                               rowkey_info, err_stat)))
    {
      ret = OB_ERROR;
      TRANS_LOG("Fail to get table schema for table[%ld]",update_stmt->get_update_table_id());
    }
    else
    {
      ups_modify->set_dml_type(OB_DML_INSERT);
      uint64_t tid = update_stmt->get_update_table_id();
      uint64_t cid = OB_INVALID_ID;
      for (int64_t i = 0; i < rowkey_info->get_size(); ++i)
      {
        if (OB_SUCCESS != (ret = rowkey_info->get_column_id(i, cid)))
        {
          YYSYS_LOG(USER_ERROR, "primary key can not be empty");
          ret = OB_ERR_INSERT_NULL_ROWKEY;
          break;
        }
        else if (OB_INVALID_INDEX == row_desc.get_idx(tid,cid))
        {
          YYSYS_LOG(USER_ERROR, "primary key can not be empty");
          ret = OB_ERR_INSERT_NULL_ROWKEY;
          break;
        }
      }
    }
  }
  if (OB_LIKELY(ret == OB_SUCCESS))
  {
    uint64_t main_tid = update_stmt->get_update_table_id();
    if (sql_context_->schema_manager_->is_have_modifiable_index(main_tid))
    {
      is_need_modify_index = true;
    }
  }

  if (OB_LIKELY(OB_SUCCESS == ret))
  {
    //INSERT ... VALUES ...
    uint64_t tid = update_stmt->get_update_table_id();
    const ObTableSchema *table_schema = NULL;
    if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(tid)))
    {
      ret = OB_ERR_ILLEGAL_ID;
      TRANS_LOG("fail to get table schema for table[%ld]",tid);
    }
    else if (row_desc.get_idx(tid, table_schema->get_create_time_column_id()) != OB_INVALID_INDEX)
    {
      ret = OB_ERR_CREAT_MODIFY_TIME_COLUMN;
      ColumnItem *column_item = update_stmt->get_column_item_by_id(tid, table_schema->get_create_time_column_id());
      if (column_item != NULL)
      {
        TRANS_LOG("Column '%.*s' of type ObCreateTimeType can not be inserted",
                  column_item->column_name_.length(), column_item->column_name_.ptr());
      }
      else
      {
        TRANS_LOG("Column '%ld' of type ObCreateTimeType can not be inserted",
                  table_schema->get_create_time_column_id());
      }
    }
    else if (row_desc.get_idx(tid, table_schema->get_modify_time_column_id()) != OB_INVALID_INDEX)
    {
      ret = OB_ERR_CREAT_MODIFY_TIME_COLUMN;
      ColumnItem *column_item = update_stmt->get_column_item_by_id(tid, table_schema->get_modify_time_column_id());
      if (column_item != NULL)
      {
        TRANS_LOG("Column '%.*s' of type ObModifyTimeType can not be inserted",
                  column_item->column_name_.length(), column_item->column_name_.ptr());
      }
      else
      {
        TRANS_LOG("Column '%ld' of type ObModifyTimeType can not be inserted",
                  table_schema->get_modify_time_column_id());
      }
    }
  }
  if (OB_SUCCESS == ret)
  {
    ObTableRpcScan *table_scan = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      ObRpcScanHint hint;
      hint.read_method_ = ObSqlReadStrategy::USE_GET;
      hint.is_get_skip_empty_row_ = false;
      hint.read_consistency_ = FROZEN;
      const ObTableSchema *table_schema = NULL;
      int64_t table_id = update_stmt->get_update_table_id();
      CREATE_PHY_OPERRATOR(table_scan, ObTableRpcScan, inner_plan, err_stat);
      if (OB_UNLIKELY(OB_SUCCESS != ret))
      {
      }
      else if (OB_SUCCESS != (ret = table_scan->set_table(table_id, table_id)))
      {
        TRANS_LOG("failed to set table id, err=%d",ret);
      }
      else if (OB_SUCCESS != (ret = table_scan->init(sql_context_, &hint)))
      {
        TRANS_LOG("failed to init table scan, err=%d",ret);
      }
      else if (NULL == (table_schema = sql_context_->schema_manager_->get_table_schema(table_id)))
      {
        ret = OB_ERR_ILLEGAL_ID;
        TRANS_LOG("Fail to get table schema for table[%ld]",table_id);
      }
      else if ((ret = physical_plan->add_base_table_version(
                  table_id,
                  table_schema->get_schema_version()
                  )) != OB_SUCCESS)
      {
        TRANS_LOG("Add base table version failed, table_id=%ld, ret=%d",table_id, ret);
      }
      else
      {
        table_scan->set_rowkey_cell_count(row_desc.get_rowkey_cell_count());
        table_scan->set_cache_bloom_filter(true);
      }
    }
    ObValues *tmp_table = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      CREATE_PHY_OPERRATOR(tmp_table, ObValues, inner_plan, err_stat);
      if (OB_UNLIKELY(OB_SUCCESS != ret))
      {
      }
      else if (OB_SUCCESS != (ret = tmp_table->set_child(0, *table_scan)))
      {
        YYSYS_LOG(WARN, "failed to set child, err=%d",ret);
      }
      else if (OB_SUCCESS != (ret = inner_plan->add_phy_query(tmp_table)))
      {
        YYSYS_LOG(WARN, "failed to add phy query, err=%d",ret);
      }
      else
      {
        inner_plan->set_values_op_id(tmp_table->get_id());
      }
    }
    ObMemSSTableScan *static_data = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      CREATE_PHY_OPERRATOR(static_data, ObMemSSTableScan, inner_plan, err_stat);
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        static_data->set_tmp_table(tmp_table->get_id());
      }
    }
    ObIncScan *inc_scan = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      CREATE_PHY_OPERRATOR(inc_scan, ObIncScan, inner_plan, err_stat);
      if (OB_LIKELY(OB_SUCCESS == ret))
      {
        inc_scan->set_scan_type(ObIncScan::ST_MGET);
        inc_scan->set_write_lock_flag();
      }
    }
    ObMultipleGetMerge *fuse_op = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      CREATE_PHY_OPERRATOR(fuse_op, ObMultipleGetMerge, inner_plan, err_stat);
      if (OB_UNLIKELY(OB_SUCCESS != ret))
      {
      }
      else if ((ret = fuse_op->set_child(0, *static_data)) != OB_SUCCESS)
      {
        TRANS_LOG("Set child of fuse_op operator failed, err=%d",ret);
      }
      else if ((ret = fuse_op->set_child(1, *inc_scan)) != OB_SUCCESS)
      {
        TRANS_LOG("Set child of fuse_op operator failed, err=%d",ret);
      }
      else
      {
        fuse_op->set_is_ups_row(false);
      }
    }
    ObExprValues *input_values = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      CREATE_PHY_OPERRATOR(input_values, ObExprValues, inner_plan, err_stat);
      if (OB_UNLIKELY(OB_SUCCESS != ret))
      {
      }
      else if (OB_SUCCESS != (ret = inner_plan->add_phy_query(input_values)))
      {
        YYSYS_LOG(WARN, "failed to add phy query, err=%d",ret);
      }
      else if ((ret = input_values->set_row_desc(row_desc, row_desc_ext)) != OB_SUCCESS)
      {
        TRANS_LOG("Set descriptor of value operator failed, err=%d",ret);
      }
      else
      {
        inner_plan->set_table_id(update_stmt->get_update_table_id());
        inner_plan->set_stmt_type(ObBasicStmt::T_INSERT);
        inner_plan->set_expr_values_op_id(input_values->get_id());
        input_values->set_check_rowkey_duplicate(true);
      }
    }
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      if (OB_SUCCESS != (ret = op_update_rowkey->set_op(table_scan, input_values)))
      {
        TRANS_LOG("faild to set operator of ObTableRpcScan and ObExprValues, err=%d",ret);
      }
      else
      {
        sql_read_strategy.set_rowkey_info(*rowkey_info);
        op_update_rowkey->set_sql_read_atratege(sql_read_strategy);
      }
    }
    ObEmptyRowFilter *empty_row_filter = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      CREATE_PHY_OPERRATOR(empty_row_filter, ObEmptyRowFilter, inner_plan, err_stat);
      if (OB_UNLIKELY(OB_SUCCESS != ret))
      {
      }
      else if ((ret = empty_row_filter->set_child(0, *fuse_op)) != OB_SUCCESS)
      {
        TRANS_LOG("Failed to set child");
      }
    }
    ObInsertDBSemFilter *insert_sem = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      CREATE_PHY_OPERRATOR(insert_sem, ObInsertDBSemFilter, inner_plan, err_stat);
      if (OB_UNLIKELY(OB_SUCCESS != ret))
      {
      }
      else if ((ret = insert_sem->set_child(0, *empty_row_filter)) != OB_SUCCESS)
      {
        TRANS_LOG("Failed to set child, err=%d", ret);
      }
      else
      {
        inc_scan->set_values(input_values->get_id(), true);
        insert_sem->set_input_values(input_values->get_id());
      }
    }
    ObIndexTrigger *index_trigger = NULL;
    if (OB_LIKELY(OB_SUCCESS == ret) && is_need_modify_index)
    {
      CREATE_PHY_OPERRATOR(index_trigger, ObIndexTrigger, inner_plan, err_stat);
      if (OB_UNLIKELY(OB_SUCCESS != ret))
      {
      }
      else if ((ret = index_trigger->set_child(0, *insert_sem)) != OB_SUCCESS)
      {
        TRANS_LOG("Failed to set child, err=%d",ret);
      }
      else if (OB_SUCCESS != (ret = sql_context_->schema_manager_->get_all_modifiable_index_num(update_stmt->get_update_table_id(), index_num)))
      {

      }
      else
      {
        index_trigger->set_i64_values(update_stmt->get_update_table_id(), index_num, 0);
      }
    }
    if (OB_LIKELY(OB_SUCCESS == ret))
    {
      if (is_need_modify_index)
      {
        if (OB_SUCCESS != (ret = ups_modify->set_child(0, *index_trigger)))
        {
          TRANS_LOG("Set child of ups_modify operator failed, err=%d",ret);
        }
      }
      else
      {
        if(OB_SUCCESS != (ret = ups_modify->set_child(0, *insert_sem)))
        {
          TRANS_LOG("Set child of ups_modify operator failed, err=%d",ret);
        }
      }
    }
  }
  if (ret == OB_SUCCESS)
  {
    if ((ret = merge_tables_version(*physical_plan, *inner_plan)) != OB_SUCCESS)
    {
      TRANS_LOG("Failed to add base tables version, err=%d",ret);
    }
  }
  return ret;
}

int ObTransformer::gen_phy_update_rowkey_for_select_more_rows(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ObUpdateRowkey *&op_update_rowkey,
    ErrStat &err_stat,
    const uint64_t &query_id,
    int32_t *index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObUpdateStmt *update_stmt = NULL;
  UNUSED(index);
  ObRowDesc row_desc;
  ObRowDescExt row_desc_ext;
  const ObRowkeyInfo *rowkey_info = NULL;
  TableItem *table_item = NULL;
  uint64_t table_id = OB_INVALID_ID;
  if ((ret = get_stmt(logical_plan, err_stat, query_id, update_stmt)) != OB_SUCCESS)
  {
  }
  if (OB_SUCCESS == ret)
  {
    /* Normal Select Statement */
    table_id = update_stmt->get_update_table_id();
    if (table_id == OB_INVALID_ID
        || (table_item = update_stmt->get_table_item_by_id(table_id)) == NULL
        || TableItem::BASE_TABLE != table_item->type_)
    {
      ret = OB_ERR_ILLEGAL_ID;
      TRANS_LOG("Wrong table id, tid=%lu",table_id);
    }
    else if ((ret = cons_row_desc_for_select_all(table_id,
                                                 update_stmt,
                                                 row_desc_ext,
                                                 row_desc,
                                                 rowkey_info,
                                                 err_stat)) != OB_SUCCESS)
    {
    }
    else
    {
      if (OB_SUCCESS != (ret = op_update_rowkey->set_row_desc(row_desc)))
      {
      }
      else if (OB_SUCCESS != (ret = op_update_rowkey->set_row_desc_ext(row_desc_ext)))
      {
      }
      op_update_rowkey->set_rowkey_info(rowkey_info);
    }
    ObRpcScanHint hint;
    hint.read_consistency_ = WEAK;
    hint.read_method_ = ObSqlReadStrategy::USE_SCAN;
    hint.max_parallel_count = 1;
    ObTableRpcScan *table_rpc_scan_op = NULL;
    CREATE_PHY_OPERRATOR(table_rpc_scan_op, ObTableRpcScan, physical_plan, err_stat);
    if (ret == OB_SUCCESS
        && (ret = table_rpc_scan_op->set_table(table_id, table_id)) != OB_SUCCESS)
    {
      TRANS_LOG("ObTableRpcScan set table faild");
    }
    else if ((ret = table_rpc_scan_op->init(sql_context_, &hint)) != OB_SUCCESS)
    {
      TRANS_LOG("ObTableRpcScan init faild");
    }

    int32_t num = update_stmt->get_condition_size();
    for (int i = 0; i < num; ++i)
    {
      ObSqlRawExpr *cnd_expr = logical_plan->get_expr(update_stmt->get_condition_id(i));
      cnd_expr->set_applied(true);
      ObSqlExpression *filter = ObSqlExpression::alloc();
      if (NULL == filter)
      {
        ret = OB_ALLOCATE_MEMORY_FAILED;
        TRANS_LOG("no memory");
        break;
      }
      else if ((ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan)) != OB_SUCCESS)
      {
        TRANS_LOG("Add table filter condition faild");
        break;
      }
      else if ((ret = table_rpc_scan_op->add_filter(filter)) != OB_SUCCESS)
      {
        TRANS_LOG("Add table filter condition faild");
        break;
      }
    }
    ObSqlExpression expr;
    for (int32_t i = 0; ret == OB_SUCCESS && i < row_desc.get_column_num(); i++)
    {
      uint64_t tid = OB_INVALID_ID;
      uint64_t cid = OB_INVALID_ID;
      expr.reset();
      if (OB_SUCCESS != (ret = row_desc.get_tid_cid(i, tid, cid)))
      {
        TRANS_LOG("Faild to get tid cid, err=%d",ret);
        break;
      }
      else
      {
        ObBinaryRefRawExpr col_raw_ref(tid, cid, T_REF_COLUMN);
        expr.reset();;
        ObSqlRawExpr col_ref(OB_INVALID_ID, tid, cid, &col_raw_ref);
        if (OB_SUCCESS != (ret = col_ref.fill_sql_expression(expr, this, logical_plan, physical_plan)))
        {
          TRANS_LOG("Faild to fill expression, err=%d",ret);
          break;
        }
        else if (OB_SUCCESS != (ret = table_rpc_scan_op->add_output_column(expr)))
        {
          TRANS_LOG("Faild to add output column, err=%d",ret);
          break;
        }
      }
    }
    ObSqlRawExpr *raw_expr = NULL;
    uint64_t expr_id = OB_INVALID_ID;
    uint64_t column_id = OB_INVALID_ID;
    for (int64_t column_idx = 0; column_idx < update_stmt->get_update_column_count(); column_idx++)
    {
      expr.reset();
      const ObColumnSchemaV2 *column_schema = NULL;
      if (OB_SUCCESS != (ret = update_stmt->get_update_column_id(column_idx, column_id)))
      {
        TRANS_LOG("Faild to get_update_column_id for table[%ld] column idx[%ld], err=%d",table_id, column_idx, ret);
        break;
      }
      else if (OB_SUCCESS != (ret = update_stmt->get_update_expr_id(column_idx, expr_id)))
      {
        TRANS_LOG("Faild to get_update_expr_id for table[%ld] column [%ld], err=%d",table_id, column_id, ret);
        break;
      }
      else if (NULL == (raw_expr = logical_plan->get_expr(expr_id)))
      {
        TRANS_LOG("Faild to get_expr from logical_plan for table[%ld] column [%ld] column idx[%ld]",table_id,column_id, column_idx);
        ret = OB_ERR_UNEXPECTED;
        break;
      }
      else if (OB_SUCCESS != (ret = raw_expr->fill_sql_expression(expr, this, logical_plan, physical_plan)))
      {
        TRANS_LOG("Faild to fill expression, err=%d",ret);
        break;
      }
      else
      {
        expr.set_tid_cid(table_id, column_id);
        op_update_rowkey->add_sql_expression(expr);
      }
      column_schema = sql_context_->schema_manager_->get_column_schema(table_id, column_id);
      const ObObjType type = column_schema->get_type();
      op_update_rowkey->add_value_type(type);
    }
    if (OB_SUCCESS == ret)
    {
      op_update_rowkey->set_select_more_rows(table_rpc_scan_op);
    }
  }
  return ret;
}

int ObTransformer::check_partition_value_type(
    ObLogicalPlan *logical_plan,
    ObSelectStmt *select_stmt,
    ObString table_name,
    ObTableRuleNode table_node,
    ObArray<ObObj> &partition_value,
    ObString &partition_key)
{
  int ret = OB_SUCCESS;
  ObPartRuleNode part_node;
  ObArray<ObString> param_list;
  partition_key = table_node.get_para_list();
  part_node.separate(partition_key, PARTITION_LIST_SEPARATOR, param_list);
  ObSqlRawExpr *partition_expr = NULL;
  int64_t partition_expr_count = select_stmt->get_partition_cal_values_size();
  const ObColumnSchemaV2 *col_schema = NULL;
  if(param_list.count() != partition_expr_count)
  {
    ret = OB_ERROR;
    YYSYS_LOG(USER_ERROR, "partition_key num is not equal to function param num,partition_key_num=%ld,param_list_num=%ld",\
              partition_expr_count,param_list.count());
  }
  else
  {
    ObObj orig_cell;
    ObObj cast_obj;
    ObObj obj_type;
    const ObObj *res_obj = NULL;
    for (int64_t i = 0; ret == OB_SUCCESS && i < partition_expr_count; i++)
    {
      uint64_t expr_id = select_stmt->get_partition_cal_value_id(i);
      if (NULL == (partition_expr = logical_plan->get_expr(expr_id)))
      {
        ret = OB_ERROR;
        YYSYS_LOG(WARN, "failed to get partition expr");
      }
      else
      {
        ObConstRawExpr *part_expr = dynamic_cast<ObConstRawExpr *>(partition_expr->get_expr());
        orig_cell = part_expr->get_value();
        if (NULL == (col_schema =sql_context_->schema_manager_->get_column_schema(table_name, param_list.at(i))))
        {
          YYSYS_LOG(WARN, "failed to get col_schema");
        }
        else
        {
          obj_type.set_type(col_schema->get_type());
          if (OB_SUCCESS != (ret = obj_cast(orig_cell, obj_type, cast_obj, res_obj)))
          {
            YYSYS_LOG(WARN, "failed to cast to  obj=%s, expected type:%d", to_cstring(orig_cell), col_schema->get_type());
            YYSYS_LOG(USER_ERROR, "The data type of partition_value[%ld] is not compatible,the input type:%d,expected type:%d",i, orig_cell.get_type(), col_schema->get_type());
            break;
          }
          partition_value.push_back(*res_obj);
        }
      }
    }
  }
  return ret;
}

int ObTransformer::gen_phy_select_partition_calc_func(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat &err_stat,
    const uint64_t &query_id,
    int32_t *index)
{
  OB_ASSERT(sql_context_);
  OB_ASSERT(sql_context_->schema_manager_);
  OB_ASSERT(sql_context_->session_info_);
  int &ret = err_stat.err_code_  = OB_SUCCESS;
  ObSelectStmt *select_stmt = NULL;
  ObValues *result_op = NULL;
  if (ret ==OB_SUCCESS)
  {
    get_stmt(logical_plan, err_stat, query_id, select_stmt);
  }
  if (ret == OB_SUCCESS)
  {
    ObRowDesc row_desc;
    CREATE_PHY_OPERRATOR(result_op, ObValues, physical_plan, err_stat);
    int64_t field_num = result_->get_field_columns().count();
    int64_t column_id = OB_APP_MIN_COLUMN_ID;
    for (int64_t i = 0; ret == OB_SUCCESS && i < field_num; i++)
    {
      if ((ret = row_desc.add_column_desc(common::OB_INVALID_ID, column_id+i)) != OB_SUCCESS)
      {
        TRANS_LOG("add row desc error, err=%d",ret);
      }
    }
    if (ret == OB_SUCCESS && (ret = result_op->set_row_desc(row_desc)) != OB_SUCCESS)
    {
      TRANS_LOG("add row desc error, err=%d",ret);
    }
    else
    {
      ObRow val_row;
      val_row.set_row_desc(row_desc);
      uint64_t table_id = OB_INVALID_ID;
      int64_t version_flag = OB_INVALID_ID;
      ObString table_name;
      int64_t cur_version = OB_INVALID_ID;
      ObString valid_version;
      int64_t start_version = OB_INVALID_VERSION;
      int64_t end_version = OB_INVALID_VERSION;
      int64_t table_rule_start_version = OB_INVALID_VERSION;
      int64_t table_rule_end_version = OB_INVALID_VERSION;
      int64_t group_start_version = OB_INVALID_VERSION;
      int64_t group_end_version = OB_INVALID_VERSION;
      ObString partition_key;
      ObString group_name;
      char temp[OB_MAX_TABLE_NAME_LENGTH] = {0};
      group_name.assign_buffer(temp, static_cast<int32_t>(OB_MAX_TABLE_NAME_LENGTH));
      int32_t paxos_id = OB_INVALID_PAXOS_ID;
      bool has_next_version = false;
      bool has_last_version = false;
      table_id = select_stmt->get_partition_cal_table_id();
      version_flag = select_stmt->get_partition_cal_version_flag();
      const ObTableSchema *schema = sql_context_->schema_manager_->get_table_schema(table_id);
      if (schema == NULL)
      {
        ret = OB_ERROR;
        YYSYS_LOG(WARN, "schema is null,table_id:%ld",table_id);
      }
      else if (schema->get_index_helper().tbl_tid != OB_INVALID_ID || table_id < 3001)
      {
        ret = OB_NOT_SUPPORTED;
        YYSYS_LOG(USER_ERROR, "table is index table or system table");
      }
      else
      {
        ObTableRuleNode table_node;
        ObTableRuleNode last_table_node;
        table_name = ObString::make_string(schema->get_table_name());
        cur_version = sql_context_->session_info_->get_frozen_version() +1;
        bool is_need_last_table_rule = false;
        bool get_last_table_rule = false;
        if (ret==OB_SUCCESS)
        {
          if(OB_SUCCESS != (ret = sql_context_->partition_mgr_->get_table_node_with_version(table_id, version_flag, cur_version,\
                                                                                            has_next_version, has_last_version, table_node, table_rule_start_version, table_rule_end_version, last_table_node)))
          {
            YYSYS_LOG(WARN, "failed to get table node");
          }
          while(ret==OB_SUCCESS)
          {
            if (is_need_last_table_rule)
            {
              get_last_table_rule = true;
              if (version_flag == -1 && has_last_version == true)
              {
                table_node = last_table_node;
                table_rule_start_version = table_node.get_start_version();
                table_rule_end_version = table_node.get_end_version();
                group_start_version = OB_INVALID_VERSION;
                group_end_version = OB_INVALID_VERSION;
                partition_key.reset();
                group_name.reset();
                group_name.assign_buffer(temp, static_cast<int32_t>(OB_MAX_TABLE_NAME_LENGTH));
              }
              else
              {
                has_last_version = false;
                break;
              }
            }
            if(OB_WITHOUT_PARTITION == table_node.get_partition_type())
            {
              group_name = table_node.get_prefix_name();
              if (OB_SUCCESS != (ret = sql_context_->partition_mgr_->get_group_node_id_with_version(version_flag, has_next_version, has_last_version, group_name, cur_version, paxos_id,\
                                                                                                    group_start_version, group_end_version, table_node, is_need_last_table_rule)))
              {
                YYSYS_LOG(WARN, "failed to get group name and paxos id");
              }
            }
            else if(OB_DIRECT_PARTITION == table_node.get_partition_type())
            {
              ObArray<ObObj> partition_value;
              if (OB_SUCCESS != (ret = check_partition_value_type(logical_plan, select_stmt, table_name, table_node, partition_value, partition_key)))
              {
                if(version_flag == -1 && !is_need_last_table_rule &&!get_last_table_rule)
                {
                  is_need_last_table_rule = true;
                  ret = OB_SUCCESS;
                }
                else
                {
                  YYSYS_LOG(WARN, "partition_value's type is not correct");
                }
              }
              else if (OB_SUCCESS != (ret = sql_context_->partition_mgr_->get_group_and_paxos_id(table_node, version_flag, cur_version, has_next_version, has_last_version, partition_value,\
                                                                                                 group_start_version, group_end_version, group_name, paxos_id, is_need_last_table_rule)))
              {
                YYSYS_LOG(WARN, "failed to get group name and paxos id ");
              }
            }
            if (!is_need_last_table_rule || get_last_table_rule)
            {
              break;
            }
          }
          if (ret == OB_SUCCESS && (version_flag == 0 || (version_flag == 1 && has_next_version) || (version_flag == -1 && has_last_version)))
          {
            ObObj table_id_obj;
            ObObj table_name_obj;
            ObObj cur_version_obj;
            ObObj valid_version_obj;
            ObObj partition_key_obj;
            ObObj group_name_obj;
            ObObj paxos_id_obj;
            table_id_obj.set_int(table_id);
            table_name_obj.set_varchar(table_name);
            cur_version_obj.set_int(cur_version);
            start_version = table_rule_start_version >= group_start_version ? table_rule_start_version : group_start_version;
            end_version = table_rule_end_version <= group_end_version ? table_rule_end_version : group_end_version;
            const char *VALID_VERSION_FORMAT1 = "[%ld, %ld)";
            const char *VALID_VERSION_FORMAT2 = "[%ld, MAX)";
            const int MAX_VALID_VERSION_BUF_SIZE = 100;
            char valid_version_buf[MAX_VALID_VERSION_BUF_SIZE];
            if (end_version == INT64_MAX)
            {
              snprintf(valid_version_buf, MAX_VALID_VERSION_BUF_SIZE, VALID_VERSION_FORMAT2, start_version);
            }
            else
            {
              snprintf(valid_version_buf, MAX_VALID_VERSION_BUF_SIZE, VALID_VERSION_FORMAT1, start_version, end_version);
            }
            valid_version.assign_ptr(valid_version_buf, static_cast<int32_t>(strlen(valid_version_buf)));
            valid_version_obj.set_varchar(valid_version);
            partition_key_obj.set_varchar(partition_key);
            group_name_obj.set_varchar(group_name);
            paxos_id_obj.set_int(paxos_id);
            if ((ret = val_row.set_cell(OB_INVALID_ID, column_id+0, table_id_obj)) != OB_SUCCESS)
            {
              TRANS_LOG("Add value to ObRow failed");
            }
            else if ((ret = val_row.set_cell(OB_INVALID_ID, column_id+1, table_name_obj)) != OB_SUCCESS)
            {
              TRANS_LOG("Add value to ObRow failed");
            }
            else if ((ret = val_row.set_cell(OB_INVALID_ID, column_id+2, cur_version_obj)) != OB_SUCCESS)
            {
              TRANS_LOG("Add value to ObRow failed");
            }
            else if ((ret = val_row.set_cell(OB_INVALID_ID, column_id+3, valid_version_obj)) != OB_SUCCESS)
            {
              TRANS_LOG("Add value to ObRow failed");
            }
            else if ((ret = val_row.set_cell(OB_INVALID_ID, column_id+4, partition_key_obj)) != OB_SUCCESS)
            {
              TRANS_LOG("Add value to ObRow failed");
            }
            else if ((ret = val_row.set_cell(OB_INVALID_ID, column_id+5, group_name_obj)) != OB_SUCCESS)
            {
              TRANS_LOG("Add value to ObRow failed");
            }
            else if ((ret = val_row.set_cell(OB_INVALID_ID, column_id+6, paxos_id_obj)) != OB_SUCCESS)
            {
              TRANS_LOG("Add value to ObRow failed");
            }
            else if (ret == OB_SUCCESS && (ret = result_op->add_values(val_row)) != OB_SUCCESS)
            {
              TRANS_LOG("Add value row failed");
            }
          }
          else if (ret == OB_SUCCESS && version_flag == 2)
          {
            ObObj paxos_id_obj;
            paxos_id_obj.set_int(paxos_id);
            if ((ret = val_row.set_cell(OB_INVALID_ID, column_id+0, paxos_id_obj)) != OB_SUCCESS)
            {
              TRANS_LOG("Add value to ObRow failed");
            }
            else if ((ret = result_op->add_values(val_row)) != OB_SUCCESS)
            {
              TRANS_LOG("Add value row failed");
            }
          }
          else
          {
            result_->set_affected_rows(0);
          }
        }
      }
    }
  }
  if(ret == OB_SUCCESS)
  {
    ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, select_stmt, result_op, index);
  }
  return ret;
}

int ObTransformer::gen_physical_gather_statistics(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat &err_stat,
    const uint64_t &query_id,
    int32_t *index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObGatherStatisticsStmt *gather_statistics_stmt = NULL;
  ObGatherStatistics *gather_statistics_op = NULL;
  if (ret == OB_SUCCESS)
  {
    get_stmt(logical_plan, err_stat, query_id, gather_statistics_stmt);
  }
  if (OB_SUCCESS == ret)
  {
    ObString table_name;
    char dn[OB_MAX_DATBASE_NAME_LENGTH];
    char tn[OB_MAX_TABLE_NAME_LENGTH];
    ObString dname;
    ObString tname;
    dname.assign_buffer(dn, OB_MAX_DATBASE_NAME_LENGTH);
    tname.assign_buffer(tn, OB_MAX_TABLE_NAME_LENGTH);
    table_name = gather_statistics_stmt->get_table_name();
    if (!table_name.split_two(dname,tname))
    {
      TRANS_LOG("table name[%.*s] is invalid",table_name.length(), table_name.ptr());
    }
    else if (OB_SUCCESS != (ret = check_dbname_for_table(err_stat, dname)))
    {
      TRANS_LOG("gather table statistics failed because the database name %.*s not exist",dname.length(), dname.ptr());
    }
    else if (TableSchema::is_system_table(table_name))
    {
      ret = OB_ERR_NO_PRIVILEGE;
      YYSYS_LOG(USER_ERROR, "system table can not be gathered, table_name=%.*s",
                table_name.length(), table_name.ptr());
    }
  }
  if (OB_SUCCESS == ret)
  {
    CREATE_PHY_OPERRATOR(gather_statistics_op, ObGatherStatistics, physical_plan, err_stat);
    if (OB_SUCCESS == ret)
    {
      gather_statistics_op->set_sql_context(*sql_context_);
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, gather_statistics_stmt, gather_statistics_op, index);
    }
  }
  if (OB_SUCCESS == ret)
  {
    gather_statistics_op->set_if_not_exists(gather_statistics_stmt->get_if_exists());
    gather_statistics_op->set_table_id(gather_statistics_stmt->get_statistics_table_id());
    gather_statistics_op->set_row_key_info(gather_statistics_stmt->get_row_key_info());
    if (hash::HASH_INSERT_SUCC != ObMergeServerMain::get_instance()->get_merge_server().add_udi_index(gather_statistics_stmt->get_statistics_table_id()))
    {
      YYSYS_LOG(WARN, "failed to add table_id into udi_index_!");
    }
    for (int64_t i = 0; i<gather_statistics_stmt->get_statistics_colums_count(); i++)
    {
      if (OB_SUCCESS != (ret = gather_statistics_op->set_column_id(gather_statistics_stmt->get_column_id(i))))
      {
        TRANS_LOG("Add gather column failed");
        break;
      }
    }
    gather_statistics_op->set_context(sql_context_);
  }
  return ret;
}

bool ObTransformer::is_enable_index_for_one_table(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ObStmt *stmt,
    ObOptimizerRelation *rel_opt,
    uint64_t table_id,
    ObArray<ObIndexTableInfo> &can_used_index_table_array)
{
  Expr_Array filter_array;
  common::ObArray<ObSqlExpression*> fp_array;
  Expr_Array project_array;
  Expr_Array order_array;
  Expr_Array group_array;
  Join_column_Array join_column;
  bool not_use_index = false;
  int ret = OB_SUCCESS;
  bool return_ret = false;
  TableItem *table_item = NULL;
  ObBitSet<> table_bitset;
  int32_t num = 0;
  ObSeqScanInfo rel_opt_seq_scan_info = rel_opt->get_seq_scan_info();

  if (NULL==stmt)
  {
    YYSYS_LOG(ERROR, "QX enter this stmt = NULL");
  }
  else
  {
    table_item = stmt->get_table_item_by_id(table_id);
    not_use_index = stmt->get_query_hint().not_use_index_;
  }
  if(table_item!= NULL && rel_opt!= NULL)
  {
  }
  else
  {
    YYSYS_LOG(WARN, "QX table_item is NULL or rel_opt is NULL table id = %ld", table_id);
    ret = OB_NOT_SUPPORTED;
  }
  if (not_use_index)
  {
    return_ret = false;
  }
  else
  {
    if(OB_SUCCESS == ret)
    {
      int32_t bit_index = stmt->get_table_bit_index(table_item->table_id_);
      table_bitset.add_member(bit_index);
      if (bit_index<0)
      {
        YYSYS_LOG(ERROR, "QX negative bitmap values,table_id=%ld ref_id=%ld", table_item->table_id_, table_item->ref_id_);
      }
      num = stmt->get_condition_size();
      for(int32_t i =0;ret==OB_SUCCESS&&i<num;i++)
      {
        ObSqlRawExpr *cnd_expr = logical_plan->get_expr(stmt->get_condition_id(i));
        if(cnd_expr && table_bitset.is_superset(cnd_expr->get_tables_set()))
        {
          if(!cnd_expr->can_push_down_with_outerjoin())
          {
            continue;
          }
          ObSqlExpression *filter = ObSqlExpression::alloc();
          if (NULL == filter)
          {
            ret = OB_ALLOCATE_MEMORY_FAILED;
            YYSYS_LOG(ERROR, "no memory");
            break;
          }
          else if ((ret = cnd_expr->fill_sql_expression(*filter, this, logical_plan, physical_plan)) != OB_SUCCESS)
          {
            YYSYS_LOG(ERROR, "Add table filter condition faild");
            ObSqlExpression::free(filter);
            break;
          }
          else if (OB_SUCCESS != (ret = filter_array.push_back(*filter)))
          {
            YYSYS_LOG(ERROR, "push back to filter array failed");
            ObSqlExpression::free(filter);
            break;
          }
          else if (OB_SUCCESS != (ret = fp_array.push_back(filter)))
          {

            ObSqlExpression::free(filter);
            YYSYS_LOG(ERROR, "push back to filter array ptr failed");
            break;
          }
        }
      }
      ObVector<TableItem> table_item_v;
      for (int i =0;i<stmt->get_table_size();i++)
      {
        TableItem tmp;
        tmp = stmt->get_table_item(i);
        table_item_v.push_back(tmp);
      }
      for (int i=0; i<logical_plan->get_expr_list_num();i++)
      {
        bool is_same_order = false;
        ExprItem::SqlCellInfo c1;
        ExprItem::SqlCellInfo c2;
        ObSqlRawExpr * ob_sql_raw_expr = logical_plan->get_expr_for_something(i);
        if (NULL == ob_sql_raw_expr)
        {
          ret = OB_ERR_POINTER_IS_NULL;
          YYSYS_LOG(WARN, "logical plan expression is null!");
        }
        else
        {
          ObSqlExpression *cond_expr = ObSqlExpression::alloc();
          if(cond_expr == NULL)
          {
            ret = OB_ALLOCATE_MEMORY_FAILED;
            YYSYS_LOG(WARN, "no memory");
          }
          else if (ob_sql_raw_expr->get_expr()->is_join_cond())
          {
            if(OB_SUCCESS != (ret = ob_sql_raw_expr->fill_sql_expression(
                                *cond_expr,
                                this,
                                logical_plan,
                                physical_plan)))
            {
              YYSYS_LOG(WARN, "get equijoin_cond faild! ret[%d]",ret);
            }
            else
            {
              cond_expr->is_equijoin_cond(c1, c2);
              for(int i=0;i<table_item_v.size();i++)
              {
                uint64_t tmp_tid = table_item_v.at(i).table_id_;
                if (c1.tid == tmp_tid)
                {
                  i++;
                  for(; i < table_item_v.size(); i++)
                  {
                    tmp_tid = table_item_v.at(i).table_id_;
                    if (c2.tid == tmp_tid)
                    {
                      is_same_order = true;
                      break;
                    }
                  }
                }
              }
            }
            if(is_same_order)
            {
              if(c2.tid == table_id)
              {
                join_column.push_back(c2.cid);
              }
              if(c1.tid == table_id)
              {
                join_column.push_back(c1.cid);
              }
            }
            else
            {
              if(c1.tid == table_id)
              {
                join_column.push_back(c1.cid);
              }
              if(c2.tid == table_id)
              {
                join_column.push_back(c2.cid);
              }
            }
          }
          if(cond_expr != NULL)
          {
            ObSqlExpression::free(cond_expr);
            cond_expr = NULL;
          }
        }
      }
      bool only_single_table = true;
      if (ret == OB_SUCCESS)
      {
        bool can_apply_group_by = false;
        bool can_apply_order_by = false;
        ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
        if(only_single_table
           && select_stmt->get_from_item_size() == 1
           && !select_stmt->get_from_item(0).is_joined_)
        {
          can_apply_group_by = true;
          can_apply_order_by = true;
        }
        else if(!only_single_table
                && join_column.count() == 1
                && select_stmt->get_from_item_size() == 2
                && !select_stmt->get_from_item(0).is_joined_
                && !select_stmt->get_from_item(1).is_joined_)
        {
          if (rel_opt->get_group_by_num() == 1)
          {
            ObSqlRawExpr *group_expr = logical_plan->get_expr(select_stmt->get_group_expr_id(0));
            if(group_expr->get_column_id() == join_column.at(0))
            {
              can_apply_group_by = true;
            }
          }
          if ((can_apply_group_by || rel_opt->get_group_by_num() == 0)
              && rel_opt->get_order_by_num() == 1)
          {
            const OrderItem& order_item = select_stmt->get_order_item(0);
            ObSqlRawExpr *order_expr = logical_plan->get_expr(order_item.expr_id_);
            if (order_expr->get_column_id() == join_column.at(0))
            {
              can_apply_order_by = true;
            }
          }
        }
        if (can_apply_group_by || can_apply_order_by)
        {
          ObIndexTableInfo idx_info;
          idx_info.index_table_id_ = table_item->ref_id_;
          ObArray<ObIndexTableInfo> index_table_info_array;
          index_table_info_array.push_back(idx_info);
          if (rel_opt->get_group_by_num() > 0
              && can_apply_group_by
              && OB_SUCCESS != (ret = optimize_group_by_index_V2(index_table_info_array, table_item->ref_id_, stmt, logical_plan)))
          {
            YYSYS_LOG(WARN, "QX optimize_group_by_index failed,ret = %d",ret);
          }
          else if (idx_info.group_by_applyed_)
          {
            rel_opt_seq_scan_info.group_by_applyed_ = true;
          }
          if (OB_SUCCESS == ret
              && rel_opt->get_order_by_num() > 0
              && can_apply_order_by
              && OB_SUCCESS != (ret = optimize_order_by_index_V2(index_table_info_array, table_item->ref_id_, stmt, logical_plan)))
          {
            YYSYS_LOG(WARN, "QX optimize_order_by_index failed,ret = %d",ret);
          }
          else if (idx_info.order_by_applyed_)
          {
            rel_opt_seq_scan_info.order_by_applyed_ = true;
          }
        }
      }
      //add output columns
      num = stmt->get_column_size();
      for (int32_t i=0;ret==OB_SUCCESS&&i < num;i++)
      {
        const ColumnItem *col_item = stmt->get_column_item(i);
        if(col_item&&col_item->table_id_ == table_item->table_id_)
        {
          ObBinaryRefRawExpr col_expr(col_item->table_id_, col_item->column_id_, T_REF_COLUMN);
          ObSqlRawExpr col_raw_expr(
                common::OB_INVALID_ID,
                col_item->table_id_,
                col_item->column_id_,
                &col_expr);
          ObSqlExpression output_expr;
          if ((ret = col_raw_expr.fill_sql_expression(
                 output_expr,
                 this,
                 logical_plan,
                 physical_plan)) != OB_SUCCESS)
          {
            YYSYS_LOG(ERROR, "Add table output columns faild");
            break;
          }
          else
          {
            project_array.push_back(output_expr);
          }
        }
      }
      ObSelectStmt *select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
      if (ret == OB_SUCCESS && select_stmt)
      {
        num = select_stmt->get_order_item_size();
        for (int32_t i=0;ret==OB_SUCCESS &&i < num ;i++)
        {
          const OrderItem& order_item = select_stmt->get_order_item(i);
          ObSqlRawExpr *order_expr = logical_plan->get_expr(order_item.expr_id_);
          if (order_expr)
          {
            ObSqlExpression output_expr;
            if ((ret = order_expr->fill_sql_expression(
                   output_expr,
                   this,
                   logical_plan,
                   physical_plan)) != OB_SUCCESS)
            {
              YYSYS_LOG(ERROR, "Add table order columns faild");
              break;
            }
            else
            {
              order_array.push_back(output_expr);
            }
          }
        }
        num = select_stmt->get_group_expr_size();
        for (int32_t i =0;ret==OB_SUCCESS && i<num; i++)
        {
          uint64_t expr_id = select_stmt->get_group_expr_id(i);
          ObSqlRawExpr *group_expr = logical_plan->get_expr(expr_id);
          if (group_expr)
          {
            ObSqlExpression output_expr;
            if ((ret = group_expr->fill_sql_expression(
                   output_expr,
                   this,
                   logical_plan,
                   physical_plan)) != OB_SUCCESS)
            {
              YYSYS_LOG(ERROR, "Add table group columns faild");
              break;
            }
            else
            {
              group_array.push_back(output_expr);
            }
          }
        }
      }
    }
    if (OB_SUCCESS == ret)
    {
      bool is_use_hint = false;
      bool use_hint_for_storing = false;
      bool use_hint_without_storing = false;
      bool is_use_storing_column = false;
      bool is_use_index_without_storing = false;
      uint64_t index_id_without_storing=OB_INVALID_ID;
      if (stmt->get_query_hint().has_index_hint())
      {
        for (int i=0;i<stmt->get_query_hint().use_index_array_.size();i++)
        {
          ObIndexTableNamePair tmp = stmt->get_query_hint().use_index_array_.at(i);
          if (tmp.src_table_id_ == table_item->ref_id_)
          {
            is_use_hint = true;
            use_hint_for_storing = is_can_use_hint_for_storing_V3(&filter_array, &project_array, tmp.index_table_id_, &join_column,stmt,can_used_index_table_array);
            if (!use_hint_for_storing)
            {
              use_hint_without_storing = is_can_use_hint_index_V3(&filter_array,tmp.index_table_id_,&join_column,stmt,can_used_index_table_array);
            }
            break;
          }
        }
        if(use_hint_for_storing==false&&use_hint_without_storing==false)
        {
          is_use_hint =false;
        }
      }
      if(!is_use_hint)
      {
        is_use_storing_column = decide_is_use_storing_or_not_V3(&filter_array,&project_array,can_used_index_table_array, table_item->ref_id_,&join_column,stmt,logical_plan,&order_array,&group_array);
        if(is_use_storing_column==false)
        {
          const ObTableSchema *mian_table_schema = NULL;
          if (NULL == (mian_table_schema = sql_context_->schema_manager_->get_table_schema(table_item->ref_id_)))
          {
            YYSYS_LOG(WARN, "QX Fail to get table schema for table[%ld]",table_item->ref_id_);
          }
          else
          {
            const ObRowkeyInfo *rowkey_info = &mian_table_schema->get_rowkey_info();
            uint64_t main_cid = OB_INVALID_ID;
            rowkey_info->get_column_id(0,main_cid);
            bool is_where_condition_have_main_cid = true;
            if(!is_wherecondition_have_main_cid_V2(&filter_array, main_cid))
            {
              is_where_condition_have_main_cid = false;
              for(int l=0;l<join_column.count();l++)
              {
                uint64_t tmp_cid = join_column.at(l);
                common::ObArray<uint64_t> index_table_array;
                if(is_this_expr_can_use_index_for_joinV2(tmp_cid, index_table_array,table_item->ref_id_, sql_context_->schema_manager_))
                {
                  for(int64_t i=0;i<index_table_array.count();i++)
                  {
                    is_use_index_without_storing=true;
                    ObIndexTableInfo index_table_info;
                    index_table_info.index_column_id_ = tmp_cid;
                    index_table_info.index_table_id_ = index_table_array.at(i);
                    index_table_info.is_back_ = true;
                    can_used_index_table_array.push_back(index_table_info);
                  }
                }
              }
              int64_t c_num = filter_array.count();
              for(int32_t j=0;j<c_num;j++)
              {
                ObSqlExpression c_filter = filter_array.at(j);
                uint64_t tmp_cid;
                if(c_filter.is_this_expr_can_use_index(index_id_without_storing,table_item->ref_id_,sql_context_->schema_manager_))
                {
                  is_use_index_without_storing=true;
                  ObIndexTableInfo index_table_info;
                  c_filter.get_cid(tmp_cid);//[742]
                  index_table_info.index_column_id_ = tmp_cid;
                  index_table_info.index_table_id_ = index_id_without_storing;
                  index_table_info.is_back_ = true;
                  can_used_index_table_array.push_back(index_table_info);
                }
              }
            }
            else
            {
              if (stmt == NULL)
              {
                ret = OB_ERR_POINTER_IS_NULL;
                YYSYS_LOG(WARN, "QX [semi join] stmt is null!");
              }
              else if (stmt->get_query_hint().join_array_.size()>0)
              {
                ObJoinTypeArray tmp_join_type = stmt->get_query_hint().join_array_.at(0);
                if(tmp_join_type.join_type_ == T_SEMI_JOIN || tmp_join_type.join_type_ == T_SEMI_BTW_JOIN)
                {
                  for(int l=0;l<join_column.count();l++)
                  {
                    uint64_t tmp_cid = join_column.at(l);
                    if(is_this_expr_can_use_index_for_join(tmp_cid, index_id_without_storing, table_item->ref_id_, sql_context_->schema_manager_))
                    {
                      is_use_index_without_storing=true;
                      ObIndexTableInfo index_table_info;
                      index_table_info.index_column_id_ = tmp_cid;
                      index_table_info.index_table_id_ = index_id_without_storing;
                      index_table_info.is_back_ = true;
                      can_used_index_table_array.push_back(index_table_info);
                    }
                  }
                }
              }
            }
            if(is_use_index_without_storing && can_used_index_table_array.count()>0)
            {
              if(group_array.count() > 0 && OB_SUCCESS != (ret = optimize_group_by_index_V2(can_used_index_table_array,table_item->ref_id_, stmt, logical_plan)))
              {
                YYSYS_LOG(WARN, "QX optimize_group_by_index failed,ret=%d",ret);
              }
              if (OB_SUCCESS == ret && order_array.count() > 0)
              {
                if (OB_SUCCESS != (ret = optimize_order_by_index_V2(can_used_index_table_array, table_item->ref_id_, stmt,logical_plan)))
                {
                  YYSYS_LOG(WARN, "QX optimize_order_by_index failed,ret=%d",ret);
                }
              }
            }
            else if(!is_where_condition_have_main_cid)
            {
              if (group_array.count() > 0)
              {
                ObSqlExpression c_filter = group_array.at(0);
                uint64_t tmp_cid;
                if(c_filter.is_this_expr_can_use_index(index_id_without_storing,table_item->ref_id_, sql_context_->schema_manager_))
                {
                  is_use_index_without_storing=true;
                  ObIndexTableInfo index_table_info;
                  c_filter.get_cid(tmp_cid);//[742]
                  index_table_info.index_column_id_ = tmp_cid;
                  index_table_info.index_table_id_ = index_id_without_storing;
                  index_table_info.is_back_ = true;
                  can_used_index_table_array.push_back(index_table_info);
                  if(OB_SUCCESS != (ret = optimize_group_by_index_V2(can_used_index_table_array,table_item->ref_id_, stmt, logical_plan)))
                  {
                    YYSYS_LOG(WARN, "QX optimize_group_by_index failed,ret=%d",ret);
                  }
                }
              }
              if(OB_SUCCESS == ret && order_array.count() > 0)
              {
                if (can_used_index_table_array.count() > 0)
                {
                  if (OB_SUCCESS != (ret = optimize_order_by_index_V2(can_used_index_table_array, table_item->ref_id_, stmt,logical_plan)))
                  {
                    YYSYS_LOG(WARN, "QX optimize_order_by_index failed,ret = %d",ret);
                  }
                }
                else if (0 == group_array.count())
                {
                  ObSqlExpression c_filter = order_array.at(0);
                  uint64_t tmp_cid;
                  if (c_filter.is_this_expr_can_use_index(index_id_without_storing, table_item->ref_id_, sql_context_->schema_manager_))
                  {
                    is_use_index_without_storing=true;
                    ObIndexTableInfo index_table_info;
                    c_filter.get_cid(tmp_cid);//[742]
                    index_table_info.index_column_id_ = tmp_cid;
                    index_table_info.index_table_id_ = index_id_without_storing;
                    index_table_info.is_back_ = true;
                    can_used_index_table_array.push_back(index_table_info);
                    if(OB_SUCCESS != (ret = optimize_order_by_index_V2(can_used_index_table_array,table_item->ref_id_, stmt, logical_plan)))
                    {
                      YYSYS_LOG(WARN, "QX optimize_order_by_index failed,ret=%d",ret);
                    }
                  }
                }
              }
            }
          }
        }
      }
      else
      {
        if(use_hint_for_storing)
        {
          is_use_storing_column = true;
        }
        else if (use_hint_without_storing)
        {
          is_use_index_without_storing = true;
        }
        if (use_hint_for_storing || use_hint_without_storing)
        {
          if(group_array.count() > 0 && OB_SUCCESS != (ret = optimize_group_by_index_V2(can_used_index_table_array, table_item->ref_id_,stmt, logical_plan)))
          {
            YYSYS_LOG(WARN, "QX optimize group by index failed,ret=%d",ret);
          }
          if(OB_SUCCESS == ret && order_array.count()>0)
          {
            if (OB_SUCCESS != (ret = optimize_order_by_index_V2(can_used_index_table_array, table_item->ref_id_,stmt, logical_plan)))
            {
              YYSYS_LOG(WARN, "QX optimize order by index failed,ret=%d",ret);
            }
          }
        }
      }
      if (is_use_storing_column ==true ||is_use_index_without_storing==true)
      {
        return_ret = true;
      }
      int64_t sub_query_num = 0;
      int64_t num=0;
      num = filter_array.count();
      for (int32_t i=0;ret == OB_SUCCESS&&i<num;i++)
      {
        sub_query_num = sub_query_num + filter_array.at(i).get_sub_query_num();
      }
      if(sub_query_num==0)
      {
      }
      else
        return_ret = false;
      if(OB_SUCCESS !=ret)
      {
        return_ret = false;
      }
    }
  }
  for (int64_t i = 0;i < fp_array.count(); i++)
  {
    ObSqlExpression* filter = fp_array.at(i);
    if (NULL != filter)
    {
      ObSqlExpression::free(filter);
    }
  }
  join_column.clear();
  (void)rel_opt_seq_scan_info;
  return return_ret;
}

bool ObTransformer::decide_is_use_storing_or_not_V3(
    Expr_Array *filter_array,
    Expr_Array *project_array,
    ObArray<ObIndexTableInfo> &can_used_index_table_array,
    uint64_t main_tid,
    Join_column_Array *join_column,
    ObStmt *stmt,
    ObLogicalPlan *logical_plan,
    Expr_Array *order_array,
    Expr_Array *group_array
    )
{
  bool return_ret = false;
  int ret = OB_SUCCESS;
  uint64_t tid = main_tid;
  const ObTableSchema *mian_table_schema = NULL;
  if (NULL == (mian_table_schema = sql_context_->schema_manager_->get_table_schema(tid)))
  {
    YYSYS_LOG(WARN, "QX Fail to get table schema for table[%ld]",tid);
  }
  else
  {
    const ObRowkeyInfo *rowkey_info = &mian_table_schema->get_rowkey_info();
    uint64_t main_cid = OB_INVALID_ID;
    rowkey_info->get_column_id(0,main_cid);
    if (!is_wherecondition_have_main_cid_V2(filter_array,main_cid) ||
        join_column->count() >0)
    {
      for(int l =0;l<join_column->count();l++)
      {
        common::ObArray<uint64_t> index_tid_array;
        if(is_expr_can_use_storing_for_joinV2(join_column->at(l),tid,index_tid_array,filter_array,project_array))
        {
          for(int64_t i=0;i<index_tid_array.count();i++)
          {
            ObIndexTableInfo index_table_info;
            index_table_info.index_column_id_ = join_column->at(l);
            index_table_info.index_table_id_ = index_tid_array.at(i);
            index_table_info.is_back_ = false;
            can_used_index_table_array.push_back(index_table_info);
            return_ret = true;
          }
        }
      }
      int64_t c_num = filter_array->count();
      int32_t i = 0;
      for(;ret == OB_SUCCESS&&i < c_num;i++)
      {
        ObSqlExpression c_filter = filter_array->at(i);
        if(!c_filter.is_expr_has_more_than_two_columns())
        {
          common::ObArray<uint64_t> index_tid_array;
          if(is_expr_can_use_storing_V3(c_filter,tid,index_tid_array,filter_array,project_array))
          {
            for(int64_t i=0;i<index_tid_array.count();i++)
            {
              ObIndexTableInfo index_table_info;
              uint64_t expr_cid = OB_INVALID_ID;
              c_filter.get_cid(expr_cid);//[742]
              index_table_info.index_column_id_ = expr_cid;
              index_table_info.index_table_id_ = index_tid_array.at(i);
              index_table_info.is_back_ = false;
              can_used_index_table_array.push_back(index_table_info);
              return_ret = true;
            }
          }
        }
      }
      if (OB_SUCCESS==ret)
      {
        if(return_ret && can_used_index_table_array.count()>0)
        {
          if(group_array->count() > 0 && OB_SUCCESS != (ret = optimize_group_by_index_V2(can_used_index_table_array,tid,stmt,logical_plan)))
          {
            YYSYS_LOG(WARN, "QX optimize group by index failed,ret=%d",ret);
          }
          if (OB_SUCCESS == ret && order_array->count() > 0)
          {
            if(OB_SUCCESS != (ret = optimize_order_by_index_V2(can_used_index_table_array,tid,stmt,logical_plan)))
            {
              YYSYS_LOG(WARN, "QX optimize order by index failed,ret=%d",ret);
            }
          }
        }
        else
        {
          bool is_use_index_without_storing = false;
          uint64_t index_tid = OB_INVALID_ID;
          for(int32_t j=0;j<c_num;j++)
          {
            ObSqlExpression &c_filter = filter_array->at(j);
            if(c_filter.is_this_expr_can_use_index(index_tid,tid,sql_context_->schema_manager_))
            {
              is_use_index_without_storing = true;
              break;
            }
          }
          if(!is_use_index_without_storing && group_array->count() > 0)
          {
            ObSqlExpression &c_filter = group_array->at(0);
            if(!c_filter.is_expr_has_more_than_two_columns())
            {
              common::ObArray<uint64_t> index_tid_array;
              if(is_expr_can_use_storing_V3(c_filter, tid, index_tid_array, filter_array, project_array))
              {
                for(int64_t i = 0;i<index_tid_array.count();i++)
                {
                  ObIndexTableInfo index_table_info;
                  uint64_t expr_cid = OB_INVALID_ID;
                  c_filter.get_cid(expr_cid);//[742]
                  index_table_info.index_column_id_ = expr_cid;
                  index_table_info.index_table_id_ = index_tid_array.at(i);
                  index_table_info.is_back_ = false;
                  can_used_index_table_array.push_back(index_table_info);
                  return_ret = true;
                }
                if(OB_SUCCESS != (ret = optimize_group_by_index_V2(can_used_index_table_array,tid,stmt,logical_plan)))
                {
                  YYSYS_LOG(WARN, "QX optimize group by index failed,ret=%d",ret);
                }
              }
            }
          }
          if (OB_SUCCESS == ret && !is_use_index_without_storing && order_array->count() > 0)
          {
            if(OB_SUCCESS != (ret = optimize_order_by_index_V2(can_used_index_table_array,tid,stmt,logical_plan)))
            {
              YYSYS_LOG(WARN, "QX optimize order by index failed,ret=%d",ret);
            }
            else if (0 == group_array->count())
            {
              ObSqlExpression &c_filter = order_array->at(0);
              if(!c_filter.is_expr_has_more_than_two_columns())
              {
                common::ObArray<uint64_t> index_tid_array;
                if(is_expr_can_use_storing_V3(c_filter, tid, index_tid_array, filter_array, project_array))
                {
                  for(int64_t i = 0;i<index_tid_array.count();i++)
                  {
                    ObIndexTableInfo index_table_info;
                    uint64_t expr_cid = OB_INVALID_ID;
                    c_filter.get_cid(expr_cid);//[742]
                    index_table_info.index_column_id_ = expr_cid;
                    index_table_info.index_table_id_ = index_tid_array.at(i);
                    index_table_info.is_back_ = false;
                    can_used_index_table_array.push_back(index_table_info);
                    return_ret = true;
                  }
                  if(OB_SUCCESS != (ret = optimize_order_by_index_V2(can_used_index_table_array,tid,stmt,logical_plan)))
                  {
                    YYSYS_LOG(WARN, "QX optimize order by index failed,ret=%d",ret);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return return_ret;
}

bool ObTransformer::is_expr_can_use_storing_V3(
    ObSqlExpression c_filter,
    uint64_t mian_tid,
    common::ObArray<uint64_t> &index_table_array,
    Expr_Array *filter_array,
    Expr_Array *project_array)
{
  bool ret = false;
  uint64_t expr_cid = OB_INVALID_ID;
  uint64_t tmp_index_tid = OB_INVALID_ID;
  uint64_t index_tid_array[OB_MAX_INDEX_NUMS];
  for(int32_t k=0;k<OB_MAX_INDEX_NUMS;k++)
  {
    index_tid_array[k] = OB_INVALID_ID;
  }
  if(OB_SUCCESS == c_filter.get_cid(expr_cid))//[742]
  {
    if(sql_context_->schema_manager_->is_cid_in_index(expr_cid, mian_tid, index_tid_array))
    {
      for(int32_t i=0;i<OB_MAX_INDEX_NUMS;i++)
      {
        if(index_tid_array[i]!=OB_INVALID_ID)
        {
          if(is_index_table_has_all_cid_V2(index_tid_array[i],filter_array,project_array))
          {
            tmp_index_tid = index_tid_array[i];
            index_table_array.push_back(tmp_index_tid);
            ret =true;
          }
        }
      }
    }
  }
  return ret;
}

bool ObTransformer::is_this_expr_can_use_index_for_joinV2(
    uint64_t cid,
    ObArray<uint64_t> &can_used_index_table_array,
    uint64_t main_tid,
    const ObSchemaManagerV2 *sm_v2)
{
  bool return_ret = false;
  uint64_t tmp_index_tid[OB_MAX_INDEX_NUMS];
  uint64_t index_tid;
  for(int32_t m=0;m<OB_MAX_INDEX_NUMS;m++)
  {
    tmp_index_tid[m]=OB_INVALID_ID;
  }
  if(sm_v2->is_cid_in_index(cid,main_tid,tmp_index_tid))
  {
    for(int i=0;i<OB_MAX_INDEX_NUMS&&tmp_index_tid[i]!=OB_INVALID_ID;i++)
    {
      index_tid = tmp_index_tid[i];
      can_used_index_table_array.push_back(tmp_index_tid[i]);
      return_ret =true;
    }
  }
  return return_ret;
}

bool ObTransformer::is_expr_can_use_storing_for_joinV2(
    uint64_t cid,
    uint64_t mian_tid,
    ObArray<uint64_t> &can_used_index_table_array,
    Expr_Array *filter_array,
    Expr_Array *project_array)
{
  bool ret = false;
  uint64_t expr_cid = cid;
  uint64_t tmp_index_tid = OB_INVALID_ID;
  uint64_t index_tid_array[OB_MAX_INDEX_NUMS];
  for(int32_t k=0;k<OB_MAX_INDEX_NUMS;k++)
  {
    index_tid_array[k] = OB_INVALID_ID;
  }
  if(sql_context_->schema_manager_->is_cid_in_index(expr_cid, mian_tid, index_tid_array))
  {
    for(int32_t i=0;i<OB_MAX_INDEX_NUMS;i++)
    {
      if(index_tid_array[i]!=OB_INVALID_ID)
      {
        if(is_index_table_has_all_cid_V2(index_tid_array[i],filter_array,project_array))
        {
          tmp_index_tid = index_tid_array[i];
          can_used_index_table_array.push_back(tmp_index_tid);
          ret =true;
        }
      }
    }
  }
  return ret;
}

bool ObTransformer::is_can_use_hint_index_V3(
    Expr_Array *filter_ayyay,
    uint64_t index_table_id,
    Join_column_Array *join_column,
    ObStmt *stmt,
    ObArray<ObIndexTableInfo> &can_used_index_table_array
    )
{
  bool can_use_hint_index = false;
  bool cond_has_main_cid = false;
  const ObTableSchema *index_table_schema = NULL;
  if (NULL == (index_table_schema = sql_context_->schema_manager_->get_table_schema(index_table_id)))
  {
    YYSYS_LOG(WARN, "QX fail to get table schema for table[%ld]",index_table_id);
  }
  else
  {
    const ObRowkeyInfo& rowkey_info = index_table_schema->get_rowkey_info();
    uint64_t index_key_cid = OB_INVALID_ID;
    if(OB_SUCCESS != rowkey_info.get_column_id(0, index_key_cid))
    {
      YYSYS_LOG(WARN,"QX fail to get column id, index_table name:[%s], index_table id: [%ld]",
                index_table_schema->get_table_name(), index_table_schema->get_table_id());
      cond_has_main_cid = false;
    }
    else if (!is_wherecondition_have_main_cid_V2(filter_ayyay, index_key_cid))
    {
      if(stmt == NULL)
      {
        YYSYS_LOG(WARN, "[semi join] stmt is null!");
      }
      else if (stmt->get_query_hint().join_array_.size() >0)
      {
        ObJoinTypeArray tmp_join_type = stmt->get_query_hint().join_array_.at(0);
        if(tmp_join_type.join_type_ == T_SEMI_JOIN || tmp_join_type.join_type_ == T_SEMI_BTW_JOIN)
        {
          for(int l=0;l<join_column->count();l++)
          {
            if (join_column->at(l) == index_key_cid)
            {
              cond_has_main_cid = true;
              ObIndexTableInfo index_table_info;
              index_table_info.index_table_id_ = index_table_id;
              index_table_info.index_column_id_ = index_key_cid;
              index_table_info.is_back_ = true;
              can_used_index_table_array.push_back(index_table_info);
              break;
            }
            else
            {
              cond_has_main_cid = false;
            }
          }
        }
        else
        {
          cond_has_main_cid = false;
        }
      }
      else
      {
        cond_has_main_cid = false;
      }
    }
    else
    {
      if(stmt == NULL)
      {
        YYSYS_LOG(WARN, "[semi join] stmt is null!");
      }
      else if (stmt->get_query_hint().join_array_.size()>0)
      {
        ObJoinTypeArray tmp_join_type = stmt->get_query_hint().join_array_.at(0);
        if(tmp_join_type.join_type_ == T_SEMI_JOIN || tmp_join_type.join_type_ == T_SEMI_BTW_JOIN)
        {
          for(int l=0;l<join_column->count();l++)
          {
            if (join_column->at(l) == index_key_cid)
            {
              cond_has_main_cid = true;
              ObIndexTableInfo index_table_info;
              index_table_info.index_table_id_ = index_table_id;
              index_table_info.index_column_id_ = index_key_cid;
              index_table_info.is_back_ = true;
              can_used_index_table_array.push_back(index_table_info);
              //break;
            }
            else
            {
              cond_has_main_cid = false;
            }
          }
        }
        else
        {
          cond_has_main_cid = true;
        }
      }
      else
      {
        cond_has_main_cid = true;
      }
    }
  }
  if (cond_has_main_cid)
  {
    can_use_hint_index = true;
  }
  if(!sql_context_->schema_manager_->is_this_table_avalibale(index_table_id))
  {
    can_use_hint_index = false;
    can_used_index_table_array.pop_back();
  }
  return can_use_hint_index;
}

bool ObTransformer::is_can_use_hint_for_storing_V3(
    Expr_Array *filter_array,
    Expr_Array *project_array,
    uint64_t index_table_id,
    Join_column_Array *join_column,
    ObStmt *stmt,
    ObArray<ObIndexTableInfo> &can_used_index_table_array)
{
  bool cond_has_main_cid = false;
  bool can_use_hint_for_storing = false;
  const ObTableSchema *index_table_schema = NULL;
  if (NULL == (index_table_schema = sql_context_->schema_manager_->get_table_schema(index_table_id)))
  {
    YYSYS_LOG(WARN, "QX Fail to get table schema for table[%ld]",index_table_id);
  }
  else if (sql_context_->schema_manager_->is_this_table_avalibale(index_table_id))
  {
    const ObRowkeyInfo& rowkey_info = index_table_schema->get_rowkey_info();
    uint64_t index_key_cid = OB_INVALID_ID;
    if(OB_SUCCESS != rowkey_info.get_column_id(0, index_key_cid))
    {
      YYSYS_LOG(WARN,"QX Fail to get column id, index_table name:[%s], index_table id: [%ld]",
                index_table_schema->get_table_name(), index_table_schema->get_table_id());
      cond_has_main_cid = false;
    }
    else if (!is_wherecondition_have_main_cid_V2(filter_array, index_key_cid))
    {
      if(stmt == NULL)
      {
        YYSYS_LOG(WARN, "[semi join] stmt is null!");
      }
      else if (stmt->get_query_hint().join_array_.size()>0)
      {
        ObJoinTypeArray tmp_join_type = stmt->get_query_hint().join_array_.at(0);
        if(tmp_join_type.join_type_ == T_SEMI_JOIN || tmp_join_type.join_type_ == T_SEMI_BTW_JOIN)
        {
          for(int l=0;l<join_column->count();l++)
          {
            if (join_column->at(l) == index_key_cid)
            {
              cond_has_main_cid = true;
              ObIndexTableInfo index_table_info;
              index_table_info.index_table_id_ = index_table_id;
              index_table_info.index_column_id_ = index_key_cid;
              index_table_info.is_back_ = false;
              can_used_index_table_array.push_back(index_table_info);
            }
            else
            {
              cond_has_main_cid = false;
            }
          }
        }
        else
        {
          cond_has_main_cid = false;
        }
      }
      else
      {
        cond_has_main_cid =false;
      }
    }
    else
    {
      if(stmt == NULL)
      {
        YYSYS_LOG(WARN, "[semi join] stmt is null!");
      }
      else if (stmt->get_query_hint().join_array_.size()>0)
      {
        ObJoinTypeArray tmp_join_type = stmt->get_query_hint().join_array_.at(0);
        if(tmp_join_type.join_type_ == T_SEMI_JOIN || tmp_join_type.join_type_ == T_SEMI_BTW_JOIN)
        {
          for(int l=0;l<join_column->count();l++)
          {
            if (join_column->at(l) != index_key_cid)
            {
              cond_has_main_cid = false;
            }
            else
            {
              cond_has_main_cid = true;
              ObIndexTableInfo index_table_info;
              index_table_info.index_table_id_ = index_table_id;
              index_table_info.index_column_id_ = index_key_cid;
              index_table_info.is_back_ = false;
              can_used_index_table_array.push_back(index_table_info);
            }
          }
        }
        else
        {
          cond_has_main_cid = true;
        }
      }
      else
      {
        cond_has_main_cid =true;
      }
    }
  }
  if(cond_has_main_cid)
  {
    can_use_hint_for_storing = is_index_table_has_all_cid_V2(index_table_id, filter_array, project_array);
    if(!can_use_hint_for_storing)
    {
      can_used_index_table_array.pop_back();
    }
  }
  else
  {
    can_use_hint_for_storing =false;
  }
  return can_use_hint_for_storing;
}

int ObTransformer::add_semi_join_expr_V2(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ObSemiJoin &join_op,
    ObSort &l_sort,
    ObSort &r_sort,
    ObSqlRawExpr &expr,
    const bool is_table_expr_same_order,
    oceanbase::common::ObList<ObSqlRawExpr *> &remainder_cnd_list,
    bool &is_add_other_join_cond,
    ObJoin::JoinType join_type,
    ObSelectStmt *select_stmt,
    int id,
    ObJoinTypeArray &hint_temp)
{
  int ret = OB_SUCCESS;
  UNUSED(id);
  bool is_on_expr_push_down = true;
  bool is_cons_right_table_filter = true;
  bool is_get_all_index_table_for_right_table = false;
  bool is_decide_use_index = true;
  ObSqlRawExpr join_expr = expr;
  ObBinaryOpRawExpr equal_expr = *(dynamic_cast<ObBinaryOpRawExpr*>(expr.get_expr()));
  join_expr.set_expr(&equal_expr);
  ObBinaryRefRawExpr *expr1 = NULL;
  ObBinaryRefRawExpr *expr2 = NULL;
  uint64_t first_table_id = OB_INVALID_ID;
  uint64_t second_table_id = OB_INVALID_ID;
  uint64_t index_table_id = OB_INVALID_ID;
  uint64_t left_index_table_id = OB_INVALID_ID;
  uint64_t right_main_cid = OB_INVALID_ID;
  bool is_use_index = false;
  uint64_t left_table_id = OB_INVALID_ID;
  uint64_t right_table_id = OB_INVALID_ID;
  uint64_t left_alias_table_id = OB_INVALID_ID;
  uint64_t right_alias_table_id = OB_INVALID_ID;
  uint64_t right_expr_column_id = OB_INVALID_ID;

  TableItem *left_table_item = NULL;
  TableItem *right_table_item = NULL;
  ObSqlExpression join_op_cnd;
  ObOptimizerRelation* rel_opt = NULL;
  ObIndexTableInfo index_table_info;
  if (hint_temp.join_type_ == T_SEMI_BTW_JOIN)
  {
    join_op.set_use_btw(true);
  }
  else if (hint_temp.join_type_ == T_SEMI_JOIN)
  {
    join_op.set_use_in(true);
  }
  if (OB_UNLIKELY(!expr.get_expr() || expr.get_expr()->get_expr_type() != T_OP_EQ))
  {
    ret = OB_ERR_GEN_PLAN;
    YYSYS_LOG(WARN, "QX Wrong expression of semi join, ret=%d", ret);
  }
  else
  {
    if (is_table_expr_same_order)
    {
      expr1 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_first_op_expr());
      expr2 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_second_op_expr());
    }
    else
    {
      expr2 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_first_op_expr());
      expr1 = dynamic_cast<ObBinaryRefRawExpr*>(equal_expr.get_second_op_expr());
      equal_expr.set_op_exprs(expr1,expr2);
    }
    if ((ret = l_sort.add_sort_column(expr1->get_first_ref_id(), expr1->get_second_ref_id(), true)) != OB_SUCCESS
        ||(ret = r_sort.add_sort_column(expr2->get_first_ref_id(), expr2->get_second_ref_id(), true)) != OB_SUCCESS)
    {
      join_op.set_is_can_use_semi_join(false);
      YYSYS_LOG(WARN, "QX Add sort column faild, ret = %d", ret);
    }
    else
    {
      if(select_stmt == NULL)
      {
        join_op.set_is_can_use_semi_join(false);
        ret = OB_ERR_POINTER_IS_NULL;
        YYSYS_LOG(WARN, "QX [semi join] select stmt is null!");
      }
      else
      {
        left_table_item = select_stmt->get_table_item_by_id(expr1->get_first_ref_id());
        right_table_item = select_stmt->get_table_item_by_id(expr2->get_first_ref_id());
        if(left_table_item == NULL||right_table_item == NULL)
        {
          join_op.set_is_can_use_semi_join(false);
          ret = OB_ERR_POINTER_IS_NULL;
          YYSYS_LOG(WARN, "QX [semi join] left table item is null or right item is null!");
        }
        else
        {
          left_table_id = left_table_item->ref_id_;
          right_table_id = right_table_item->ref_id_;
          left_alias_table_id = left_table_item->table_id_;
          right_alias_table_id = right_table_item->table_id_;
          right_expr_column_id = expr2->get_second_ref_id();
        }
      }
      if (OB_SUCCESS == ret && is_get_all_index_table_for_right_table)
      {
        if(sql_context_ == NULL)
        {
          join_op.set_is_can_use_semi_join(false);
          ret = OB_ERR_POINTER_IS_NULL;
          YYSYS_LOG(WARN, "QX [semi join] sql_context is null!");
        }
        else
        {
          const common::ObSchemaManagerV2 *schema_manager = sql_context_->schema_manager_;
          IndexList first_table_index_table_list;
          IndexList second_table_index_table_list;
          if(schema_manager == NULL)
          {
            join_op.set_is_can_use_semi_join(false);
            ret = OB_ERR_POINTER_IS_NULL;
            YYSYS_LOG(WARN, "QX [semi join] schema manager is null!");
          }
          else
          {
            schema_manager->get_index_list(left_table_id, first_table_index_table_list);
            schema_manager->get_index_list(right_table_id, second_table_index_table_list);
            for(int64_t i=0;i<first_table_index_table_list.get_count();i++)
            {
              first_table_index_table_list.get_idx_id(i, first_table_id);
            }
            for(int64_t i=0;i<second_table_index_table_list.get_count();i++)
            {
              second_table_index_table_list.get_idx_id(i, second_table_id);
            }
          }
        }
      }
      if(OB_SUCCESS == ret)
      {
        if(OB_SUCCESS != (ret = join_op.set_alias_table(right_table_item->table_id_, select_stmt)))
        {
          join_op.set_is_can_use_semi_join(false);
          YYSYS_LOG(WARN, "QX don't know right table[%ld],ret[%d]", right_table_item->table_id_, ret);
        }
      }
      if(OB_SUCCESS == ret && is_decide_use_index)
      {
        if((ret = join_expr.fill_sql_expression(
              join_op_cnd,
              this,
              logical_plan,
              physical_plan)) != OB_SUCCESS)
        {
          join_op.set_is_can_use_semi_join(false);
          YYSYS_LOG(WARN, "QX [semi join] fill join op condition faild!");
        }
        else
        {
          {
            const ObTableSchema *right_mian_table_schema = NULL;
            if (NULL == (right_mian_table_schema = sql_context_->schema_manager_->get_table_schema(right_table_id)))
            {
              join_op.set_is_can_use_semi_join(false);
              YYSYS_LOG(ERROR, "[semi join] get right table schema[%ld] faild", right_table_id);
            }
            else
            {
              const ObRowkeyInfo *right_rowkey_info = &right_mian_table_schema->get_rowkey_info();
              if(right_rowkey_info != NULL)
                right_rowkey_info->get_column_id(0,right_main_cid);
              else
              {
                join_op.set_is_can_use_semi_join(false);
                ret = OB_ERR_POINTER_IS_NULL;
                YYSYS_LOG(ERROR, "[semi join] get right table row key info faild");
              }
            }
          }
          oceanbase::common::ObList<ObOptimizerRelation*> * rel_opt_list= select_stmt->get_rel_opt_list();
          oceanbase::common::ObList<ObOptimizerRelation*>::const_iterator iter = rel_opt_list->begin();
          for (;iter!=rel_opt_list->end();iter++)
          {
            if ((*iter)->get_table_id() == right_alias_table_id)
            {
              rel_opt = (*iter);
              common::ObVector<ObIndexTableInfo> &index_table_array = rel_opt->get_index_table_array();
              int32_t cheapest_index_table_idx = 0;
              double tmp_cheapest_cost;
              if (index_table_array.size() > 0)
              {
                tmp_cheapest_cost = DBL_MAX;
                for(int32_t i = 0; i < rel_opt->get_index_table_array().size(); i++)
                {
                  if(rel_opt->get_index_table_array().at(i).cost_ < tmp_cheapest_cost
                     && rel_opt->get_index_table_array().at(i).index_column_id_ == right_expr_column_id)
                  {
                    tmp_cheapest_cost = rel_opt->get_index_table_array().at(i).cost_;
                    cheapest_index_table_idx = i;
                  }
                }
                if (tmp_cheapest_cost <= rel_opt->get_seq_scan_cost())
                {
                  index_table_info = rel_opt->get_index_table_array().at(cheapest_index_table_idx);
                  is_use_index = true;
                  index_table_id = index_table_info.index_table_id_;
                  break;
                }
              }
              else
              {
                join_op.set_is_use_second_index(false);
              }
              break;
            }
          }
          for (iter = rel_opt_list->begin();iter!= rel_opt_list->end();iter++)
          {
            if ((*iter)->get_table_id() == left_alias_table_id)
            {
              rel_opt = (*iter);
              common::ObVector<ObIndexTableInfo> &index_table_array = rel_opt->get_index_table_array();
              int32_t cheapest_index_table_idx = 0;
              double tmp_cheapest_cost;
              if (index_table_array.size() > 0)
              {
                tmp_cheapest_cost = rel_opt->get_index_table_array().at(0).cost_;
                for(int32_t i=1; i< rel_opt->get_index_table_array().size();i++)
                {
                  if (rel_opt->get_index_table_array().at(i).cost_ < tmp_cheapest_cost)
                  {
                    tmp_cheapest_cost = rel_opt->get_index_table_array().at(i).cost_;
                    cheapest_index_table_idx = i;
                  }
                }
                if (tmp_cheapest_cost <= rel_opt->get_seq_scan_cost())
                {
                  ObIndexTableInfo index_table_info = rel_opt->get_index_table_array().at(cheapest_index_table_idx);
                  left_index_table_id = index_table_info.index_table_id_;
                  break;
                }
              }
              break;
            }
          }
          if (OB_SUCCESS == ret)
          {
            if (ObJoin::INNER_JOIN == join_type ||
                ObJoin::LEFT_OUTER_JOIN == join_type)
            {
              if (is_use_index)
              {
                join_op.set_is_use_second_index(true);
                join_op.set_index_table_id(first_table_id, index_table_info.index_table_id_);
                if (index_table_info.is_back_)
                {
                  join_op.set_is_use_second_index_storing(false);
                  join_op.set_is_use_second_index_without_storing(true);
                }
                else
                {
                  join_op.set_is_use_second_index_storing(true);
                  join_op.set_is_use_second_index_without_storing(false);
                }
              }
              else
              {
                //YYSYS_LOG(DEBUG,"semi join not use second index");
              }
            }
          }
        }
      }
      if (OB_SUCCESS == ret)
      {
        if ((ret = join_op.add_equijoin_condition(join_op_cnd)) != OB_SUCCESS)
        {
          YYSYS_LOG(WARN, "[semi join] Add condition of join plan faild");
        }
        else
        {
          if (is_use_index)
          {
            join_op.set_id(join_op.equal_join_conds_count()-1);
          }
          if (is_add_other_join_cond)
          {
            if (OB_SUCCESS == ret && is_cons_right_table_filter)
            {
              ErrStat err_stat;
              ObFilter *right_table_filter = NULL;
              ObBitSet<> table_bitset;
              if (NULL == r_sort.get_child(0) || PHY_TABLE_RPC_SCAN != r_sort.get_child(0)->get_type())
              {
                join_op.set_is_can_use_semi_join(false);
                if(NULL == r_sort.get_child(0)) ret=OB_ERR_POINTER_IS_NULL;
                YYSYS_LOG(WARN, "[semi join] can not use semi join ! right phy is not table rpc scan! ret=%d", ret);
              }
              else if(NULL == right_table_item || NULL == select_stmt)
              {
                ret = OB_ERR_POINTER_IS_NULL;
                YYSYS_LOG(ERROR, "[semi join] right_table_item or select stmt is null");
              }
              else if(!(table_bitset.add_member(select_stmt->get_table_bit_index(right_table_item->table_id_))))
              {
                ret = OB_ERR_UNEXPECTED;
                YYSYS_LOG(WARN, "bitset add index failed,ret=%d",ret);
              }
              else if (NULL == CREATE_PHY_OPERRATOR(right_table_filter, ObFilter, physical_plan, err_stat)
                       || OB_SUCCESS != (ret = err_stat.err_code_))
              {
                ret = OB_ERR_POINTER_IS_NULL;
                YYSYS_LOG(ERROR, "[semi join] right table filter create failed!");
              }
              else
              {
                for (int32_t i =0; ret==OB_SUCCESS&&i < select_stmt->get_condition_size(); i++)
                {
                  ObSqlRawExpr *cnd_expr = NULL;
                  ObSqlExpression *filter = NULL;
                  if (NULL == (cnd_expr = logical_plan->get_expr(select_stmt->get_condition_id(i))))
                  {
                    ret = OB_ERR_POINTER_IS_NULL;
                    YYSYS_LOG(ERROR, "[semi join] condition expr is null!");
                  }
                  else if (false == table_bitset.is_superset(cnd_expr->get_tables_set()))
                  {
                  }
                  else if (ObJoin::INNER_JOIN != join_type && !cnd_expr->can_push_down_with_outerjoin())
                  {
                    continue;
                  }
                  else if (NULL == (filter = ObSqlExpression::alloc()))
                  {
                    ret = OB_ALLOCATE_MEMORY_FAILED;
                    YYSYS_LOG(WARN , "allocate memory for filter failed");
                  }
                  else if (OB_SUCCESS !=
                           (ret = cnd_expr->fill_sql_expression(*filter,this,logical_plan, physical_plan)))
                  {
                    TRANS_LOG("construct right table filter of semi join plan faild");
                  }
                  else if (OB_SUCCESS != (ret = right_table_filter->add_filter(filter)))
                  {
                    YYSYS_LOG(WARN , "[semi join] add filter[%d] to right table filter failed! ret=%d",i,ret);
                  }
                  if (OB_SUCCESS !=ret)
                  {
                    join_op.set_is_can_use_semi_join(false);
                    if (NULL != filter)
                    {
                      ObSqlExpression::free(filter);
                      filter= NULL;
                    }
                    break;
                  }
                }
              }
              if (OB_SUCCESS != ret)
              {
                join_op.set_is_can_use_semi_join(false);
                if (NULL != right_table_filter)
                {
                  right_table_filter->reset();
                  right_table_filter->~ObFilter();
                  right_table_filter = NULL;
                }
              }
              if (OB_SUCCESS == ret && NULL != right_table_filter)
              {
                join_op.set_right_table_filter(right_table_filter);
              }
            }
            if (ObJoin::INNER_JOIN == join_type && ret == OB_SUCCESS && is_on_expr_push_down)
            {
              if (NULL == expr1)
              {
                ret = OB_INVALID_ARGUMENT;
                YYSYS_LOG(ERROR, "first_op_expr is null,ret=%d",ret);
              }
              if (OB_SUCCESS == ret)
              {
                common::ObBitSet<> expr_bit_set1,expr_bit_set2;
                oceanbase::common::ObList<ObSqlRawExpr*>::iterator cnd_it_ll;
                for (cnd_it_ll = remainder_cnd_list.begin();
                     OB_SUCCESS == ret && cnd_it_ll != remainder_cnd_list.end(); ++cnd_it_ll)
                {
                  uint64_t table_id = OB_INVALID_ID;
                  bool add_suc = true;
                  ObSqlExpression *expr_temp = NULL;
                  if (NULL == (*cnd_it_ll)->get_expr())
                  {
                    ret = OB_ERR_POINTER_IS_NULL;
                    YYSYS_LOG(WARN, "[semi join] ObSqlRawExpr is null!");
                  }
                  else if ((*cnd_it_ll)->get_expr()->is_join_cond())
                  {
                    continue;
                  }
                  expr_bit_set1.clear();
                  expr_bit_set2.clear();
                  expr_bit_set1.add_member(select_stmt->get_table_bit_index(left_table_item->table_id_));
                  expr_bit_set2.add_member(select_stmt->get_table_bit_index(right_table_item->table_id_));
                  if (!expr_bit_set1.is_superset((*cnd_it_ll)->get_tables_set())
                      &&!expr_bit_set2.is_superset((*cnd_it_ll)->get_tables_set()))
                  {
                    continue;
                  }
                  if (left_index_table_id != OB_INVALID_ID
                      && expr_bit_set1.is_superset((*cnd_it_ll)->get_tables_set()))
                  {
                    continue;
                  }
                  if(NULL == (expr_temp = ObSqlExpression::alloc()))
                  {
                    ret = OB_ALLOCATE_MEMORY_FAILED;
                    YYSYS_LOG(WARN , "[semi join] expression is null!");
                  }
                  else if (OB_SUCCESS !=
                           (ret = (*cnd_it_ll)->fill_sql_expression(*expr_temp,this,logical_plan, physical_plan)))
                  {
                    YYSYS_LOG(WARN , "[semi join] fill_sql_expression falied!");
                  }
                  else if (expr_temp->is_not_equal_cond(table_id))
                  {
                    if(OB_INVALID_ID == table_id)
                    {
                      YYSYS_LOG(ERROR, "table id in expr is not valid");
                    }
                    if (NULL != expr_temp)
                    {
                      ObSqlExpression::free(expr_temp);
                      expr_temp = NULL;
                    }
                  }
                  else if (table_id == expr1->get_first_ref_id())
                  {
                    if (OB_SUCCESS != (ret = semi_join_add_filter(right_main_cid, right_table_id,index_table_id,
                                                                  l_sort,expr_temp, true,add_suc)))
                    {
                      YYSYS_LOG(WARN, "left sort add filter failed, ret=%d",ret);
                    }
                  }
                  else
                  {
                    if(OB_SUCCESS != (ret = semi_join_add_filter(right_main_cid, right_table_id,index_table_id,
                                                                 r_sort,expr_temp, false,add_suc)))
                    {
                      YYSYS_LOG(WARN, "left sort add filter failed, ret=%d",ret);
                    }
                  }
                  if (OB_SUCCESS != ret || !add_suc)
                  {
                    if (OB_SUCCESS !=ret)
                    {
                      join_op.set_is_can_use_semi_join(false);
                    }
                    if (NULL != expr_temp)
                    {
                      ObSqlExpression::free(expr_temp);
                      expr_temp = NULL;
                    }
                  }
                  if(OB_SUCCESS != ret)
                  {
                    break;
                  }
                }//end for
              }
            }
          }
        }
        if (OB_SUCCESS !=ret)
        {
          join_op.set_is_can_use_semi_join(false);
        }
      }
    }
  }
  if (OB_SUCCESS == ret)
  {
    if(r_sort.get_child(0) == NULL || l_sort.get_child(0) == NULL)
    {
      ret = OB_ERR_POINTER_IS_NULL;
      YYSYS_LOG(WARN, "[semi join] left sort op is null or right sort op is null");
    }
    else if (PHY_TABLE_MEM_SCAN == r_sort.get_child(0)->get_type())
    {
      join_op.set_is_can_use_semi_join(false);
    }
    else
    {

    }
  }
  return ret;
}

int ObTransformer::optimize_order_by_index_V2(
    ObArray<ObIndexTableInfo> &index_table_info_array,
    uint64_t main_tid,
    ObStmt *stmt,
    ObLogicalPlan *logical_plan)
{
  int ret = OB_SUCCESS;
  if (ObBasicStmt::T_SELECT == stmt->get_stmt_type())
  {
    ObSelectStmt* select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
    bool can_optimize = false;
    if (select_stmt->get_from_item_size() == 1
        && !select_stmt->get_from_item(0).is_joined_)
    {
      can_optimize = true;
    }
    int32_t num = select_stmt->get_order_item_size();
    for (int64_t j = 0; ret == OB_SUCCESS && can_optimize && num > 0 &&j < index_table_info_array.count(); j++)
    {
      uint64_t index_tid = index_table_info_array.at(j).index_table_id_;
      const ObTableSchema *idx_table_schema = NULL;
      if (NULL == (idx_table_schema = sql_context_->schema_manager_->get_table_schema(index_tid)))
      {
        ret = OB_ERROR;
        YYSYS_LOG(WARN,"QX Fail to get table schema for table[%ld]",index_tid);
      }
      else
      {
        const ObRowkeyInfo &idx_rk_info = idx_table_schema->get_rowkey_info();
        bool & hit_index = index_table_info_array.at(j).order_by_applyed_;
        if (select_stmt->get_group_expr_size() > 0 &&
            !index_table_info_array.at(j).group_by_applyed_)
        {
          hit_index = false;
          continue;
        }
        for(int32_t i=0; ret==OB_SUCCESS&&num <=idx_rk_info.get_size() && i < num;i++)
        {
          uint64_t column_id = OB_INVALID_ID;
          const OrderItem& order_item = select_stmt->get_order_item(i);
          ObSqlRawExpr *order_expr = logical_plan->get_expr(order_item.expr_id_);
          if (OB_SUCCESS != (ret = idx_rk_info.get_column_id(i, column_id)))
          {
            hit_index =false;
            break;
          }
          if (OrderItem::ASC == order_item.order_type_ && order_expr && order_expr->get_expr()->get_expr_type() == T_REF_COLUMN)
          {
            if (main_tid == order_expr->get_table_id() && column_id == order_expr->get_column_id())
            {
              hit_index = true;
              continue;
            }
            else
            {
              hit_index =false;
              break;
            }
          }
          else
          {
            hit_index =false;
            break;
          }
        }
      }
    }
  }
  return ret;
}

int ObTransformer::optimize_group_by_index_V2(
    ObArray<ObIndexTableInfo> &index_table_info_array,
    uint64_t main_tid,
    ObStmt *stmt,
    ObLogicalPlan *logical_plan)
{
  int ret = OB_SUCCESS;
  if (ObBasicStmt::T_SELECT == stmt->get_stmt_type())
  {
    ObSelectStmt* select_stmt = dynamic_cast<ObSelectStmt*>(stmt);
    bool can_optimize = false;
    if (select_stmt->get_from_item_size() == 1
        && !select_stmt->get_from_item(0).is_joined_)
    {
      can_optimize = true;
    }
    int32_t num = select_stmt->get_group_expr_size();
    for (int64_t j = 0; ret == OB_SUCCESS && can_optimize && num > 0 && j < index_table_info_array.count(); j++)
    {
      uint64_t index_tid = index_table_info_array.at(j).index_table_id_;
      const ObTableSchema *idx_table_schema = NULL;
      if (NULL == (idx_table_schema = sql_context_->schema_manager_->get_table_schema(index_tid)))
      {
        ret = OB_ERROR;
        YYSYS_LOG(WARN,"QX Fail to get table schema for table[%ld]",index_tid);
      }
      else
      {
        const ObRowkeyInfo &idx_rk_info = idx_table_schema->get_rowkey_info();
        bool & hit_index = index_table_info_array.at(j).group_by_applyed_;
        for(int32_t i=0; ret==OB_SUCCESS&&num <=idx_rk_info.get_size() && i < num;i++)
        {
          uint64_t column_id = OB_INVALID_ID;
          ObSqlRawExpr *group_expr = logical_plan->get_expr(select_stmt->get_group_expr_id(i));
          if (OB_SUCCESS != (ret = idx_rk_info.get_column_id(i, column_id)))
          {
            hit_index =false;
            break;
          }
          if (group_expr && group_expr->get_expr()->get_expr_type() == T_REF_COLUMN)
          {
            if (main_tid == group_expr->get_table_id() && column_id == group_expr->get_column_id())
            {
              hit_index = true;
              continue;
            }
            else
            {
              hit_index =false;
              break;
            }
          }
          else
          {
            hit_index =false;
            break;
          }
        }
      }
    }
  }
  return ret;
}

int ObTransformer::gen_physical_select_for_update_rowkey(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ObUpdateRowkey *&op_update_rowkey,
    ErrStat &err_stat,
    const uint64_t &query_id,
    int32_t *index
    )
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObUpdateStmt *update_stmt = NULL;
  UNUSED(index);
  ObRowDesc row_desc;
  ObRowDescExt row_desc_ext;
  const ObRowkeyInfo *rowkey_info = NULL;
  TableItem *table_item = NULL;

  uint64_t table_id = OB_INVALID_ID;
  if((ret = get_stmt(logical_plan, err_stat, query_id, update_stmt)) != OB_SUCCESS)
  {
  }
  if (OB_SUCCESS == ret)
  {
    table_id = update_stmt->get_update_table_id();
    if(table_id == OB_INVALID_ID
       || (table_item = update_stmt->get_table_item_by_id(table_id)) == NULL
       || TableItem::BASE_TABLE != table_item->type_)
    {
      ret = OB_ERR_ILLEGAL_ID;
      TRANS_LOG("Wrong table id, tid=%lu", table_id);
    }
    else if ((ret = cons_row_desc_for_select_all(table_id,
                                                 update_stmt,
                                                 row_desc_ext,
                                                 row_desc,
                                                 rowkey_info,
                                                 err_stat)) != OB_SUCCESS)
    {
    }
    else
    {
      if (OB_SUCCESS != (ret = op_update_rowkey->set_row_desc(row_desc)))
      {
        YYSYS_LOG(WARN, "op_update_rowkey set row desc not succ");
      }
      else if (OB_SUCCESS != (ret = op_update_rowkey->set_row_desc_ext(row_desc_ext)))
      {
        YYSYS_LOG(WARN, "op_update_rowkey set row desc ext not succ");
      }
      op_update_rowkey->set_rowkey_info(rowkey_info);
    }
    ObPhyOperator *sub_query_operator = NULL;
    if (OB_SUCCESS == ret)
    {
      bool is_non_where_condition = false;
      ParseNode *ud_where_parse_tree = update_stmt->get_ud_where_parse_tree();
      std::string column_names;
      std::string table_name;
      if (OB_SUCCESS != (ret = get_column_name_table_name(column_names, table_name, table_item, row_desc)))
      {
        YYSYS_LOG(WARN, "fail to get column_name[%s] and table_name[%s]", column_names.data(), table_name.data());
      }
      else
      {
        if (0 >= update_stmt->get_condition_size())
        {
          is_non_where_condition = true;
        }
        int32_t select_operator_id = OB_INVALID_INDEX;
        if(OB_SUCCESS != (ret = constuct_top_operator_of_select(is_non_where_condition,
                                                                ud_where_parse_tree,
                                                                physical_plan,
                                                                column_names,
                                                                table_name,
                                                                select_operator_id,
                                                                err_stat)))
        {
          YYSYS_LOG(WARN, "fail to construct operator of select");
        }
        else
        {
          if(NULL == (sub_query_operator = physical_plan->get_phy_query(select_operator_id)))
          {
            ret = OB_INVALID_INDEX;
            TRANS_LOG("wrong get sub query operator");
          }
        }
      }
    }
    ObSqlRawExpr *raw_expr = NULL;
    uint64_t expr_id = OB_INVALID_ID;
    uint64_t column_id = OB_INVALID_ID;
    ObSqlExpression expr;
    for(int64_t column_idx = 0; column_idx < update_stmt->get_update_column_count(); column_idx++)
    {
      expr.reset();
      const ObColumnSchemaV2 *column_schema = NULL;
      if (OB_SUCCESS != (ret = update_stmt->get_update_column_id(column_idx, column_id)))
      {
        TRANS_LOG("Failed to get_update_column_id for table[%ld] column idx[%ld], err=%d", table_id, column_idx, ret);
        break;
      }
      else if (OB_SUCCESS != (ret = update_stmt->get_update_expr_id(column_idx, expr_id)))
      {
        TRANS_LOG("Failed to get_update_expr_id for table[%ld] column[%ld], err=%d", table_id, column_id, ret);
        break;
      }
      else if (NULL == (raw_expr = logical_plan->get_expr(expr_id)))
      {
        TRANS_LOG("Failed to get_expr from logical_plan for table[%ld] column[%ld] column idx[%ld]",
                  table_id, column_id, column_idx);
        ret = OB_ERR_UNEXPECTED;
        break;
      }
      else if (OB_SUCCESS != (ret = raw_expr->fill_sql_expression(expr, this, logical_plan, physical_plan)))
      {
        TRANS_LOG("Faild to fill expression, err=%d", ret);
        break;
      }
      else
      {
        expr.set_tid_cid(table_id, column_id);
        op_update_rowkey->add_sql_expression(expr);
      }
      column_schema = sql_context_->schema_manager_->get_column_schema(table_id, column_id);
      const ObObjType type = column_schema->get_type();
      op_update_rowkey->add_value_type(type);
    }
    if (OB_SUCCESS == ret)
    {
      op_update_rowkey->set_select_more_rows(sub_query_operator);
    }
  }
  return ret;
}

int ObTransformer::gen_physical_create_view(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat &err_stat,
    const uint64_t &query_id,
    int32_t *index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObCreateView *create_view_op = NULL;
  ObCreateViewStmt *create_view_stmt = NULL;
  if(OB_SUCCESS != (ret = get_stmt(logical_plan, err_stat, query_id, create_view_stmt)))
  {

  }
  if(ret == OB_SUCCESS)
  {
    const ObString &view_name = create_view_stmt->get_view_name();
    if(TableSchema::is_system_table_v2(view_name))
    {
      ret = OB_ERR_NO_PRIVILEGE;
      YYSYS_LOG(USER_ERROR, "invalid view name to create, view_name=[%.*s]", view_name.length(), view_name.ptr());
    }
  }
  if(ret == OB_SUCCESS)
  {
    ret = check_dbname_for_table(err_stat, create_view_stmt->get_db_name());
  }
  if(ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(create_view_op, ObCreateView, physical_plan, err_stat);
    create_view_op->set_sql_context(*sql_context_);
    create_view_op->set_do_replace(create_view_stmt->get_do_replace());
    if(OB_SUCCESS != (ret = physical_plan->add_phy_query(create_view_op, index, true)))
    {
      YYSYS_LOG(WARN, "failed to add query, err=%d", ret);
    }
  }
  if(ret == OB_SUCCESS)
  {
      if(create_view_stmt->get_column_size() > OB_MAX_USER_DEFINED_COLUMNS_COUNT)
      {
          ret = OB_ERR_INVALID_COLUMN_NUM;
          TRANS_LOG("too many columns (max allowed is %ld).", OB_MAX_USER_DEFINED_COLUMNS_COUNT);
      }
  }
  if(ret == OB_SUCCESS)
  {
    common::TableSchema &table_schema = create_view_op->get_table_schema();
    const ObString &view_name = create_view_stmt->get_view_name();
    if(view_name.ptr() != NULL && static_cast<int64_t>(view_name.length()) < OB_MAX_TABLE_NAME_LENGTH)
    {
      snprintf(table_schema.table_name_, view_name.length() + 1, "%s", view_name.ptr());
    }
    const ObString &dbname = create_view_stmt->get_db_name();
    if(dbname.ptr() != NULL && static_cast<int64_t>(dbname.length()) < OB_MAX_DATBASE_NAME_LENGTH)
    {
      snprintf(table_schema.dbname_, dbname.length() + 1, "%s", dbname.ptr());
    }
    const char *sql_text = create_view_stmt->get_sql_text();
    if(sql_text != NULL && *sql_text != '\0')
    {
      snprintf(table_schema.text_, sizeof(table_schema.text_), "%s", sql_text);
    }
    //partition type
    table_schema.table_partition_type_ = OB_WITHOUT_PARTITION;
    snprintf(table_schema.group_name_prefix_, strlen(OB_DEFAULT_GROUP_NAME) + 1, "%s", OB_DEFAULT_GROUP_NAME);
    table_schema.table_type_ = TableSchema::VIEW;
    sql::ObViewCheckOption check_option = create_view_stmt->get_with_check_option();
    table_schema.with_check_option_ = static_cast<TableSchema::WithCheckOption>(check_option);
    table_schema.is_updatable_ = false;
  }
  return ret;
}

int ObTransformer::gen_physical_drop_view(
    ObLogicalPlan *logical_plan,
    ObPhysicalPlan *physical_plan,
    ErrStat &err_stat,
    const uint64_t &query_id,
    int32_t *index)
{
  int &ret = err_stat.err_code_ = OB_SUCCESS;
  ObDropView *drop_view_op = NULL;
  ObDropViewStmt *drop_view_stmt = NULL;
  ret = get_stmt(logical_plan, err_stat, query_id, drop_view_stmt);
  if (OB_SUCCESS == ret)
  {
    int64_t view_size = drop_view_stmt->get_view_size();
    ObString view_name;
    char dn[OB_MAX_DATBASE_NAME_LENGTH];
    char tn[OB_MAX_TABLE_NAME_LENGTH];
    ObString dname;
    ObString tname;
    dname.assign_buffer(dn, OB_MAX_DATBASE_NAME_LENGTH);
    tname.assign_buffer(tn, OB_MAX_TABLE_NAME_LENGTH);
    for(int64_t i = 0; i < view_size; i++)
    {
      view_name = drop_view_stmt->get_view_name(i);
      if(!view_name.split_two(dname, tname))
      {
        TRANS_LOG("view name[%.*s] is invalid", view_name.length(), view_name.ptr());
        break;
      }
      else if (OB_SUCCESS != (ret = check_dbname_for_table(err_stat, dname)))
      {
        TRANS_LOG("drop view failed because the database name [%.*s] not exist", dname.length(), dname.ptr());
        break;
      }
    }
  }
  //generate operator
  if (ret == OB_SUCCESS)
  {
    CREATE_PHY_OPERRATOR(drop_view_op, ObDropView, physical_plan, err_stat);
    if(ret == OB_SUCCESS)
    {
      drop_view_op->set_rpc_stub(sql_context_->rs_rpc_proxy_);
      drop_view_op->set_sql_context(*sql_context_);
      ret = add_phy_query(logical_plan, physical_plan, err_stat, query_id, drop_view_stmt, drop_view_op, index);
    }
  }
  if(ret == OB_SUCCESS)
  {
    bool disallow_drop_sys_table = sql_context_->session_info_->is_create_sys_table_disabled();
    drop_view_op->set_if_exists(drop_view_stmt->get_if_exists());
    for(int64_t i = 0; ret == OB_SUCCESS && i < drop_view_stmt->get_view_id_size(); i++)
    {
      const ObString &table_name = drop_view_stmt->get_view_name(i);
      uint64_t tid = drop_view_stmt->get_view_id(i);
      if(TableSchema::is_system_table(table_name) && disallow_drop_sys_table)
      {
        ret = OB_ERR_NO_PRIVILEGE;
        YYSYS_LOG(USER_ERROR, "system table can not be dropped, table_name=[%.*s]", table_name.length(), table_name.ptr());
        break;
      }
      if((ret = drop_view_op->add_view_name(table_name)) != OB_SUCCESS)
      {
        TRANS_LOG("add drop view [%.*s] failed", table_name.length(), table_name.ptr());
        break;
      }
      else if((ret = drop_view_op->add_table_id(tid)) != OB_SUCCESS)
      {
        TRANS_LOG("add drop view [%.*s] table id failed", table_name.length(), table_name.ptr());
        break;
      }
    }
  }
  return ret;
}
