# YaoBase 多租户资源隔离架构设计

## 系统架构分析

### YaoBase架构特点

YaoBase采用极致解耦设计，包含两层LSM-tree，L0层和L1层分离存储，并且采用不同的分区方式：
- **L0层(增量数据)**：由TransServer(TS)管理，包含MemTable和SSTable
- **L1层(基线数据)**：由DataServer(DS)管理，以256M范围分片

关键组件：
- **AdminServer(AS)**：负责集群管理，保持和节点之间的心跳，感知节点上下线。负责管理元数据，副本负载均衡。
- **TransServer(TS)**：负责L0层的数据写入，包含MemTable和冻结到磁盘的SSTable。
- **SqlServer(SS)**：负责解析用户的SQL请求，并生成高效的分布式执行计划。
- **DataServer(DS)**：负责L1层的数据管理。

### 二期资源隔离需求分析

| 资源类型 | 隔离层级 | 隔离难点 | 解决方案 |
|----------|----------|----------|----------|
| CPU | SS | 已有项目改造，支持cgroup | - |
| 内存 | SS、TS | 多租户共享MemTable | 只在SS实现内存隔离，共享TS增量能力 |
| I/O | DS | 多租户共享基线数据 | 区分控制租户磁盘使用空间 |
| 网络带宽 | SS | 网络线程共享 | - |
| 事务能力 | TS | 不同租户有不同的raft架构 | - |
| 独立备份 | 集群 | 不同租户有不同的raft架构 | 租户定期备份恢复策略 |
| 资源过载告警 | / | / | 对租户已使用资源统计，提供查询接口 |

## 概要设计

综合需求和实现难度，CPU、内存资源只在SqlServer进行隔离，磁盘资源在DataServer进行控制，**TransServer作为数据库后端增量服务器为所有租户提供增量读写能力，不加入多租户隔离的对象，作为多租户共享的资源**。

抽象资源统计方法，对租户进行资源统计，包括租户在SqlServer已使用的内存，cpu资源，在DataServer已使用的磁盘资源；提供租户资源使用视图，为用户提供租户统一的资源统计、查询接口；

### CPU资源隔离

在SqlServer层面实现CPU资源隔离，支持基础模式（按配额比例分配工作线程）和cgroup精确控制。

### 内存资源隔离

在SqlServer层面实现内存配额控制，防止单个租户过度使用内存影响其他租户。

### 磁盘资源隔离

在DataServer层面控制租户磁盘使用总量，超限时禁止写入操作。

### 资源监控

各个server使用统一的抽象统计接口，SqlServer对CPU/MEMORY资源进行统计，DataServer对磁盘资源进行统计。

## SqlServer端CPU隔离详细设计

### 总体设计理念

#### 设计目标
- 在SqlServer层面实现租户级CPU资源隔离
- 支持两种隔离模式：基础模式（线程池比例分配）和cgroup模式（精确限制）
- 保证租户间CPU资源公平性，防止单个租户过度占用
- 保持系统整体性能开销可控（<5%）

#### 核心原则
- **租户感知**：在请求处理链路中始终传递租户上下文
- **渐进式**：先实现基础隔离，后支持高级cgroup功能
- **可配置**：通过配置项灵活控制隔离策略
- **可监控**：提供详细的CPU使用统计和告警机制

### 架构设计

#### 组件层次
```
SqlServer
├── ConnectionManager (连接管理)
│   ├── TenantAuthenticator (租户认证)
│   └── CpuQuotaChecker (CPU配额检查)
├── ThreadPoolManager (线程池管理)
│   ├── TenantThreadGroup (租户专用线程组)
│   └── CpuResourceAllocator (CPU资源分配器)
├── CpuMonitor (CPU监控)
│   ├── UsageCollector (使用量收集)
│   └── AlertManager (告警管理)
└── CgroupController (cgroup控制器，可选)
    ├── CpuSubsystem (CPU子系统)
    └── TenantCgroup (租户cgroup组)
```

#### 数据流设计
1. **请求接入**：客户端连接携带租户标识（user@tenant格式）
2. **认证授权**：验证租户身份和连接权限
3. **配额检查**：检查租户CPU配额是否充足
4. **资源分配**：为请求分配CPU资源（线程/时间片）
5. **执行监控**：实时监控CPU使用情况
6. **结果返回**：处理完成后释放资源

### 线程模型设计

#### 线程池架构
```
Global Thread Pool (120 threads)
├── Tenant A Thread Group (比例分配)
│   ├── Worker Thread 1
│   ├── Worker Thread 2
│   └── ...
├── Tenant B Thread Group (比例分配)
│   ├── Worker Thread 1
│   ├── Worker Thread 2
│   └── ...
└── System Thread Group (系统任务)
    ├── Maintenance Thread
    └── Monitor Thread
```

#### 线程池初始化
- **系统启动时**：创建固定大小的线程池（默认120个工作线程），初始化cgroup v1子系统
- **租户加载时**：根据CPU配额计算线程分配比例，为每个租户创建ThreadGroup和专属无锁TaskQueue

#### 租户线程组设计
- **结构**：包含租户ID、分配线程数、工作线程列表、无锁任务队列、cgroup控制器
- **工作线程**：从租户队列取任务执行，支持状态管理和监控
- **无锁任务队列**：基于CAS实现，支持批量操作和容量控制

#### 任务调度机制
- **提交流程**：SQL请求 → 租户认证 → 任务封装 → 推入租户队列 → 唤醒空闲线程
- **调度策略**：公平调度、优先级调度、负载均衡

### 核心组件设计

#### 租户上下文 (TenantContext)
- **职责**：存储租户基本信息和CPU配额
- **属性**：tenantId、cpuQuota、connectionList、enableCgroup
- **生命周期**：随租户创建/销毁

#### CPU资源管理器 (CpuResourceManager)
- **职责**：统一管理CPU资源的分配和回收
- **功能**：配额分配、资源预留、动态调整、超限处理

#### 线程池管理器 (ThreadPoolManager)
- **职责**：管理租户专用线程池
- **设计**：多租户共享物理线程池但逻辑隔离，根据配额动态调整

#### CPU监控器 (CpuMonitor)
- **职责**：实时监控和统计CPU使用情况
- **指标**：租户CPU使用率、时间消耗、系统利用率、cgroup限制命中率

### cgroup v1集成设计

#### 层次结构
```
/sys/fs/cgroup/cpu/yaobase/
├── tenant_a/ (cpu.shares = 1024)
├── tenant_b/ (cpu.shares = 2048)
└── system/ (cpu.shares = 512)
```

#### 控制器实现
- **份额分配**：根据CPU配额比例设置cpu.shares
- **进程管理**：动态管理线程PID在cgroup中的添加/移除
- **监控集成**：读取cpuacct统计信息

### 工作流程设计

#### 请求处理流程
```
客户端请求 → 连接建立 → 租户认证 → CPU配额检查 → 线程分配 → SQL执行 → 监控统计 → 结果返回
```

#### CPU分配策略
1. **基础模式**：根据配额比例分配工作线程
2. **cgroup模式**：使用Linux cgroup精确限制CPU使用量

#### 超限处理策略
- **软限制**：记录告警，继续处理但降低优先级
- **硬限制**：拒绝新请求
- **优雅降级**：高负载时对低优先级租户限流

### 配置管理设计

#### 租户级配置
- cpu: CPU核心数配额
- enable_cgroup: 是否启用cgroup隔离
- cpu_soft_limit: 软限制阈值
- cpu_hard_limit: 硬限制阈值

#### 系统级配置
- default_cpu_quota: 默认配额
- cgroup_enabled: 系统cgroup支持
- monitor_interval: 监控间隔

### 监控和告警设计

#### 监控指标
- tenant_cpu_usage: 租户CPU使用率
- tenant_cpu_throttled: 被限制的CPU时间
- system_cpu_utilization: 系统CPU利用率
- tenant_request_queue_length: 请求队列长度

#### 告警规则
- CPU使用率持续超过软限制5分钟触发警告
- 超过硬限制立即告警
- cgroup限制命中率过高触发优化建议

#### 统计接口
```sql
SELECT * FROM __all_virtual_tenant_cpu_status;
```

### 异常处理和容错设计

#### 异常场景
- cgroup初始化失败：降级到基础模式
- 配额配置错误：使用默认配额
- 监控数据收集失败：记录错误但不中断服务

#### 容错机制
- 配置热更新：运行时调整无重启
- 降级策略：高级功能失败自动降级
- 资源清理：租户删除时完全释放资源

### 性能优化考虑

#### 同步开销最小化
- 无锁队列减少同步
- 批量操作减少系统调用
- 缓存友好优化数据局部性

#### 内存管理
- 对象池复用Task对象
- 预分配队列空间
- 及时清理完成任务

#### CPU亲和性
- NUMA感知考虑处理器拓扑
- 缓存优化减少跨核通信

### 测试性设计

#### 单元测试
- 组件接口抽象便于测试
- 依赖注入支持Mock对象
- 并发测试验证多线程正确性

#### 集成测试
- 负载测试验证高并发
- 配置测试验证动态调整
- 故障注入测试异常处理

## 设计原则

- **最小侵入**：尽量减少对现有架构的修改
- **渐进式**：先实现基础资源隔离，后续可扩展
- **租户感知**：在关键路径传递租户上下文，实现资源隔离
- **可配置**：提供灵活的配置选项，适应不同业务场景
- **可监控**：提供一定的资源使用监控能力

## 隔离层级设计

| 组件 | 隔离策略 | 说明 |
|------|----------|------|
| AdminServer (AS) | 共享 | 集群管理，内存使用稳定 |
| SqlServer (SS) | 隔离 | CPU、内存资源隔离 |
| TransServer (TS) | 共享 | 增量数据服务，自动合并释放内存 |
| DataServer (DS) | 隔离 | 磁盘资源隔离 |

## 关键技术点

1. **租户上下文传递**：在请求链路中传递租户ID
2. **资源统计抽象**：统一的资源统计接口
3. **cgroup集成**：可选的Linux cgroup支持
4. **配额检查**：在资源分配前检查配额

## 约束与限制

### 功能限制

- **磁盘资源控制的延迟性**：磁盘超限在数据合并后才会检测，不会立即报错
- **内存隔离不作用于TransServer**：TS为共享资源，不隔离（自动合并释放内存）
- **数据隔离程度有限**：多租户共享RAFT架构、LSM-tree、raft日志
- **事务处理能力隔离受限**：受限于共享的TS RAFT组结构

### 使用建议

- 对于有严格数据隔离需求的场景，建议使用独立集群
- 资源配置应与实际业务负载相匹配
- 高优先级租户应配置适当的资源余量
- 定期监控资源使用情况